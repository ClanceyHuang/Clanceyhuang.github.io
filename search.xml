<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python3的一个沙箱逃逸技巧</title>
      <link href="2021/04/01/sandboxEscapePy3/"/>
      <url>2021/04/01/sandboxEscapePy3/</url>
      
        <content type="html"><![CDATA[<p>Emil Lerner(twitter @emil_lerner) 上个月发了个<a href="//twitter.com/emil_lerner/status/1369221697145016322">推</a>，当时看到了没想到很好的解决方法。</p><span id="more"></span><p>他提出了这样一个问题:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">code = <span class="built_in">input</span>()</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">&#x27;hui&quot;\&#x27;(&#x27;</span>:</span><br><span class="line">    <span class="keyword">assert</span> c <span class="keyword">not</span> <span class="keyword">in</span> code</span><br><span class="line"><span class="built_in">exec</span>(code, &#123;<span class="string">&#x27;__builtins__&#x27;</span>: &#123;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>3月15号的时候 Arthur Khashaev (twitter @Invizory)给了个<a href="https://gist.github.com/Invizory/36b5c4e037548b940c831efe350162d2">解法</a>，惊为天人，来和大家分享一下。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">b=[].__class__.__base__</span><br><span class="line">d=[].__doc__</span><br><span class="line">n=d.__doc__[<span class="number">31</span>]</span><br><span class="line">__bultns__[n+n+d[<span class="number">13</span>]+d[<span class="number">1</span>:<span class="number">4</span>]+d[<span class="number">139</span>]+n+d[<span class="number">23</span>]+d[<span class="number">3</span>]+d[<span class="number">12</span>]+d[<span class="number">17</span>]*<span class="number">2</span>+n+n]=<span class="keyword">lambda</span>*_:b</span><br><span class="line"><span class="meta">@b.__class__.__subclasses__</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">s</span>:</span>_</span><br><span class="line"><span class="meta">@s[<span class="number">84</span>].load_module</span></span><br><span class="line"><span class="meta">@lambda _:d[<span class="number">32</span>]+d[<span class="number">17</span>]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">o</span>:</span>_</span><br><span class="line"><span class="meta">@o.system</span></span><br><span class="line"><span class="meta">@lambda _:d[<span class="number">2</span>]+d[<span class="number">139</span>]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_</span>:</span>_</span><br></pre></td></tr></table></figure><h2 id="identifier-过滤绕过"><a class="markdownIt-Anchor" href="#identifier-过滤绕过"></a> identifier 过滤绕过</h2><p>这段代码的第一个神奇之处就在于 python3 的 interpreter 竟然会做 unicode normalize，这个特性总<br />感觉以前从来没看过，经过一定的考证找到了<a href="https://docs.python.org/3/reference/lexical_analysis.html#identifiers">实据</a>:<br />文档中写到:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Python 3.0 introduces additional characters from outside the ASCII range (see PEP 3131). </span><br><span class="line">For these characters, the classification uses the version of the Unicode Character Database as included in the unicodedata module.</span><br></pre></td></tr></table></figure><p>从 python 3.0 引入的对 name 的处理，从 <a href="https://www.python.org/dev/peps/pep-3131/#implementation">PEP 3131</a> 中可知:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The following changes will need to be made to the parser:</span><br><span class="line"></span><br><span class="line">If a non-ASCII character is found in the UTF-8 representation of the source code, a forward scan is made to find the first ASCII non-identifier character (e.g. a space or punctuation character) The entire UTF-8 string is passed to a function to normalize the string to NFKC, and then verify that it follows the identifier syntax. No such callout is made for pure-ASCII identifiers, which continue to be parsed the way they are today. The Unicode database must start including the Other_ID_&#123;Start|Continue&#125; property. If this specification is implemented for 2.x, reflective libraries (such as pydoc) must be verified to continue to work when Unicode strings appear in __dict__ slots as keys.</span><br></pre></td></tr></table></figure><p>具体来说就是如果 id 名称使用了非 ASCII 字符，则会将整个 name 传给 unicodedb 去做 NFKC normalize，也就是说这些字符会被自动的替换，从而正常解析。<br />因此 Python 3 起针对 identifier 的过滤都可以使用该方法绕过。</p><h2 id="函数调用绕过"><a class="markdownIt-Anchor" href="#函数调用绕过"></a> 函数调用绕过</h2><p>本题第二个难点在于，不允许使用左括号，因此无法做直接的函数调用。有同学就要说了，可以通过修 改 <strong>add</strong> 等默认行为来做间接的函数调用，不过我没有找到内置的可以直接修改 <strong>add</strong> 属性的 对象，若有发现望告知。<br />Arthur 使用的方法比较巧妙，通过修改 <strong>build_class</strong> 从而修改了声明 class 时的默认行为，</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__bultns__[n+n+d[<span class="number">13</span>]+d[<span class="number">1</span>:<span class="number">4</span>]+d[<span class="number">139</span>]+n+d[<span class="number">23</span>]+d[<span class="number">3</span>]+d[<span class="number">12</span>]+d[<span class="number">17</span>]*<span class="number">2</span>+n+n]=<span class="keyword">lambda</span>*_:b</span><br></pre></td></tr></table></figure><p>这一行将修改创建 class 时的默认行为，使得每个 class 声明都会返回 object type:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__builtins__[<span class="string">&#x27;__build_class__&#x27;</span>] = <span class="keyword">lambda</span>*_:b</span><br></pre></td></tr></table></figure><p>而这里:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@b.__class__.__subclasses__ </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">s</span>:</span>_</span><br></pre></td></tr></table></figure><p>在创建 class 的时候相当于让</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = b(func, name, /, *bases, [metaclass], **kwds) <span class="comment"># 即 s = object</span></span><br><span class="line">s = b.__class__.__subclasses__(s) <span class="comment"># 即 s = b.__class__.__subclasses__(object)</span></span><br></pre></td></tr></table></figure><p>从而通过 class s 获得了object的子类列表<br />后续原理类似不再赘述。这个形势有些类似于 PHP 中的回调型后⻔，对于 function 其实也有类似的形<br />势可以达到一样的效果:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@b.__class__.__subclasses__ </span></span><br><span class="line"><span class="meta">@c</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">d</span>():</span> <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>因此值得讨论的问题转化为了: python 中的类似回调的行为都有哪些呢?</p>]]></content>
      
      
      <categories>
          
          <category> sec </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows10下WSL开发环境搭建</title>
      <link href="2021/01/20/tipsWSL/"/>
      <url>2021/01/20/tipsWSL/</url>
      
        <content type="html"><![CDATA[<p>工作环境的一架台式机是<code>Windows10</code>系统，<code>Windows</code>系统对开发者来说并不是很友好（<code>.net</code>及<code>Windows</code>内核开发者除外，比如一些扩展包，例如<code>PHP</code>的<code>swoole</code>，在<code>Windows</code>上现在没有直接安装的解决方案）。</p><span id="more"></span><p>刚开始一段时间(<code>WSL</code>没有出来那会，也不想用虚拟机和<code>Docker</code>)把台式机改成<code>Linux</code>系统，但是呢，各种办公软件在<code>Linux</code>平台就很糟心了，比如微信、QQ 这些软件，在<code>Linux</code>没有官方版本，通过黑科技进行移植的版本会出现各种故障，比如发送文档都得做磁盘空间共享，简直让人崩溃。</p><p>如果是纯粹只负责写代码的工作场景倒无所谓了，但是需要和客户、同事进行沟通，涉及到视频、音频、文件传输，简直炸毛。。。</p><h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2><p>某天装备升级强化了下，内存有<code>16G</code>，试着安装了<code>Windows</code>的<code>WSL</code>，这是微软自研的架构，为了兼容<code>Linux</code>内核。简单来讲就是<code>Windows</code>系统内置了一套<code>Linux</code>内核，直接做了系统间的映射。</p><h2 id="准备"><a class="markdownIt-Anchor" href="#准备"></a> 准备</h2><h3 id="材料"><a class="markdownIt-Anchor" href="#材料"></a> 材料</h3><ul><li>Windows10</li><li>wsl</li><li>Ubuntu18.appx</li></ul><h3 id="wsl-环境初始化"><a class="markdownIt-Anchor" href="#wsl-环境初始化"></a> WSL 环境初始化</h3><p>打开<code>Windows</code>自带的<code>power shell</code>终端，执行<code>Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux</code>命令，就在<code>Windows</code>上安装好了<code>wsl</code>环境。</p><p>接着下载一份<code>Ubuntu18.04</code>镜像，同样是在<code>power shell</code>终端执行命令<code>Invoke-WebRequest -Uri https://aka.ms/wsl-ubuntu-1804 -OutFile Ubuntu.appx -UseBasicParsing</code>，当前目录路径下就会出现一个<code>Ubuntu</code>的<code>appx</code>软件，点击安装即可。</p><h3 id="ubuntu-配置"><a class="markdownIt-Anchor" href="#ubuntu-配置"></a> Ubuntu 配置</h3><p>点击安装<code>Ubuntu.appx</code>后，系统会弹出一个黑色窗口，提示你输入<code>unix</code>系统的用户名及密码，正常配置即可。</p><h4 id="修改镜像源"><a class="markdownIt-Anchor" href="#修改镜像源"></a> 修改镜像源</h4><p>我们需要把<code>Linux</code>系统的软件镜像地址改成国内的镜像地址，否则安装软件包会卡到你怀疑人生，我们先到网上搜索一下<code>Ubuntu18</code>国内镜像源（这里选用了阿里的镜像源），源链接如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># alibaba source list</span></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure><p>得到需要的源链接后，再到<code>Ubuntu</code>系统里更改源文件即可，命令操作如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先备份原文件</span></span><br><span class="line">sudo cp /etc/apt/source.list /etc/apt/source.list-back</span><br><span class="line"><span class="comment"># 再更改原文件</span></span><br><span class="line">sudo vim /etc/apt/source.list</span><br><span class="line"><span class="comment"># 将上面的源链接拷贝进来，再保存退出</span></span><br><span class="line"><span class="comment"># 更新系统的源包管理</span></span><br><span class="line">sudo apt-get update &amp;&amp; sudo apt-get upgrade -y</span><br></pre></td></tr></table></figure><p>这样，我们就配置好了国内镜像源。</p><h4 id="部署-nginx"><a class="markdownIt-Anchor" href="#部署-nginx"></a> 部署 nginx</h4><p><code>web</code>开发，一般<code>web</code>代理服务器选择<code>apache</code>或者<code>nginx</code>，这里讲<code>nginx</code>的部署，相应的操作命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装nginx，等待一段时间即可。</span></span><br><span class="line">sudo apt-get install nginx</span><br><span class="line"><span class="comment"># 创建我们的vhost文件夹</span></span><br><span class="line">mkdir ~/vhost</span><br><span class="line"><span class="comment"># 更改nginx配置</span></span><br><span class="line">sudo vim /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><ul><li>在 include /etc/nginx/site-avaliable 下引入我们的 vhost 文件夹：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include /home/kirk/vhost/*.conf;</span><br></pre></td></tr></table></figure><ul><li>本地 hosts 配置下开发域名</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/hosts</span><br><span class="line"><span class="comment"># 增加一条指向记录</span></span><br><span class="line">127.0.0.1 api.kirk.com</span><br></pre></td></tr></table></figure><ul><li>编写 vhost 文件,如 vim ~/vhost/Kirk.conf</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># API 解析</span></span><br><span class="line">server &#123;</span><br><span class="line">    listen        80;</span><br><span class="line">    server_name  api.kirk.com;</span><br><span class="line">    <span class="comment"># 这里的项目地址是宿主机的项目地址，因为在Windows内置的Linux系统中，读取宿主机Windows文件的方式是使用挂载的模式，</span></span><br><span class="line">    <span class="comment"># 把Windows系统盘当成挂在盘进行处理，例如/mnt/d表示Windows的D盘，我们在D盘github/kirk文件夹下写了一个php文件，里面打印一个phpinfo();</span></span><br><span class="line">    root   <span class="string">&quot;/mnt/d/github/kirk&quot;</span>;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        index index.php index.html error/index.html;</span><br><span class="line">        <span class="keyword">if</span> (!-e <span class="variable">$request_filename</span>) &#123;</span><br><span class="line">            rewrite  ^(.*)$  /index.php?s=/<span class="variable">$1</span>  last;</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        autoindex  off;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ \.php(.*)$ &#123;</span><br><span class="line">        <span class="comment"># 记住这里fastcgi监听的是9004端口，后面配置php-fpm的时候会用到，因为fastcgi要和php-fpm端口保持统一</span></span><br><span class="line">        fastcgi_pass   127.0.0.1:9004;</span><br><span class="line">        fastcgi_index  index.php;</span><br><span class="line">        fastcgi_split_path_info  ^((?U).+\.php)(/?.+)$;</span><br><span class="line">        fastcgi_param  SCRIPT_FILENAME  $document_root<span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">        fastcgi_param  PATH_INFO  <span class="variable">$fastcgi_path_info</span>;</span><br><span class="line">        fastcgi_param  PATH_TRANSLATED  $document_root<span class="variable">$fastcgi_path_info</span>;</span><br><span class="line">        include        fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存完<code>conf</code>文件后，再执行<code>sudo service nginx reload</code>进行重载<code>nginx</code>的配置。</p><h4 id="安装-php"><a class="markdownIt-Anchor" href="#安装-php"></a> 安装 php</h4><p>这里选用了<code>php74</code>版本，具体命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先安装一个软件中心组件</span></span><br><span class="line">sudo apt-get install software-properties-common</span><br><span class="line"><span class="comment"># 再添加一个php的第三方源（因为官方源的php版本不大适用，一个是版本少，另一个是扩展包比较少）</span></span><br><span class="line">sudo add-apt-repository ppa:ondrej/php</span><br><span class="line"><span class="comment"># 再刷新一下包管理器</span></span><br><span class="line">sudo apt-get update</span><br><span class="line"><span class="comment"># 安装对应版本的php及扩展包，扩展包自行按需添加</span></span><br><span class="line">sudo apt-get install php7.4 php7.4-fpm php7.4-mysql php7.4-gd php7.4-mbstring php7.4-redis</span><br></pre></td></tr></table></figure><p>处理<code>php-fpm</code>，操作如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改php-fpm监听的端口，与nginx的fastcgi保持一致</span></span><br><span class="line">sudo vim /etc/php/74/fpm/pool.d/www.conf</span><br><span class="line"><span class="comment"># 找到listen = /run/php/php7.4-fpm.sock ,并改成下面的监听配置</span></span><br><span class="line">listen = 127.0.0.1:9004</span><br><span class="line"><span class="comment"># 修改保存成功后，重启php-fpm即可</span></span><br><span class="line">sudo service php7.4-fpm restart</span><br></pre></td></tr></table></figure><p>这样打开<code>Windows</code>的浏览器，访问我们刚刚配置的站点<code>http://api.kirk.com</code>，出现<code>php</code>版本信息即表示配置成功。</p><p>然后，看了下性能损耗，<code>Windows</code>基本的应用加上<code>wsl</code>共消耗<code>3G</code>内存，还是比集成软件<code>PHPstudy</code>节省了一丢丢内存，最主要的是以前<code>Windows</code>不能安装的扩展现在可以随意安装了~</p><p>再试着打开微信、企业微信、开发软件 IDE，好家伙，直接达到<code>8G</code>内存，平时半天没有回复你们信息不是故意不回，是电脑卡死了在等待。</p><h4 id="安装-python-环境"><a class="markdownIt-Anchor" href="#安装-python-环境"></a> 安装 python 环境</h4><p>单单只有一个<code>php</code>怎么玩数据呢，需要部署下<code>python</code>，<code>Ubuntu</code>自带了<code>python3</code>，但是我们需要按照不同项目做环境隔离，所以需要特殊处理下隔离软件的配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先看看Ubuntu有没有自带python3，执行如下命令</span></span><br><span class="line">python3</span><br><span class="line"><span class="comment"># 如果进入了python3操作界面，表示系统已安装，反之需要我们自己安装.</span></span><br><span class="line"><span class="comment"># 安装命令</span></span><br><span class="line">sudo apt-get install python3</span><br><span class="line"><span class="comment"># 验证是否安装pip 包管理器</span></span><br><span class="line">pip3 -V</span><br><span class="line"><span class="comment"># 如果没有出现pip3的版本信息，代表系统没有安装，需要我们手动安装</span></span><br><span class="line">sudo apt-get install pip3</span><br><span class="line"><span class="comment"># 安装好了之后，开始安装python虚拟环境</span></span><br><span class="line">sudo pip3 install virtualenv</span><br><span class="line">sudo pip3 install virtualenvwrapper</span><br><span class="line"><span class="comment"># 配置包引导</span></span><br><span class="line">sudo vim ~/.bashrc</span><br><span class="line"><span class="comment"># 在最后加上这几条命令，分别表示1.虚拟环境的工作目录。2.虚拟包用python3进行驱动。3.加载虚拟包执行脚本。</span></span><br><span class="line"><span class="built_in">export</span> WORKON_HOME=<span class="variable">$HOME</span>/.virtualenvs</span><br><span class="line"><span class="built_in">export</span> VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3</span><br><span class="line"><span class="built_in">source</span> ~/.<span class="built_in">local</span>/bin/virtualenvwrapper.sh</span><br><span class="line"><span class="comment"># 保存退出后</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"><span class="comment"># 这样python虚拟环境管理包就配置好了，我们可以用如下命令创建对应的虚拟环境</span></span><br><span class="line">mkvirtualenv -p python3 Kirk</span><br><span class="line"><span class="comment"># 退出python虚拟环境</span></span><br><span class="line">deactive</span><br><span class="line"><span class="comment"># 删除对应虚拟环境</span></span><br><span class="line">rmvirtualenv Kirk</span><br></pre></td></tr></table></figure><p>这样通过<code>virtualenvwrapper</code>进行管理<code>python</code>的虚拟环境，从而实现不同的项目使用不同的<code>python</code>包管理。</p><p>其他的环境配置会陆续更新，to be continue…</p>]]></content>
      
      
      <categories>
          
          <category> tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DiyExpress - 自定义表达式计算引擎</title>
      <link href="2020/12/09/devDiyExpress/"/>
      <url>2020/12/09/devDiyExpress/</url>
      
        <content type="html"><![CDATA[<p>我们在数据分析的业务上，经常会有一些比较脑洞大开却又很实用的需求。</p><p>比如有个场景，当我们将数据分析的”自主权“交给用户。</p><span id="more"></span><p>由用户来决定自己需要计算分析什么维度的数据，这个需求确实是一个痛点，能解决这个需求，不就是为用户创造了价值么。</p><p>因此，花了点时间写了一套自定义表达式计算引擎。<br />已知用户是有一定<code>Excel</code>公式基础的，需要提供一个交互界面让他输入他定义的类似<code>Excel</code>公式的一段简单公式，其中的各个参数是自定义表单中各个字段所填充的数据。如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;销售返现&#125;&#125;=if ( &#123;&#123;数量&#125;&#125; &gt;= <span class="number">100</span> AND (&#123;&#123;产品类型&#125;&#125; == &#x27;产品A&#x27; OR &#123;&#123;产品类型&#125;&#125; == &#x27;产品B&#x27;), &#123;&#123;成单金额&#125;&#125; * <span class="number">0.7</span>, &#123;&#123;成单金额&#125;&#125;*<span class="number">0.5</span>) + <span class="number">100</span></span><br></pre></td></tr></table></figure><p>双花括号里面的是指定的字段（用来代表该字段的取值 data），单引号或者双引号是指定的取值。</p><p>我们的目标是程序根据用户定义的公式计算对应的数据，那么核心点在于如何识别用户定义的公式。</p><p>依旧是被“自定义”给坑了，需要识别用户定义的公式只能上一个词法分析器了，根据大三学的编译原理，徒手撸个状态机。。</p><p>考虑到能用脚本语言就用脚本语言，技术选型用的<code>PHP</code>,源码放在 github 上，<a href="https://github.com/ClanceyHuang/DiyExpress" title="https://github.com/ClanceyHuang/DiyExpress">DiyExpress</a>。</p><h2 id="贮备知识点"><a class="markdownIt-Anchor" href="#贮备知识点"></a> 贮备知识点</h2><h3 id="ast-节点树"><a class="markdownIt-Anchor" href="#ast-节点树"></a> AST 节点树</h3><p>AST (Abstract Syntax Tree(抽象语法树)) 是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构。它由一堆节点（Node）组成，每个节点都表示源代码中的一种结构。不同结构用类型来区分，常见的类型有： Identifier(标识符)，BinaryExpression(二元表达式)，VariableDeclaration(变量定义)，FunctionDeclaration(函数定义)等。</p><p>AST 是编译器看的。编译器会将源码转化成 AST。如下源码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = 42;</span><br><span class="line">var b = 5;</span><br><span class="line">function addA(d) &#123;</span><br><span class="line">    return a + d;</span><br><span class="line">&#125;</span><br><span class="line">var c = addA(2) + b;</span><br></pre></td></tr></table></figure><p>会换转化成这样的 AST:</p><p><img src="/images/diyRule01.png" alt="ast" title="ast" /></p><h3 id="ast-的使用场景"><a class="markdownIt-Anchor" href="#ast-的使用场景"></a> AST 的使用场景？</h3><p><code>TypeScript</code>、<code>babel</code>、<code>webpack</code>、<code>vue-cli</code>等都是依赖<code>AST</code>进行开发的。</p><p>通过<code>AST</code>，可以将代码转化后，再输出。比如：</p><ul><li>代码压缩。删除没用的空格，未使用的语句，变量名替换等。</li><li>代码高亮。</li><li>将 <code>ES6</code> 代码转换成 <code>ES5</code> 代码。</li><li>给 <code>CSS</code> 中的某些属性加浏览器前缀<code>-webkit-</code>。</li><li>将 <code>CSS</code> 中的<code>px</code>转化成<code>rem</code>。</li><li>生成代码。最近用了<code>ANT DESIGN PRO</code>。 <code>ANT DESIGN PRO</code> 中的 <code>umi</code> 可以在生成页面的代码和路由时，修改路由配置的<code>js</code>。<code>umi</code> 这种方式，用户体验很好。因此，我准备用这种方式来改造我之前做的代码生成工具。修改路由配置需要通过 AST 来转换代码。</li></ul><h3 id="需要学习-ast-的哪些知识"><a class="markdownIt-Anchor" href="#需要学习-ast-的哪些知识"></a> 需要学习 <code>AST</code> 的哪些知识？</h3><ol><li>了解 AST 常见节点的结构</li></ol><p>了解 AST 常见节点的结构推荐通读下<code>AST node</code> 规范。</p><ol start="2"><li>源码解析</li></ol><p>将源码转化为<code>AST</code>。该步骤分为词法分析（<code>Lexical Analysis</code>）和 语法分析（<code>Syntactic Analysis</code>）。<br />解析 <code>JavaScript</code> 可以用<code>@babel/parser</code>(以前叫 <code>Babylon</code>)。</p><ol start="3"><li>转换</li></ol><p>在遍历<code>AST</code>时，对指定的<code>AST</code>节点做新增，修改或删除操作。<br />转换可以用<code>@babel/traverse</code>。<br />创建和验证节点可以用<code>@babel/types</code>。创建<code>AST</code>节点代码示例见这里。</p><ol start="4"><li>生成目标代码</li></ol><p>将上一步转换过的<code>AST</code>，转化为目标代码，并生成源码映射（<code>source maps</code>）。<br />生成目标代码可以用<code>@babel/generator</code></p><p>To be continue…</p>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Window10下双系统grub修复</title>
      <link href="2020/03/15/tipsDoubleSystem/"/>
      <url>2020/03/15/tipsDoubleSystem/</url>
      
        <content type="html"><![CDATA[<p>起因是我的笔记本<code>window10</code>在某次更新升级时，将之前设置好的双系统引导破坏了，导致进入<code>Linux</code>系统时提示<code>Unknown filesystem</code>。</p><span id="more"></span><p>首先能确定的是<code>Linux</code>的引导读取出了问题，才进入到了<code>grub rescue</code>模式。如果记得自己的<code>Linux</code>引导安装在哪个区块可以直接重新读取引导（这个得看你安装双系统的时候，把<code>Linux</code>的引导装在哪个分区），如果不记得，就执行下面的命令输出<code>gpt</code>分区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure><p>这样会显示出你所有的分区，再一个一个试试下面的命令（我的引导安装在<code>gpt7</code>区块上）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls (hd0,gpt7)\boot\grub</span><br></pre></td></tr></table></figure><p>其他不是引导所在的分区都是提示<code>error: unknown filesystem</code>。找到了所在的分区会提示该目录下的文件目录。<br />假定你们也是<code>(hd0,gpt7)</code>分区，依次执行下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> root=(hd0,gpt7),</span><br><span class="line"><span class="built_in">set</span> prefix=(hd0,gpt7)/boot/grub</span><br><span class="line">insmod normal,</span><br><span class="line">normal</span><br></pre></td></tr></table></figure><p>执行完毕会进入<code>Linux</code>启动的图形界面。<br />进入<code>Linux</code>系统后，打开终端执行以下命令重新安装<code>grub</code>引导：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo update-grub</span><br><span class="line">sudo grub-install /dev/sda</span><br></pre></td></tr></table></figure><p>再重启，就能恢复到正常<code>Linux</code>的启动引导了。</p>]]></content>
      
      
      <categories>
          
          <category> tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自定义表单设计及实现方案</title>
      <link href="2020/02/03/devDiyForm/"/>
      <url>2020/02/03/devDiyForm/</url>
      
        <content type="html"><![CDATA[<p>如何设计一款高度自定义的表单系统？<br /><code>自定义</code>意味着<code>表单数量不确定</code>，每个表单<code>字段数量不确定</code>，每个字段<code>类型不确定</code>，<code>存储量不确定</code>，等等一切都是<code>未知</code>的。</p><span id="more"></span><p>以及之后如何建立索引，如何搜索定位指定的数据？这些问题都将在下面的方案中进行解答。</p><h3 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h3><p>为了实现某个比较<code>脑洞大开</code>的需求，建立自定义表单，而且，还限定了前置条件—技术选型不许复杂，数据存储只能基于<code>mysql</code>, So…</p><h3 id="所谓的自定义表设计"><a class="markdownIt-Anchor" href="#所谓的自定义表设计"></a> 所谓的“自定义”（表设计）</h3><p>我们会定义这么几张表，用来实现自定义模板的大致框架。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">diy_field_pool      字段池（我们定义好的字段类型）</span><br><span class="line">diy_form            表单表（记录用户自定义的表单）</span><br><span class="line">diy_form_field      表单字段表（记录某张表单中有哪些字段）</span><br><span class="line">diy_form_entity     表单实例表（记录某张表单中的某条数据实例）</span><br><span class="line">diy_form_data       表单数据表（记录某张表单在某条实例下，哪些字段对应的数据）</span><br></pre></td></tr></table></figure><h4 id="系统初始化字段池"><a class="markdownIt-Anchor" href="#系统初始化字段池"></a> 系统初始化字段池</h4><p>我们提供一批预定义的字段类型，初始化数据到<code>diy_field_pool</code>表中，用户也能自己定义自己的字段池。</p><h4 id="用户创建自定义表单"><a class="markdownIt-Anchor" href="#用户创建自定义表单"></a> 用户创建自定义表单</h4><p>用户通过选用字段池（<code>diy_field_pool</code>表）中提供的字段，创建一张自定义表单，表单的属性信息记录在<code>diy_form</code>表中，表单包含的字段（从字段池中选好的字段）记录在<code>diy_form_field</code>表中。这样用户就创建了一张自定义表单。</p><h4 id="用户填写表单"><a class="markdownIt-Anchor" href="#用户填写表单"></a> 用户填写表单</h4><p>用户使用创建好的表单填写数据，每新增一条数据，在<code>diy_form_entity</code>表就会新增一条记录，该表单中有几个<code>field</code>，就会同时在<code>diy_form_data</code>表中新增几条 data 数据。数据结构关系如下图所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">diy_form    ------ diy_enity</span><br><span class="line">|                   |</span><br><span class="line">|---diy_field       |---diy_data</span><br><span class="line">|                   |</span><br><span class="line">|---diy_field       |---diy_data</span><br><span class="line">|                   |</span><br><span class="line">|---diy_field       |---diy_data</span><br><span class="line">|                   |</span><br><span class="line">|---diy_field       |---diy_data</span><br><span class="line">|                   |</span><br><span class="line">|---diy_field       |---diy_data</span><br><span class="line">|                   |</span><br><span class="line">|---diy_field       |---diy_data</span><br><span class="line">|                   |</span><br><span class="line">|...</span><br></pre></td></tr></table></figure><h3 id="如何进行数据搜索"><a class="markdownIt-Anchor" href="#如何进行数据搜索"></a> 如何进行数据搜索</h3><p>数据存储结构中，最终保存数据的地方其实是<code>data表</code>，但是，<code>data表</code>的辅助字段有<code>form表id</code>，<code>field表id</code>，<code>entity表id</code>，只有一个<code>content</code>字段是记录真实信息的，那么，如何搭建索引体系呢？</p><h4 id="采用-sphinx"><a class="markdownIt-Anchor" href="#采用-sphinx"></a> 采用 Sphinx</h4><p>构建<code>Sphinx</code>的<code>sql</code>语句时，将<code>data表</code>的<code>id</code>作为文档<code>id</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 公共的自定义模板的数据源</span></span><br><span class="line"><span class="built_in">source</span> diyCommonSource</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">type</span>            = mysql</span><br><span class="line">    sql_db          = diy</span><br><span class="line">    sql_host        = 127.0.0.1</span><br><span class="line">    sql_port        = 3306</span><br><span class="line">    sql_user        = root</span><br><span class="line">    sql_pass        = root</span><br><span class="line">    sql_query_pre   = SET NAMES utf8</span><br><span class="line"></span><br><span class="line">    sql_query   = \</span><br><span class="line">        select \</span><br><span class="line">        dfd.id, \</span><br><span class="line">        dfd.entity_id,dfd.content,dfd.createat,dfd.updateat, \</span><br><span class="line">        dff.id as field_id,dff.sys_id,dff.field, \</span><br><span class="line">        df.id as form_id \</span><br><span class="line">    from diy_form_data as dfd \</span><br><span class="line">        inner join diy_form_field as dff on dff.form_id=dfd.form_id and dff.is_delete=0 \</span><br><span class="line">        inner join diy_form as df on df.id=dff.form_id and df.is_delete=0 \</span><br><span class="line">    <span class="built_in">where</span> dfd.is_delete=0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 公共的自定义模板的索引</span></span><br><span class="line">index diyCommonIndex</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">source</span>          = diyCommonSource</span><br><span class="line">    path            = /var/<span class="built_in">local</span>/diy/sphinx/data/diyCommonIndex</span><br><span class="line">    docinfo         = extern</span><br><span class="line">    <span class="comment">#charset_type   = zh_cn.utf-8</span></span><br><span class="line">    charset_type    = utf-8</span><br><span class="line">    min_word_len    = 1</span><br><span class="line">    ngram_len       = 1</span><br><span class="line">    ngram_chars     = U+3000..U+2FA1F</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 范围：新闻模板（假定form_type为1）</span></span><br><span class="line"><span class="built_in">source</span> news:diyCommonSource</span><br><span class="line">&#123;</span><br><span class="line">    sql_query    = \</span><br><span class="line">        select \</span><br><span class="line">            dfd.id, \</span><br><span class="line">            dfd.entity_id,dfd.content,dfd.createat,dfd.updateat, \</span><br><span class="line">            dff.id as field_id,dff.sys_id,dff.field, \</span><br><span class="line">            df.id as form_id \</span><br><span class="line">        from pre_diy_form_data as dfd \</span><br><span class="line">            inner join pre_diy_form_field as dff \</span><br><span class="line">                and dff.form_id=dfd.form_id \</span><br><span class="line">                and dff.sys_id&gt;0 and dff.is_delete=0 \</span><br><span class="line">            inner join pre_diy_form as df \</span><br><span class="line">                and df.id=dff.form_id \</span><br><span class="line">                and df.is_delete=0 \</span><br><span class="line">                and df.form_type=1 \</span><br><span class="line">        <span class="built_in">where</span> dfd.is_delete=0</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用sql_attr设置的字段(搜索条件)，只能作为属性，使用SphinxClient::SetFilter()进行过滤；</span></span><br><span class="line">    <span class="comment"># 未被设置的字段，自动作为全文检索的字段，使用SphinxClient::Query(&quot;搜索字符串&quot;)进行全文搜索</span></span><br><span class="line">    <span class="comment"># sql_query第一列id需为整数，且被系统使用，无需再设置sql_attr_uint</span></span><br><span class="line">    sql_attr_uint       = form_id</span><br><span class="line">    sql_attr_uint       = field_id</span><br><span class="line">    sql_attr_uint       = field</span><br><span class="line">    sql_attr_uint       = entity_id</span><br><span class="line">    sql_attr_timestamp  = createat</span><br><span class="line">    sql_attr_timestamp  = updateat</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 构造商品模板的数据索引</span></span><br><span class="line">index news:diyCommonIndex</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">source</span>  = news</span><br><span class="line">    path    = /var/<span class="built_in">local</span>/diy/sphinx/data/news</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中，如果需要指定查找某些字段的数据，那么，以上面的数据源再重新定义数据源，sql 语句进一步指定 field 表的某个标志字段即可。</p>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>验证码识别</title>
      <link href="2019/05/10/devCrack/"/>
      <url>2019/05/10/devCrack/</url>
      
        <content type="html"><![CDATA[<p>通过训练卷积模型，让程序自动识别验证码。</p><span id="more"></span><h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2><p>运营人员审核某些用户提交的资质证书的时候，需要到规定的公示网站上去查询证书，大致操作是这些：</p><ol><li>到公示网站填写对应信息（证书编号等）</li><li>填写验证码（每次查询都会有校验码或者短信验证等等）</li><li>查看查询结果并比对证书<br />这一套流程下来，无疑是加大了审核员的工作量，而且每天审核的不止一张证书。一个比较迫切的需求就诞生了，<code>根据不同证书种类，分别去自动获取公示网站上该证书的信息</code>。</li></ol><p>假定以教师资质证书为例，该公示站点查询信息时，需要输入证书编号，图片验证码，即可返回该证书所对应的信息，运营人员比对用户上传的证书和站点公示的证书即可。</p><h2 id="方案一"><a class="markdownIt-Anchor" href="#方案一"></a> 方案一</h2><p>现在方案一是在我们自己的审核后台，将所有的数据（查询时需要的证书编号、姓名等等）都提取出来，封装成一个 post 请求数据，并将公示网站的验证码获取过来，在审核后台只留一个验证码的输入框给审核人员，输入正确的验证码，追加到 post 请求中，即可进行查询（该过程中会话交互验证的破解思路请自行摸索），将返回的数据结果进行切割处理，以比较好的交互方式呈现给运营人员。运营人员剩下的工作只要 check 一下信息即可。</p><p>ps：方案一的背后其实还进行了另一步操作，只要查询成功，就将这张验证码图片保存到本地服务器，运营人员输入的验证码作为图片名（这一步是关键，因为需要大量的训练样本进行模型训练，为方案二做铺垫）。</p><h2 id="方案二"><a class="markdownIt-Anchor" href="#方案二"></a> 方案二</h2><p>等一段时间后，将方案一保存下来的这批图片数据作为训练样本，去训练模型，也就是方案二，当模型的准确率达到了 0.9 以上，就可以实际拿过来使用了。（可能会说为什么不自动生成相似的验证码来进行训练，这也是一个思路，但准确率没有拿目标样本作为训练样本来的高，因为我们是不知道对方验证码的生成规则的，只能仿出一个大概相似的验证码。）</p><p>方案二部署上线的时候，只要用户提交了相关的证书信息，我们的系统就自动去公示网站上查询数据并将结果保存到数据库，这样运营人员只要在审核后台核对查询结果即可，也不用再输入验证码了。</p><p>为了更好的兼容，之前方案一预留的手动填写验证码功能也不会删减掉，防止出现系统无法自动识别验证码、获取不到查询数据的情况。这样如果系统自动查询到了数据运营人员就能直接审核，没有查询到数据，运营人员还能手动查一遍进行确认，同时还收集了验证码的训练样本。</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>方案二是在方案一使用一段时间后才能进行的，因为我们需要大量的训练样本，如果特意通过人工去获取数据（验证码图片）并打标签（每张图片所代表的验证码），无疑是会浪费很大的人力资源。<br />这样在方案一阶段，审核人员还是进行常规的审核操作，就顺便收集了对应的训练数据。等到执行案案二，就将审核员彻底解放出来，在需求（审核功能、上线时间）、成本（时间、人力）、技术实现（样本获取）上目前应该是最优解了。</p><h2 id="补充"><a class="markdownIt-Anchor" href="#补充"></a> 补充</h2><p>其实同时还是做了高仿目标站点的验证码，争取做到大致相同。然后<code>tensorflow</code>训练后的识别率达到<code>0.9</code>左右估计就差不多了。</p><p><a href="https://github.com/ClanceyHuang/CaptchaCraw" title="github.com/ClanceyHuang/CaptchaCraw">源码</a></p>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python封装Kafka客户端</title>
      <link href="2019/04/20/devKafka/"/>
      <url>2019/04/20/devKafka/</url>
      
        <content type="html"><![CDATA[<p>业务上处理<code>Kafka</code>主要就扣着“生产者”和“消费者”这个点就行，下面讲的是在<code>Python</code>中封装一个比较好用的<code>Kafka</code>客户端。</p><span id="more"></span><p>no bb, show code.直接上代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> pykafka <span class="keyword">import</span> KafkaClient</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KafkaTaskException</span>(<span class="params">Exception</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    在这里自定义KafkaTask类的异常</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParameterError</span>(<span class="params">KafkaTaskException</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    参数异常错误</span></span><br><span class="line"><span class="string">    _ParameterError_Key: 当 key 类型错误的时的抛错.</span></span><br><span class="line"><span class="string">    _ParameterError_Topic: 当 topic 类型错误的时的抛错.</span></span><br><span class="line"><span class="string">    _ParameterError_Consumer: 当初始化init_consumer 使用了错误的参数时抛错.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    _ParameterError_Key = <span class="string">&quot;ParameterError- type(s) for &#x27;Key&#x27;: must be bytes&quot;</span></span><br><span class="line">    _ParameterError_Topic = <span class="string">&quot;ParameterError- type(s) for &#x27;topic&#x27;: must be bytes&quot;</span></span><br><span class="line">    _ParameterError_pykafka_Consumer = <span class="string">&quot;ParameterError- type(s) for &#x27;topic&#x27;: must be bytes; &quot;</span> \</span><br><span class="line">                                       <span class="string">&quot;type(s) for &#x27;group_id&#x27;: must be str; &#x27;offset_type&#x27; &quot;</span> \</span><br><span class="line">                                       <span class="string">&quot;must be &#x27;LATEST&#x27; or &#x27;EARLIEST&#x27;&quot;</span></span><br><span class="line">    _ParameterError_kafka_Consumer = <span class="string">&quot;ParameterError- type(s) for &#x27;topic&#x27;: must be str; &quot;</span> \</span><br><span class="line">                                     <span class="string">&quot;type(s) for &#x27;group_id&#x27;: must be str; &#x27;offset_type&#x27; &quot;</span> \</span><br><span class="line">                                     <span class="string">&quot;must be &#x27;LATEST&#x27; or &#x27;EARLIEST&#x27;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KafkaTask</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    封装一个pykafka的客户端方法</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, server</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param server: str类型</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.server = server</span><br><span class="line">        self.client = KafkaClient(hosts=server)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init_producer</span>(<span class="params">self, topic</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        初始化Kafka生产者</span></span><br><span class="line"><span class="string">        :param topic:Type --&gt; bytes `Produce msg what topic You want`.</span></span><br><span class="line"><span class="string">        :raises ParameterError: 当topic不是bytes类型时抛错.</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(topic, <span class="built_in">bytes</span>):</span><br><span class="line">            <span class="keyword">raise</span> ParameterError(ParameterError._ParameterError_Topic)</span><br><span class="line">        topic = self.client.topics[topic]</span><br><span class="line">        self.producer = topic.get_producer(sync=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init_consumer_pykafka</span>(<span class="params">self, topic, group_id, offset_type</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Init Kafka Consumer by pykafka</span></span><br><span class="line"><span class="string">        :param topic:Type --&gt; bytes `Consumer msg what topic You want`.</span></span><br><span class="line"><span class="string">        :param group_id: Type --&gt; str `Consumer msg what group_id You want,You can receive duplicate data using different group_id in same topic`.</span></span><br><span class="line"><span class="string">        :param offset_type:Type --&gt; str `LATEST can receive the latest data,EARLIEST can receive earliest data in topic`</span></span><br><span class="line"><span class="string">        :raises ParameterError: When use error Parameter to init init_consumer.</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(topic, <span class="built_in">bytes</span>) <span class="keyword">or</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(group_id, <span class="built_in">str</span>) <span class="keyword">or</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(offset_type, <span class="built_in">str</span>) <span class="keyword">or</span> offset_type <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">&quot;LATEST&quot;</span>, <span class="string">&quot;EARLIEST&quot;</span>]:</span><br><span class="line">            <span class="keyword">raise</span> ParameterError(ParameterError._ParameterError_pykafka_Consumer)</span><br><span class="line">        <span class="keyword">from</span> pykafka.simpleconsumer <span class="keyword">import</span> OffsetType</span><br><span class="line">        _OffsetType = &#123;<span class="string">&quot;LATEST&quot;</span>: OffsetType.LATEST, <span class="string">&quot;EARLIEST&quot;</span>: OffsetType.EARLIEST&#125;</span><br><span class="line">        topic = self.client.topics[topic]</span><br><span class="line">        self.consumer = topic.get_simple_consumer(auto_commit_enable=<span class="literal">True</span>, auto_commit_interval_ms=<span class="number">1</span>,</span><br><span class="line">                                                  consumer_id=group_id, auto_offset_reset=_OffsetType[offset_type],</span><br><span class="line">                                                  reset_offset_on_start=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init_consumer_kafka</span>(<span class="params">self, topic, group_id, offset_type</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Init Kafka Consumer by kafka-python</span></span><br><span class="line"><span class="string">        :param topic: Type --&gt; str `Consumer msg what topic You want`.</span></span><br><span class="line"><span class="string">        :param group_id: Type --&gt; str `Consumer msg what group_id You want,You can receive duplicate data using different group_id in same topic`.</span></span><br><span class="line"><span class="string">        :param offset_type: Type --&gt; str `LATEST can receive the latest data,EARLIEST can receive earliest data in topic`</span></span><br><span class="line"><span class="string">        :raises ParameterError: When use error Parameter to init init_consumer.</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaConsumer</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(topic, <span class="built_in">str</span>) <span class="keyword">or</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(group_id, <span class="built_in">str</span>) \</span><br><span class="line">                <span class="keyword">or</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(offset_type, <span class="built_in">str</span>) <span class="keyword">or</span> offset_type <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">&quot;LATEST&quot;</span>, <span class="string">&quot;EARLIEST&quot;</span>]:</span><br><span class="line">            <span class="keyword">raise</span> ParameterError(ParameterError._ParameterError_kafka_Consumer)</span><br><span class="line"></span><br><span class="line">        self.consumer = KafkaConsumer(bootstrap_servers=self.server,</span><br><span class="line">                                      auto_offset_reset=offset_type,</span><br><span class="line">                                      group_id=group_id,</span><br><span class="line">                                      )</span><br><span class="line">        self.consumer.subscribe(topics=topic.split(<span class="string">&#x27;,&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pull</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Get info from Kafka Consumer by kafka-python</span></span><br><span class="line"><span class="string">        Poll Parameters:</span></span><br><span class="line"><span class="string">            timeout_ms: Type --&gt; int `Interval between each piece of data`.</span></span><br><span class="line"><span class="string">            max_records: Type --&gt; int `The amount of data per batch of data`</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.consumer.poll(timeout_ms=<span class="number">0</span>, max_records=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send_message</span>(<span class="params">self, msg, key</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Send MSG by this func</span></span><br><span class="line"><span class="string">        :param msg: Type --&gt; bytes or str `Message to broker`.</span></span><br><span class="line"><span class="string">        :param key: Type --&gt; bytes `Producer msg what key You want,You can see the key when you receiving data`.</span></span><br><span class="line"><span class="string">        :raises ParameterError: when error type for key.</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(key, <span class="built_in">bytes</span>):</span><br><span class="line">            <span class="keyword">raise</span> ParameterError(ParameterError._ParameterError_Key)</span><br><span class="line">        produce_msg = msg.encode() <span class="keyword">if</span> <span class="built_in">isinstance</span>(msg, <span class="built_in">str</span>) <span class="keyword">else</span> msg</span><br><span class="line">        self.producer.produce(produce_msg, partition_key=key)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>任务分配算法</title>
      <link href="2019/01/27/devTaskAssign/"/>
      <url>2019/01/27/devTaskAssign/</url>
      
        <content type="html"><![CDATA[<p>在开发一套内部的审核平台的时候，有这么一个需求，所有的任务需要平均的前提下随机分配给审核员。然后有存在一个问题，有的审核员效率慢，有的审核员效率高，这样分配任务的时候就需要考虑审核员当前手上剩余的审核任务(也有运营部的绩效考核原因)。</p><span id="more"></span><p>ps：需求变了，所有的都平均分了，因为运营人员不需要根据审核量进行绩效考核了，多劳多得变成大锅饭了。也白设计了这套算法，无所谓了，就当周末刷了会数独游戏吧，反正闲着也是闲着。</p><p>假设现在有 n 个任务需要分配给 m 个审核员去完成，但是每个审核员手头上还有未完成的任务，且未完成的任务数不同。那么如何均匀的把这些任务分配给各个审核员？这里我想出了一种基于平均思想的任务分配算法。</p><p>该算法的主要思想是：首先找出所有的审核员中手头未完成任务数量最大的审核员，然后其他审核员以该审核员的未完成任务数为参考数，计算自己可容纳的任务数，最后所有审核员可容纳的任务数之和即为总的可容纳任务数。</p><p>这里存在两种情况，第一种是：总的可容纳任务数小于或等于 n 个待分配的任务数，此时所有的审核员以最大未完成任务数 max_task 为参考数，接收待分配的任务。如果刚好分配完，那么算法结束；如果还有剩余任务未分配，那么将剩下的任务抽取 m 个任务分配给每一位审核员，以此类推，直到剩下的未分配任务数小于 m 位置，然后将这小于 m 的任务随机分配相应数量的审核员。<br />第二种情况是：总的可容纳任务数大于 n 个待分配的任务数，此时降低一个单位的参考数(max_task-1)，然后循环计算可容纳的任务数，知道退出循环（循环终止条件为：ava_task - task_num &lt;= lower_List.size(),lower_List.size()表示的是低于当前参考数的审核员数）。</p><p>接下来，我们将通过一个简单的例子来说明算法的流程，由于第一种情况比较简单，因此，该例子是基于第二种情况的，如图 1 所示.<br /><img src="/images/task-assign-01.png" alt="图1" title="图1" /></p><p>假设有 20 个任务需要分配给 8 个审核员(对应 8 个条形图，蓝色条形图对应的数字代表该审核员手头未完成的任务数)。<br />首先找出者八个审核员收中未完成任务书的最大值 max_task=7，然后个审核员已 max_task 为参考数计算各自可容纳的任务数(绿色条形图对应的数字)，总的可容纳任务数为所有审核员可容纳的任务数之和，及 ava_task=6+3+4+2+5+0+5+6,有图 1 可知，lower_List.size()=7,由 31-20&gt;7，因此，可降低一个单位的参数数，即 max_task=max_task-1=6，如图 2 所示。<br /><img src="/images/task-assign-02.png" alt="图2" title="图2" /></p><p>那么，ava_task=5+2+3+1+4+0+4+5=24，lower_List.size()=7，由于 24-20&lt;7，因此循环终止。<br />由于可容纳的任务数仍然大于待分配的任务数，因此需要再降低一个单位的参考数(一定要考虑这种情况)，max_task=max_task-1=5，此时 ava_task=4+1+2+0+3+0+3+4=17，lower_List.size()=6，剩余待分配任务数为 20-17=3，然后将这 3 个任务随机分配给低于当前参考数的 6 个审核员中的 3 个，每个审核员分配一个。<br />当然算法中还考虑了很多种情况，具体请参见如下代码。由于任务一般按审核员 ID 来分配，且 ID 一般为字符串。为了存储方便，我定义了一个二维字符串类型的数组 rev_task[i][j]来存储数据，i 表示第 i 个审核员，rev_task[i][0]存放的是第 i 个审核员的 ID，rev_task[i][1]存放的是第 i 个审核员当前未完成的任务数，rev_task[i][2]存放的是第 i 个审核员应当被分配的任务数。</p><h2 id="算法工具类-algorithmutilsjava"><a class="markdownIt-Anchor" href="#算法工具类-algorithmutilsjava"></a> 算法工具类-AlgorithmUtils.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.audit.allocationAlgorithm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlgorithmUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">taskAllocation</span><span class="params">(<span class="keyword">int</span> task_num, <span class="keyword">int</span> rev_num, String[][] rev_task)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Random rd = <span class="keyword">new</span> Random();</span><br><span class="line">        List&lt;Integer&gt; rdList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得审核人员中的最大未完成任务数</span></span><br><span class="line">        <span class="keyword">int</span> max_task = Integer.parseInt(rev_task[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; rev_num; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(max_task &lt; Integer.parseInt(rev_task[i][<span class="number">1</span>]))</span><br><span class="line">                max_task = Integer.parseInt(rev_task[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//以最大待审核任务数为参考数，判断第一轮可容纳的任务数</span></span><br><span class="line">        <span class="keyword">int</span> ava_task = <span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; lower_List = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rev_num;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((max_task-Integer.parseInt(rev_task[i][<span class="number">1</span>])) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                ava_task += (max_task-Integer.parseInt(rev_task[i][<span class="number">1</span>]));</span><br><span class="line">                lower_List.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> task_rest;</span><br><span class="line">        <span class="keyword">int</span> task_avg;</span><br><span class="line">        <span class="comment">//第一种情况：第一轮可容纳的任务数小于待分配的任务数</span></span><br><span class="line">        <span class="keyword">if</span>(ava_task - task_num &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rev_num; i++) &#123;</span><br><span class="line">                rev_task[i][<span class="number">2</span>] = String.valueOf(max_task-Integer.parseInt(rev_task[i][<span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">            task_rest = task_num-ava_task;</span><br><span class="line">            task_avg = task_rest/rev_num;</span><br><span class="line">            <span class="keyword">if</span>(task_rest != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span>(task_avg &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rev_num; i++) &#123;</span><br><span class="line">                        rev_task[i][<span class="number">2</span>] = String.valueOf(Integer.parseInt(rev_task[i][<span class="number">2</span>])+task_avg);</span><br><span class="line">                    &#125;</span><br><span class="line">                    task_rest -= rev_num*task_avg;</span><br><span class="line">                    task_avg = task_rest/rev_num;</span><br><span class="line">                &#125;</span><br><span class="line">                rdList.removeAll(rdList);</span><br><span class="line">                <span class="keyword">while</span>(rdList.size() &lt; (task_rest+<span class="number">1</span>))&#123;</span><br><span class="line">                    temp = rd.nextInt(rev_num);</span><br><span class="line">                    <span class="keyword">if</span>(!rdList.contains(temp))&#123;</span><br><span class="line">                        rdList.add(temp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; task_rest; i++) &#123;</span><br><span class="line">                    rev_task[rdList.get(i)][<span class="number">2</span>] = String.valueOf(Integer.parseInt(rev_task[rdList.get(i)][<span class="number">2</span>])+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;<span class="comment">//第二种情况：第一轮可容纳的任务数大于待分配的任务数，此时降低一个单位的参考数(max_task-1)，然后循环计算可容纳的任务数，直到退出循环</span></span><br><span class="line">            <span class="keyword">while</span>(ava_task - task_num &gt; lower_List.size()) &#123;</span><br><span class="line">                max_task--;</span><br><span class="line">                ava_task = <span class="number">0</span>;</span><br><span class="line">                lower_List.removeAll(lower_List);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rev_num;i++)&#123;</span><br><span class="line">                    rev_task[i][<span class="number">2</span>] = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">                    <span class="keyword">if</span>((max_task-Integer.parseInt(rev_task[i][<span class="number">1</span>])) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        rev_task[i][<span class="number">2</span>] = String.valueOf(max_task-Integer.parseInt(rev_task[i][<span class="number">1</span>]));</span><br><span class="line">                        ava_task += Integer.parseInt(rev_task[i][<span class="number">2</span>]);</span><br><span class="line">                        lower_List.add(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ava_task - task_num &gt; <span class="number">0</span>) &#123;<span class="comment">//如果可容纳的任务数大于待分配的任务数，那么需要再再降低一个单位的参考数</span></span><br><span class="line">                max_task--;</span><br><span class="line">                ava_task = <span class="number">0</span>;</span><br><span class="line">                lower_List.removeAll(lower_List);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rev_num;i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>((max_task-Integer.parseInt(rev_task[i][<span class="number">1</span>])) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                        rev_task[i][<span class="number">2</span>] = String.valueOf(max_task-Integer.parseInt(rev_task[i][<span class="number">1</span>]));</span><br><span class="line">                        ava_task += Integer.parseInt(rev_task[i][<span class="number">2</span>]);</span><br><span class="line">                        lower_List.add(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                task_rest = task_num - ava_task;</span><br><span class="line">                rdList.removeAll(rdList);</span><br><span class="line">                <span class="keyword">while</span>(rdList.size() &lt; (task_rest+<span class="number">1</span>))&#123;</span><br><span class="line">                    temp = rd.nextInt(rev_num);</span><br><span class="line">                    <span class="keyword">if</span>((!rdList.contains(temp))&amp;&amp;(lower_List.contains(temp)))&#123;</span><br><span class="line">                        rdList.add(temp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; task_rest; i++) &#123;</span><br><span class="line">                    rev_task[rdList.get(i)][<span class="number">2</span>] = String.valueOf(Integer.parseInt(rev_task[rdList.get(i)][<span class="number">2</span>])+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                task_rest = task_num-ava_task;</span><br><span class="line">                <span class="keyword">if</span>(task_rest != <span class="number">0</span>) &#123;</span><br><span class="line">                    rdList.removeAll(rdList);</span><br><span class="line">                    <span class="keyword">while</span>(rdList.size() &lt; (task_rest+<span class="number">1</span>))&#123;</span><br><span class="line">                        temp = rd.nextInt(rev_num);</span><br><span class="line">                        <span class="keyword">if</span>((!rdList.contains(temp))&amp;&amp;(lower_List.contains(temp)))&#123;</span><br><span class="line">                            rdList.add(temp);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; task_rest; i++) &#123;</span><br><span class="line">                        rev_task[rdList.get(i)][<span class="number">2</span>] = String.valueOf(Integer.parseInt(rev_task[rdList.get(i)][<span class="number">2</span>])+<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录被分配的任务数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rev_num;i++)&#123;</span><br><span class="line">            rev_task[i][<span class="number">1</span>] = String.valueOf(Integer.parseInt(rev_task[i][<span class="number">1</span>])+Integer.parseInt(rev_task[i][<span class="number">2</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="算法测试类-testalgorithmjava"><a class="markdownIt-Anchor" href="#算法测试类-testalgorithmjava"></a> 算法测试类-TestAlgorithm.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.audit.allocationAlgorithm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAlgorithm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入任务数：&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> task_num = sc.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入审核人员的当前未完成任务数组，整数数字输入时用英文逗号隔开：&quot;</span>);</span><br><span class="line">        String inputString=sc.next().toString();</span><br><span class="line">        String stringArray[]=inputString.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rev_num = stringArray.length;<span class="comment">//审核人员总数</span></span><br><span class="line">        String[][] rev_task =<span class="keyword">new</span> String[rev_num][<span class="number">3</span>];</span><br><span class="line">        Random rd = <span class="keyword">new</span> Random();</span><br><span class="line">        List&lt;Integer&gt; rdList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        rdList.removeAll(rdList);</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">while</span>(rdList.size() &lt; (rev_num+<span class="number">1</span>))&#123;</span><br><span class="line">            temp = rd.nextInt(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">if</span>(!rdList.contains(temp))&#123;</span><br><span class="line">                rdList.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;算法前的任务分配：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rev_num;i++)&#123;</span><br><span class="line">            rev_task[i][<span class="number">0</span>] = String.valueOf(rdList.get(i) + <span class="number">1</span>);</span><br><span class="line">            rev_task[i][<span class="number">1</span>]= stringArray[i];</span><br><span class="line">            rev_task[i][<span class="number">2</span>] = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">            System.out.print(rev_task[i][<span class="number">0</span>]+<span class="string">&quot;,&quot;</span>+rev_task[i][<span class="number">1</span>]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        AlgorithmUtils.taskAllocation(task_num, rev_num, rev_task);<span class="comment">//调用算法工具类</span></span><br><span class="line">        System.out.println(<span class="string">&quot;算法后的任务分配：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rev_num;i++)&#123;</span><br><span class="line">            System.out.print(rev_task[i][<span class="number">0</span>]+<span class="string">&quot;,&quot;</span>+rev_task[i][<span class="number">1</span>]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br />请输入任务数：<br />20<br />请输入审核人员的当前未完成任务数组，整数数字输入时用英文逗号隔开：<br />1,4,3,5,2,7,2,1<br />算法前的任务分配：<br />72,1 63,4 73,3 49,5 74,2 43,7 100,2 20,1<br />算法后的任务分配：<br />72,5 63,5 73,5 49,6 74,5 43,7 100,6 20,6<br />由运行结果可知，20 个任务均衡的分配给了每个审核人员，达到了平均分配的目的！</p>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python可视化绘图</title>
      <link href="2019/01/25/tipsPythonMatplotlib/"/>
      <url>2019/01/25/tipsPythonMatplotlib/</url>
      
        <content type="html"><![CDATA[<p><code>Matplotlib</code>是一个<code>Python</code>的绘图库，粗略理解为<code>py</code>集成<code>MATLAB</code>的功能包。以前学数学建模的时候很讨厌<code>MATLAB</code>，情愿用<code>C</code>来写算法都不想学<code>MATLAB</code>，现在没得法，工作需要分析一些数据，还好<code>Python</code>有这些相关的库，要不然真的要去研究下<code>MATLAB</code>了。</p><span id="more"></span><h3 id="简单图形绘制"><a class="markdownIt-Anchor" href="#简单图形绘制"></a> 简单图形绘制</h3><p>根据坐标点绘制：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">x = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>])</span><br><span class="line">y = np.array([<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">15</span>])</span><br><span class="line">plt.plot(x,y,<span class="string">&#x27;r&#x27;</span>)<span class="comment"># 折线 1 x 2 y 3 color</span></span><br><span class="line">plt.plot(x,y,<span class="string">&#x27;g&#x27;</span>,lw=<span class="number">10</span>)<span class="comment"># 4 line w</span></span><br><span class="line"><span class="comment"># 折线 饼状 柱状</span></span><br><span class="line">x = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>])</span><br><span class="line">y = np.array([<span class="number">13</span>,<span class="number">25</span>,<span class="number">17</span>,<span class="number">36</span>,<span class="number">21</span>,<span class="number">16</span>,<span class="number">10</span>,<span class="number">15</span>])</span><br><span class="line">plt.bar(x,y,<span class="number">0.2</span>,alpha=<span class="number">1</span>,color=<span class="string">&#x27;b&#x27;</span>)<span class="comment"># 5 color 4 透明度 3 0.9</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/images/matlab01-1.png" alt="根据坐标点绘制" title="根据坐标点绘制" /></p><p>传入参数是 numpy 数组时的效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">15</span>):</span><br><span class="line">    <span class="comment"># 1 柱状图</span></span><br><span class="line">    dateOne = np.zeros([<span class="number">2</span>])</span><br><span class="line">    dateOne[<span class="number">0</span>] = i;</span><br><span class="line">    dateOne[<span class="number">1</span>] = i;</span><br><span class="line">    y = np.zeros([<span class="number">2</span>])</span><br><span class="line">    y[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">    y[<span class="number">1</span>] = <span class="number">20</span></span><br><span class="line">    plt.plot(dateOne,y,<span class="string">&#x27;r&#x27;</span>,lw=<span class="number">8</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/images/matlab01-2.png" alt="传入参数是numpy数组时的效果" title="传入参数是numpy数组时的效果" /></p><p>根据函数图像绘制：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从-1-----1之间等间隔采66个数.也就是说所画出来的图形是66个点连接得来的</span></span><br><span class="line"><span class="comment"># 注意：如果点数过小的话会导致画出来二次函数图像不平滑</span></span><br><span class="line">x = np.linspace(-<span class="number">1</span>, <span class="number">1</span>,<span class="number">66</span>)</span><br><span class="line"><span class="comment"># 绘制y=2x+1函数的图像</span></span><br><span class="line">y = <span class="number">2</span> * x + <span class="number">1</span></span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制x^2函数的图像</span></span><br><span class="line">y = x**<span class="number">2</span></span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/images/matlab01-3-1.png" alt="根据函数图像绘制" title="根据函数图像绘制" /></p><p><img src="/images/matlab01-3-2.png" alt="根据函数图像绘制" title="根据函数图像绘制" /></p><h3 id="figure-的简单使用"><a class="markdownIt-Anchor" href="#figure-的简单使用"></a> figure 的简单使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.linspace(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># figure 1</span></span><br><span class="line">y1 = <span class="number">2</span> * x + <span class="number">1</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(x, y1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># figure 2</span></span><br><span class="line">y2 = x**<span class="number">2</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(x, y2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># figure 3，指定figure的编号并指定figure的大小, 指定线的颜色, 宽度和类型</span></span><br><span class="line"><span class="comment">#一个坐标轴上画了两个图形</span></span><br><span class="line">y2 = x**<span class="number">2</span></span><br><span class="line">plt.figure(num = <span class="number">5</span>, figsize = (<span class="number">4</span>, <span class="number">4</span>))</span><br><span class="line">plt.plot(x, y1)</span><br><span class="line">plt.plot(x, y2, color = <span class="string">&#x27;red&#x27;</span>, linewidth = <span class="number">1.0</span>, linestyle = <span class="string">&#x27;--&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>一共会画出三张图，前两张和上面的简单案例画出来的两张一样。<br /><img src="/images/matlab02-1-1.png" alt="figure的简单使用" title="figure的简单使用" /><br /><img src="/images/matlab02-1-2.png" alt="figure的简单使用" title="figure的简单使用" /><br /><img src="/images/matlab02-1-3.png" alt="figure的简单使用" title="figure的简单使用" /></p><h3 id="设置坐标轴"><a class="markdownIt-Anchor" href="#设置坐标轴"></a> 设置坐标轴</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制普通图像</span></span><br><span class="line">x = np.linspace(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">50</span>)</span><br><span class="line">y1 = <span class="number">2</span> * x + <span class="number">1</span></span><br><span class="line">y2 = x**<span class="number">2</span></span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(x, y1)</span><br><span class="line">plt.plot(x, y2, color = <span class="string">&#x27;red&#x27;</span>, linewidth = <span class="number">1.0</span>, linestyle = <span class="string">&#x27;--&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置坐标轴的取值范围</span></span><br><span class="line">plt.xlim((-<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">plt.ylim((<span class="number">0</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置坐标轴的lable</span></span><br><span class="line"><span class="comment">#标签里面必须添加字体变量：fontproperties=&#x27;SimHei&#x27;,fontsize=14。不然可能会乱码</span></span><br><span class="line">plt.xlabel(<span class="string">u&#x27;这是x轴&#x27;</span>,fontproperties=<span class="string">&#x27;SimHei&#x27;</span>,fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">u&#x27;这是y轴&#x27;</span>,fontproperties=<span class="string">&#x27;SimHei&#x27;</span>,fontsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置x坐标轴刻度, 之前为0.25, 修改后为0.5</span></span><br><span class="line"><span class="comment">#也就是在坐标轴上取5个点，x轴的范围为-1到1所以取5个点之后刻度就变为0.5了</span></span><br><span class="line">plt.xticks(np.linspace(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/images/matlab03-1.png" alt="设置坐标轴" title="设置坐标轴" /></p><p>上面代码的基础上加上下面代码（直接加载最后一句代码前面即可）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取当前的坐标轴, gca = get current axis</span></span><br><span class="line">ax = plt.gca()</span><br><span class="line"><span class="comment"># 设置右边框和上边框</span></span><br><span class="line">ax.spines[<span class="string">&#x27;right&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">ax.spines[<span class="string">&#x27;top&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line"><span class="comment"># 设置x坐标轴为下边框</span></span><br><span class="line">ax.xaxis.set_ticks_position(<span class="string">&#x27;bottom&#x27;</span>)</span><br><span class="line"><span class="comment"># 设置y坐标轴为左边框</span></span><br><span class="line">ax.yaxis.set_ticks_position(<span class="string">&#x27;left&#x27;</span>)</span><br><span class="line"><span class="comment"># 设置x轴, y周在(0, 0)的位置</span></span><br><span class="line">ax.spines[<span class="string">&#x27;bottom&#x27;</span>].set_position((<span class="string">&#x27;data&#x27;</span>, <span class="number">0</span>))</span><br><span class="line">ax.spines[<span class="string">&#x27;left&#x27;</span>].set_position((<span class="string">&#x27;data&#x27;</span>, <span class="number">0</span>))</span><br></pre></td></tr></table></figure><p><img src="/images/matlab03-2.png" alt="设置坐标轴" title="设置坐标轴" /></p><p>如果在上面代码的最后一句之前加上下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置坐标轴label的大小，背景色等信息</span></span><br><span class="line"><span class="keyword">for</span> label <span class="keyword">in</span> ax.get_xticklabels() + ax.get_yticklabels():</span><br><span class="line">    label.set_fontsize(<span class="number">12</span>)</span><br><span class="line">    label.set_bbox(<span class="built_in">dict</span>(facecolor = <span class="string">&#x27;green&#x27;</span>, edgecolor = <span class="string">&#x27;None&#x27;</span>, alpha = <span class="number">0.7</span>))</span><br></pre></td></tr></table></figure><p><img src="/images/matlab03-3.png" alt="设置坐标轴" title="设置坐标轴" /></p><h3 id="设置-legend-图例"><a class="markdownIt-Anchor" href="#设置-legend-图例"></a> 设置 legend 图例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">设置坐标轴</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制普通图像</span></span><br><span class="line">x = np.linspace(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">50</span>)</span><br><span class="line">y1 = <span class="number">2</span> * x + <span class="number">1</span></span><br><span class="line">y2 = x**<span class="number">2</span></span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(x, y1)</span><br><span class="line">plt.plot(x, y2, color = <span class="string">&#x27;red&#x27;</span>, linewidth = <span class="number">1.0</span>, linestyle = <span class="string">&#x27;--&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置坐标轴的取值范围</span></span><br><span class="line">plt.xlim((-<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">plt.ylim((<span class="number">0</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置坐标轴的lable</span></span><br><span class="line"><span class="comment">#标签里面必须添加字体变量：fontproperties=&#x27;SimHei&#x27;,fontsize=14。不然可能会乱码</span></span><br><span class="line">plt.xlabel(<span class="string">u&#x27;这是x轴&#x27;</span>,fontproperties=<span class="string">&#x27;SimHei&#x27;</span>,fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">u&#x27;这是y轴&#x27;</span>,fontproperties=<span class="string">&#x27;SimHei&#x27;</span>,fontsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置x坐标轴刻度, 之前为0.25, 修改后为0.5</span></span><br><span class="line"><span class="comment">#也就是在坐标轴上取5个点，x轴的范围为-1到1所以取5个点之后刻度就变为0.5了</span></span><br><span class="line">plt.xticks(np.linspace(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>))</span><br><span class="line"><span class="comment"># 获取当前的坐标轴, gca = get current axis</span></span><br><span class="line">ax = plt.gca()</span><br><span class="line"><span class="comment"># 设置右边框和上边框</span></span><br><span class="line">ax.spines[<span class="string">&#x27;right&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">ax.spines[<span class="string">&#x27;top&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line"><span class="comment"># 设置x坐标轴为下边框</span></span><br><span class="line">ax.xaxis.set_ticks_position(<span class="string">&#x27;bottom&#x27;</span>)</span><br><span class="line"><span class="comment"># 设置y坐标轴为左边框</span></span><br><span class="line">ax.yaxis.set_ticks_position(<span class="string">&#x27;left&#x27;</span>)</span><br><span class="line"><span class="comment"># 设置x轴, y周在(0, 0)的位置</span></span><br><span class="line">ax.spines[<span class="string">&#x27;bottom&#x27;</span>].set_position((<span class="string">&#x27;data&#x27;</span>, <span class="number">0</span>))</span><br><span class="line">ax.spines[<span class="string">&#x27;left&#x27;</span>].set_position((<span class="string">&#x27;data&#x27;</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/images/matlab04-1.png" alt="设置legend图例" title="设置legend图例" /></p><h3 id="添加注解和绘制点以及在图形上绘制线或点"><a class="markdownIt-Anchor" href="#添加注解和绘制点以及在图形上绘制线或点"></a> 添加注解和绘制点以及在图形上绘制线或点</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">添加注解和绘制点以及在图形上绘制线或点</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制普通图像</span></span><br><span class="line">x = np.linspace(-<span class="number">3</span>, <span class="number">3</span>, <span class="number">50</span>)</span><br><span class="line">y = <span class="number">2</span> * x + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(x, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将上、右边框去掉</span></span><br><span class="line">ax = plt.gca()</span><br><span class="line">ax.spines[<span class="string">&#x27;right&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">ax.spines[<span class="string">&#x27;top&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置x轴的位置及数据在坐标轴上的位置</span></span><br><span class="line">ax.xaxis.set_ticks_position(<span class="string">&#x27;bottom&#x27;</span>)</span><br><span class="line">ax.spines[<span class="string">&#x27;bottom&#x27;</span>].set_position((<span class="string">&#x27;data&#x27;</span>, <span class="number">0</span>))</span><br><span class="line"><span class="comment"># 设置y轴的位置及数据在坐标轴上的位置</span></span><br><span class="line">ax.yaxis.set_ticks_position(<span class="string">&#x27;left&#x27;</span>)</span><br><span class="line">ax.spines[<span class="string">&#x27;left&#x27;</span>].set_position((<span class="string">&#x27;data&#x27;</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义(x0, y0)点</span></span><br><span class="line">x0 = <span class="number">1</span></span><br><span class="line">y0 = <span class="number">2</span> * x0 + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制(x0, y0)点</span></span><br><span class="line">plt.scatter(x0, y0, s = <span class="number">50</span>, color = <span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line"><span class="comment"># 绘制虚线</span></span><br><span class="line">plt.plot([x0, x0], [y0, <span class="number">0</span>], <span class="string">&#x27;k--&#x27;</span>, lw = <span class="number">2.5</span>)</span><br><span class="line"><span class="comment"># 绘制注解一</span></span><br><span class="line">plt.annotate(<span class="string">r&#x27;$2 * x + 1 = %s$&#x27;</span> % y0, xy = (x0, y0), xycoords = <span class="string">&#x27;data&#x27;</span>, xytext = (+<span class="number">30</span>, -<span class="number">30</span>), \</span><br><span class="line">             textcoords = <span class="string">&#x27;offset points&#x27;</span>, fontsize = <span class="number">16</span>, arrowprops = <span class="built_in">dict</span>(arrowstyle = <span class="string">&#x27;-&gt;&#x27;</span>, connectionstyle = <span class="string">&#x27;arc3, rad = .2&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制注解二</span></span><br><span class="line">plt.text(-<span class="number">3</span>, <span class="number">3</span>, <span class="string">r&#x27;$Test\ text. \mu \sigma_i, \alpha_i$&#x27;</span>, fontdict = &#123;<span class="string">&#x27;size&#x27;</span>: <span class="number">16</span>, <span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;red&#x27;</span>&#125;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/images/matlab05-1.png" alt="添加注解和绘制点以及在图形上绘制线或点" title="添加注解和绘制点以及在图形上绘制线或点" /></p><h3 id="绘制散点图"><a class="markdownIt-Anchor" href="#绘制散点图"></a> 绘制散点图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">绘制散点图</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据个数</span></span><br><span class="line">n = <span class="number">1024</span></span><br><span class="line"><span class="comment"># 均值为0, 方差为1的随机数</span></span><br><span class="line">x = np.random.normal(<span class="number">0</span>, <span class="number">1</span>, n)</span><br><span class="line">y = np.random.normal(<span class="number">0</span>, <span class="number">1</span>, n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算颜色值</span></span><br><span class="line">color = np.arctan2(y, x)</span><br><span class="line"><span class="comment"># 绘制散点图</span></span><br><span class="line">plt.scatter(x, y, s = <span class="number">75</span>, c = color, alpha = <span class="number">0.5</span>)</span><br><span class="line"><span class="comment"># 设置坐标轴范围</span></span><br><span class="line">plt.xlim((-<span class="number">1.5</span>, <span class="number">1.5</span>))</span><br><span class="line">plt.ylim((-<span class="number">1.5</span>, <span class="number">1.5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不显示坐标轴的值</span></span><br><span class="line">plt.xticks(())</span><br><span class="line">plt.yticks(())</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/images/matlab06-1.png" alt="绘制散点图" title="绘制散点图" /></p><h3 id="绘制柱状图"><a class="markdownIt-Anchor" href="#绘制柱状图"></a> 绘制柱状图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">绘制柱状图</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据数目</span></span><br><span class="line">n = <span class="number">10</span></span><br><span class="line">x = np.arange(n)</span><br><span class="line"><span class="comment"># 生成数据, 均匀分布(0.5, 1.0)之间</span></span><br><span class="line">y1 = (<span class="number">1</span> - x / <span class="built_in">float</span>(n)) * np.random.uniform(<span class="number">0.5</span>, <span class="number">1.0</span>, n)</span><br><span class="line">y2 = (<span class="number">1</span> - x / <span class="built_in">float</span>(n)) * np.random.uniform(<span class="number">0.5</span>, <span class="number">1.0</span>, n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制柱状图, 向上</span></span><br><span class="line">plt.bar(x, y1, facecolor = <span class="string">&#x27;blue&#x27;</span>, edgecolor = <span class="string">&#x27;white&#x27;</span>)</span><br><span class="line"><span class="comment"># 绘制柱状图, 向下</span></span><br><span class="line">plt.bar(x, -y2, facecolor = <span class="string">&#x27;green&#x27;</span>, edgecolor = <span class="string">&#x27;white&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">temp = <span class="built_in">zip</span>(x, y2)</span><br><span class="line"><span class="comment"># 在柱状图上显示具体数值, ha水平对齐, va垂直对齐</span></span><br><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(x, y1):</span><br><span class="line">    plt.text(x + <span class="number">0.05</span>, y + <span class="number">0.1</span>, <span class="string">&#x27;%.2f&#x27;</span> % y, ha = <span class="string">&#x27;center&#x27;</span>, va = <span class="string">&#x27;bottom&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> temp:</span><br><span class="line">    plt.text(x + <span class="number">0.05</span>, -y - <span class="number">0.1</span>, <span class="string">&#x27;%.2f&#x27;</span> % y, ha = <span class="string">&#x27;center&#x27;</span>, va = <span class="string">&#x27;bottom&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置坐标轴范围</span></span><br><span class="line">plt.xlim(-<span class="number">1</span>, n)</span><br><span class="line">plt.ylim(-<span class="number">1.5</span>, <span class="number">1.5</span>)</span><br><span class="line"><span class="comment"># 去除坐标轴</span></span><br><span class="line">plt.xticks(())</span><br><span class="line">plt.yticks(())</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/images/matlab07-1.png" alt="绘制柱状图" title="绘制柱状图" /></p><h3 id="绘制登高线图"><a class="markdownIt-Anchor" href="#绘制登高线图"></a> 绘制登高线图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">绘制登高线图</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义等高线高度函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> - x / <span class="number">2</span> + x ** <span class="number">5</span> + y ** <span class="number">3</span>) * np.exp(- x ** <span class="number">2</span> - y ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据数目</span></span><br><span class="line">n = <span class="number">256</span></span><br><span class="line"><span class="comment"># 定义x, y</span></span><br><span class="line">x = np.linspace(-<span class="number">3</span>, <span class="number">3</span>, n)</span><br><span class="line">y = np.linspace(-<span class="number">3</span>, <span class="number">3</span>, n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成网格数据</span></span><br><span class="line">X, Y = np.meshgrid(x, y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 填充等高线的颜色, 8是等高线分为几部分</span></span><br><span class="line">plt.contourf(X, Y, f(X, Y), <span class="number">8</span>, alpha = <span class="number">0.75</span>, cmap = plt.cm.hot)</span><br><span class="line"><span class="comment"># 绘制等高线</span></span><br><span class="line">C = plt.contour(X, Y, f(X, Y), <span class="number">8</span>, colors = <span class="string">&#x27;black&#x27;</span>, linewidth = <span class="number">0.5</span>)</span><br><span class="line"><span class="comment"># 绘制等高线数据</span></span><br><span class="line">plt.clabel(C, inline = <span class="literal">True</span>, fontsize = <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去除坐标轴</span></span><br><span class="line">plt.xticks(())</span><br><span class="line">plt.yticks(())</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/images/matlab08-1.png" alt="绘制登高线图" title="绘制登高线图" /></p><h3 id="绘制-image"><a class="markdownIt-Anchor" href="#绘制-image"></a> 绘制 Image</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">绘制Image</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义图像数据</span></span><br><span class="line">a = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">9</span>).reshape(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 显示图像数据</span></span><br><span class="line">plt.imshow(a, interpolation = <span class="string">&#x27;nearest&#x27;</span>, cmap = <span class="string">&#x27;bone&#x27;</span>, origin = <span class="string">&#x27;lower&#x27;</span>)</span><br><span class="line"><span class="comment"># 添加颜色条</span></span><br><span class="line">plt.colorbar()</span><br><span class="line"><span class="comment"># 去掉坐标轴</span></span><br><span class="line">plt.xticks(())</span><br><span class="line">plt.yticks(())</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/images/matlab09-1.png" alt="绘制Image" title="绘制Image" /></p><h3 id="绘制-3d-图形"><a class="markdownIt-Anchor" href="#绘制-3d-图形"></a> 绘制 3D 图形</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">绘制3d图形</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"><span class="comment"># 定义figure</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line"><span class="comment"># 将figure变为3d</span></span><br><span class="line">ax = Axes3D(fig)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据数目</span></span><br><span class="line">n = <span class="number">256</span></span><br><span class="line"><span class="comment"># 定义x, y</span></span><br><span class="line">x = np.arange(-<span class="number">4</span>, <span class="number">4</span>, <span class="number">0.25</span>)</span><br><span class="line">y = np.arange(-<span class="number">4</span>, <span class="number">4</span>, <span class="number">0.25</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成网格数据</span></span><br><span class="line">X, Y = np.meshgrid(x, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算每个点对的长度</span></span><br><span class="line">R = np.sqrt(X ** <span class="number">2</span> + Y ** <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 计算Z轴的高度</span></span><br><span class="line">Z = np.sin(R)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制3D曲面</span></span><br><span class="line">ax.plot_surface(X, Y, Z, rstride = <span class="number">1</span>, cstride = <span class="number">1</span>, cmap = plt.get_cmap(<span class="string">&#x27;rainbow&#x27;</span>))</span><br><span class="line"><span class="comment"># 绘制从3D曲面到底部的投影</span></span><br><span class="line">ax.contour(X, Y, Z, zdim = <span class="string">&#x27;z&#x27;</span>, offset = -<span class="number">2</span>, cmap = <span class="string">&#x27;rainbow&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置z轴的维度</span></span><br><span class="line">ax.set_zlim(-<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/images/matlab10-1.png" alt="绘制3D图形" title="绘制3D图形" /></p><h3 id="subplot-绘制多图"><a class="markdownIt-Anchor" href="#subplot-绘制多图"></a> subplot 绘制多图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">subplot绘制多图</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制第一个图</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"><span class="comment"># 绘制第二个图</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"><span class="comment"># 绘制第三个图</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"><span class="comment"># 绘制第四个图</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/images/matlab11-1-1.png" alt="subplot绘制多图" title="subplot绘制多图" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">subplot绘制多图</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制第一个图</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"><span class="comment"># 绘制第二个图</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"><span class="comment"># 绘制第三个图</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"><span class="comment"># 绘制第四个图</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/images/matlab11-1-2.png" alt="subplot绘制多图" title="subplot绘制多图" /></p><h3 id="figure-绘制多图"><a class="markdownIt-Anchor" href="#figure-绘制多图"></a> figure 绘制多图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">figure绘制多图</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义figure</span></span><br><span class="line">plt.figure()</span><br><span class="line"><span class="comment"># figure分成3行3列, 取得第一个子图的句柄, 第一个子图跨度为1行3列, 起点是表格(0, 0)</span></span><br><span class="line">ax1 = plt.subplot2grid((<span class="number">3</span>, <span class="number">3</span>), (<span class="number">0</span>, <span class="number">0</span>), colspan = <span class="number">3</span>, rowspan = <span class="number">1</span>)</span><br><span class="line">ax1.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">ax1.set_title(<span class="string">&#x27;Test&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># figure分成3行3列, 取得第二个子图的句柄, 第二个子图跨度为1行3列, 起点是表格(1, 0)</span></span><br><span class="line">ax2 = plt.subplot2grid((<span class="number">3</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">0</span>), colspan = <span class="number">2</span>, rowspan = <span class="number">1</span>)</span><br><span class="line">ax2.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># figure分成3行3列, 取得第三个子图的句柄, 第三个子图跨度为1行1列, 起点是表格(1, 2)</span></span><br><span class="line">ax3 = plt.subplot2grid((<span class="number">3</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">2</span>), colspan = <span class="number">1</span>, rowspan = <span class="number">1</span>)</span><br><span class="line">ax3.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># figure分成3行3列, 取得第四个子图的句柄, 第四个子图跨度为1行3列, 起点是表格(2, 0)</span></span><br><span class="line">ax4 = plt.subplot2grid((<span class="number">3</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">0</span>), colspan = <span class="number">3</span>, rowspan = <span class="number">1</span>)</span><br><span class="line">ax4.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/images/matlab12-1-1.png" alt="figure绘制多图" title="figure绘制多图" /><br />或</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">figure绘制多图</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.gridspec <span class="keyword">as</span> gridspec</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义figure</span></span><br><span class="line">plt.figure()</span><br><span class="line"><span class="comment"># 分隔figure</span></span><br><span class="line">gs = gridspec.GridSpec(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">ax1 = plt.subplot(gs[<span class="number">0</span>, :])</span><br><span class="line">ax2 = plt.subplot(gs[<span class="number">1</span>, <span class="number">0</span>:<span class="number">2</span>])</span><br><span class="line">ax3 = plt.subplot(gs[<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">ax4 = plt.subplot(gs[<span class="number">2</span>, :])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制图像</span></span><br><span class="line">ax1.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">ax1.set_title(<span class="string">&#x27;Test&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax2.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">ax3.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">ax4.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/images/matlab12-1-2.png" alt="figure绘制多图" title="figure绘制多图" /></p><h3 id="figure-图的嵌套"><a class="markdownIt-Anchor" href="#figure-图的嵌套"></a> figure 图的嵌套</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">figure图的嵌套</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义figure</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义数据</span></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">y = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># figure的百分比, 从figure 10%的位置开始绘制, 宽高是figure的80%</span></span><br><span class="line">left, bottom, width, height = <span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.8</span>, <span class="number">0.8</span></span><br><span class="line"><span class="comment"># 获得绘制的句柄</span></span><br><span class="line">ax1 = fig.add_axes([left, bottom, width, height])</span><br><span class="line"><span class="comment"># 绘制点(x,y)</span></span><br><span class="line">ax1.plot(x, y, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">ax1.set_xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">ax1.set_ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">ax1.set_title(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 嵌套方法一</span></span><br><span class="line"><span class="comment"># figure的百分比, 从figure 10%的位置开始绘制, 宽高是figure的80%</span></span><br><span class="line">left, bottom, width, height = <span class="number">0.2</span>, <span class="number">0.6</span>, <span class="number">0.25</span>, <span class="number">0.25</span></span><br><span class="line"><span class="comment"># 获得绘制的句柄</span></span><br><span class="line">ax2 = fig.add_axes([left, bottom, width, height])</span><br><span class="line"><span class="comment"># 绘制点(x,y)</span></span><br><span class="line">ax2.plot(x, y, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">ax2.set_xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">ax2.set_ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">ax2.set_title(<span class="string">&#x27;part1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 嵌套方法二</span></span><br><span class="line">plt.axes([bottom, left, width, height])</span><br><span class="line">plt.plot(x, y, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;part2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/images/matlab13-1.png" alt="figure图的嵌套" title="figure图的嵌套" /></p><h3 id="主次坐标轴"><a class="markdownIt-Anchor" href="#主次坐标轴"></a> 主次坐标轴</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">主次坐标轴</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义数据</span></span><br><span class="line">x = np.arange(<span class="number">0</span>, <span class="number">10</span>, <span class="number">0.1</span>)</span><br><span class="line">y1 = <span class="number">0.05</span> * x ** <span class="number">2</span></span><br><span class="line">y2 = -<span class="number">1</span> * y1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义figure</span></span><br><span class="line">fig, ax1 = plt.subplots()</span><br><span class="line"><span class="comment"># 得到ax1的对称轴ax2</span></span><br><span class="line">ax2 = ax1.twinx()</span><br><span class="line"><span class="comment"># 绘制图像</span></span><br><span class="line">ax1.plot(x, y1, <span class="string">&#x27;g-&#x27;</span>)</span><br><span class="line">ax2.plot(x, y2, <span class="string">&#x27;b--&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置label</span></span><br><span class="line">ax1.set_xlabel(<span class="string">&#x27;X data&#x27;</span>)</span><br><span class="line">ax1.set_xlabel(<span class="string">&#x27;Y1&#x27;</span>, color = <span class="string">&#x27;g&#x27;</span>)</span><br><span class="line">ax2.set_xlabel(<span class="string">&#x27;Y2&#x27;</span>, color = <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/images/matlab14-1.png" alt="主次坐标轴" title="主次坐标轴" /></p><h3 id="创建动画"><a class="markdownIt-Anchor" href="#创建动画"></a> 创建动画</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">动画</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> animation</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义figure</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义数据</span></span><br><span class="line">x = np.arange(<span class="number">0</span>, <span class="number">2</span> * np.pi, <span class="number">0.01</span>)</span><br><span class="line"><span class="comment"># line, 表示只取返回值中的第一个元素</span></span><br><span class="line">line, = ax.plot(x, np.sin(x))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义动画的更新</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">i</span>):</span></span><br><span class="line">    line.set_ydata(np.sin(x + i/<span class="number">10</span>))</span><br><span class="line">    <span class="keyword">return</span> line,</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义动画的初始值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span>():</span></span><br><span class="line">    line.set_ydata(np.sin(x))</span><br><span class="line">    <span class="keyword">return</span> line,</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建动画</span></span><br><span class="line">ani = animation.FuncAnimation(fig = fig, func = update, init_func = init, interval = <span class="number">10</span>, blit = <span class="literal">False</span>, frames = <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 展示动画</span></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 动画保存</span></span><br><span class="line"><span class="comment">#我这里是保存为html文件了，打开即可完美运行</span></span><br><span class="line">ani.save(<span class="string">&#x27;sin.html&#x27;</span>, writer = <span class="string">&#x27;imagemagick&#x27;</span>, fps = <span class="number">30</span>, dpi = <span class="number">100</span>)</span><br></pre></td></tr></table></figure><p><img src="/images/matlab15-1.png" alt="创建动画" title="创建动画" /></p>]]></content>
      
      
      <categories>
          
          <category> tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向笔记梳理</title>
      <link href="2018/10/10/noteReverseEnfineering/"/>
      <url>2018/10/10/noteReverseEnfineering/</url>
      
        <content type="html"><![CDATA[<p>先把大纲列出来，有空就慢慢更新完善。</p><span id="more"></span><h2 id="x86-与-x64"><a class="markdownIt-Anchor" href="#x86-与-x64"></a> x86 与 x64</h2><p><code>x86</code>是基于<code>intel 8086</code>处理器的小端（<code>little-endian</code>）体系结构（<code>IA-32</code>的<code>32位</code>实现），他在两种操作模式下执行</p><ul><li>实模式：处理机刚刚上电后只支持 16 位指令集的状态。</li><li>保护模式：处理机支持虚拟内存、分页及其他功能的状态。<br />该体系的<code>64位</code>扩展称为<code>x64</code>或<code>x86-64</code>，<code>x86</code>通过一种称为环级别(<code>ring level</code>)的抽象来支持特权隔离(<code>privilege separation</code>)。</li></ul><h3 id="寄存器组与数据类型"><a class="markdownIt-Anchor" href="#寄存器组与数据类型"></a> 寄存器组与数据类型</h3><p>运行于保护模式下的<code>x86</code>体系结构有 8 个<code>32位</code>通用寄存器(<code>General Purpose Registers, GPR</code>):<code>EAX</code>、<code>EBX</code>、<code>ECX</code>、<code>EDX</code>、<code>EDI</code>、<code>ESI</code>、<code>EBP</code>、<code>ESP</code>。这些寄存器还能进一步分化成<code>8位</code>和<code>16位</code>寄存器。指令指针存储在<code>EIP</code>寄存器中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">31  23  15  7   0</span><br><span class="line">|       EAX     |</span><br><span class="line">|   |   |   AX  |</span><br><span class="line">|   |   |AH |AL |</span><br><span class="line"></span><br><span class="line">31  23  15  7   0       31  23  15  7   0</span><br><span class="line">|       EBP     |       |       ESP     |</span><br><span class="line">|       |   BP  |       |       |   SP  |</span><br><span class="line"></span><br><span class="line">31  23  15  7   0       31  23  15  7   0</span><br><span class="line">|       ESI     |       |       EDI     |</span><br><span class="line">|       |   SI  |       |       |   DI  |</span><br><span class="line"></span><br><span class="line">31  23  15  7   0       31  23  15  7   0</span><br><span class="line">|       EIP     |       |       EFLAGS  |</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">寄存器</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left">ECX</td><td style="text-align:left">循环计数</td></tr><tr><td style="text-align:left">ESI</td><td style="text-align:left">字符串/内存操作的源</td></tr><tr><td style="text-align:left">EDI</td><td style="text-align:left">字符串/内存操作中的目标</td></tr><tr><td style="text-align:left">EBP</td><td style="text-align:left">帧基指针</td></tr><tr><td style="text-align:left">ESP</td><td style="text-align:left">栈指针</td></tr></tbody></table><p>常用的数据类型有以下几种：</p><ul><li>字节(Byte): 8 位，比如 AL、BL、CL。</li><li>字(Word): 16 位，比如 AX、BX、CX。</li><li>双字(Double Word): 32 位，比如 EAX、EBX、ECX。</li><li>四字(Quad Word): 64 位，虽然 x86 并不支持 64 位 GPR，但是在某些场景下可以把两个寄存器(通常是 EDA:EAX)的内容合并起来当作 64 位的值。比如 RDTSC 指令会把一个 64 位值写入 EDX:EAX 寄存器。</li></ul><p><code>32位</code>寄存器<code>EFLAGS</code>用于存储运算状态以及其他运行状态（比如陷阱标志位）。</p><p>除了通用寄存器、<code>EIP</code>和<code>EFLAGS</code>，还有一些寄存器用于控制重要的底层系统机制，比如虚拟内存、终端和调试等。例如：<code>CR0</code>寄存器控制分页机制的开关，<code>CR2</code>寄存器中保存着导致缺页异常发生的线性地址，<code>CR3</code>是分页数据结构的基地址，<code>CR4</code>控制硬件虚拟化设置。<code>DR0～DR7</code>寄存器用于设置内存断点。（注意，虽然调试寄存器有 8 个，但系统只支持 4 个内存断点<code>DR0～DR3</code>，其余寄存器用于保存状态）</p><h3 id="指令集"><a class="markdownIt-Anchor" href="#指令集"></a> 指令集</h3><p><code>x86</code>指令集为寄存器和内存之间的数据移动提供了很大的灵活性。数据移动可以分为 5 种方式：</p><ul><li>立即数到寄存器</li><li>寄存器到寄存器</li><li>立即数到内存</li><li>寄存器到内存，或反向</li><li>内存到内存</li></ul><p>前四种是所有现代体系结构都支持的，而最后一种是<code>x86</code>独有的。像 ARM 这样的经典<code>RISC</code>体系结构只支持通过加载/存储指令（<code>LDR/STR</code>）从内存读出或反向内存写入数据。比如递增内存中数据值需要执行 3 条指令：</p><ol><li>把数据从内存读入到寄存器中（LDR）</li><li>寄存器加 1（ADD）</li><li>把寄存器值写回内存（STR）<br />而对已<code>x86</code>来说，因为可以直接访问内存，这样的操作只需要一条指令（<code>INC或ADD</code>）。<code>MOVS</code>指令可以同时读写内存。<br />ARM：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1B 68   LDR     R3, [R3]</span><br><span class="line">; 读入地址R3处的值并保存在R2中</span><br><span class="line">5A 1C   ADDS    R2, R3, #1</span><br><span class="line">; 加1</span><br><span class="line">1A 60   STR     R2, [R3]</span><br><span class="line">; 把更新后的值写回地址R3处</span><br></pre></td></tr></table></figure><p>x86：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FF 00   inc     dword ptr [eax]</span><br><span class="line">; 直接递增地址EAX处的值</span><br></pre></td></tr></table></figure><p><code>x86</code>的另一个重要特性是使用了变长指令——指令的长度从<code>1到15字节</code>不等。而在<code>ARM</code>上，指令长度只能是<code>2字节或4字节</code>。</p><h4 id="语法"><a class="markdownIt-Anchor" href="#语法"></a> 语法</h4><p>根据<code>汇编器/反汇编器</code>的不同，x86 汇编代码有两种记法：<code>Intel</code>和<code>AT&amp;T</code>。<br />Intel(Windows 上的记法)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ecx, AABBCCDDh</span><br><span class="line">mov ecx, [eax]</span><br><span class="line">mov ecx, eax</span><br></pre></td></tr></table></figure><p>AT&amp;T(unix 上的 GCC 记法):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl $0xAABBCCDD, %ecx</span><br><span class="line">movl (%eax), %ecx</span><br><span class="line">movl %eax, %ecx</span><br></pre></td></tr></table></figure><ul><li>AT&amp;T 记法在寄存器前加前缀%，立即数前加$。Intel 记法不加前缀。</li><li>AT&amp;T 记法加入了指示指令宽度的后缀，比如 MOVL(长整型)、MOVB(字节)等。Intel 记法没有这种标记。</li><li>AT&amp;T 记法把源操作数放在目标操作数之前。Intel 记法与之相反。</li></ul><h4 id="数据移动"><a class="markdownIt-Anchor" href="#数据移动"></a> 数据移动</h4><p>指令用于操作来自寄存器或主内存中的数据。</p><h4 id="栈操作与函数调用"><a class="markdownIt-Anchor" href="#栈操作与函数调用"></a> 栈操作与函数调用</h4><p>C 语言的局部变量就存储在函数的栈空间中。操作系统从<code>ring3</code>切换到<code>ring0</code>时，要把状态信息保存在栈上。具体来讲，<code>x86</code>上的栈是<code>ESP</code>指向的一段连续内存区域，他向下增长。压栈（<code>push指令</code>）递减<code>ESP</code>的值，然后把数据写入 ESP 指向的位置；出栈（<code>pop</code>指令）读出<code>ESP</code>指向位置的数据并递增<code>ESP</code>。默认的自动递增/递减值为 4，但是通过前缀这个值也可以替换为 1 或 2。实际上，这个值几乎总是 4，因为 OS 要求栈双字对齐。<br />假定<code>ESP</code>最初指向<code>0xb20000</code>，然后执行下面的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">; 起始值ESP=0xb20000</span><br><span class="line">B8 AA AA AA AA      MOV     EAX,0AAAAAAAAh</span><br><span class="line">BB BB BB BB BB      MOV     EBX,0BBBBBBBBh</span><br><span class="line">B9 CC CC CC CC      MOV     ECX,0CCCCCCCCh</span><br><span class="line">BA DD DD DD DD      MOV     EDX,0DDDDDDDDh</span><br><span class="line">50                  PUSH    EAX</span><br><span class="line">; 地址0xb1fffc值将会是0xAAAAAAAA，ESP将会是0xb1fffc （=0xb20000-4）</span><br><span class="line">53                  PUSH    EBX</span><br><span class="line">; 地址0xb1fff8的值将会是0xBBBBBBBB，ESP将会是0xb1fff8 （=0xb1fffc-4）</span><br><span class="line">5E                  POP     ESI</span><br><span class="line">; ESI值将会是0xBBBBBBBB，ESP将会是0xb1fffc （=0xb1fff8+4）</span><br><span class="line">5F                  POP     EDI</span><br><span class="line">; EDI值将会是0xAAAAAAAA，ESP将会是0xb20000 （=0xb1fffc+4）</span><br></pre></td></tr></table></figure><p>其他一些指令也可以直接修改<code>ESP</code>，比如<code>ADD</code>和<code>SUB</code></p><p>高级语言中有函数的概念，函数可以被调用也可以返回，而处理器本身并没有提供这样的抽象。在最底层，处理器只操作具体对象，比如寄存器或内存中的数据。在机器语言这一层级通过栈数据结构来实现函数。</p><p>C 代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function">__cdecl <span class="title">addme</span><span class="params">(<span class="keyword">short</span> a, <span class="keyword">short</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rerurn a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">004113A0 55             push    ebp</span><br><span class="line">004113A1 8B EC          mov     ebp, esp</span><br><span class="line">...</span><br><span class="line">004113BE 0F BF 45 08    movsx   eax, word ptr [ebp+8]</span><br><span class="line">004113C2 0F BF 4D 0C    movsx   ecx, word ptr [ebp+0ch]</span><br><span class="line">...</span><br><span class="line">004113CB 8B E5          mov     esp, ebp</span><br><span class="line">004113CD 5D             pop     ebp</span><br><span class="line">004113CE C3             retn</span><br><span class="line">; retn 指令就是把存储在栈顶的地址出栈到EIP，然后把控制传递给他（完全与POP EIP类似，但是x86上并没有这样的指令序列）</span><br></pre></td></tr></table></figure><p>通过下面的代码调用函数：</p><p>C 代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum = addme(x,y);</span><br></pre></td></tr></table></figure><p>汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">004129F3 50             push    eax</span><br><span class="line">...</span><br><span class="line">004129F8 51             push    ecx</span><br><span class="line">004129F9 E8 F1 E7 FF FF call    addme</span><br><span class="line">004129FE 83 C4 08       add     esp, 8</span><br></pre></td></tr></table></figure><p>先了解一下调用惯例，调用惯例规定了在机器层面如何进行函数调用。对于特定的系统来说他是由应用程序二进制接口(<code>Application Binary Interface, ABI</code>)所定义的。</p><table><thead><tr><th style="text-align:left">调用惯例</th><th style="text-align:left">CDECL</th><th style="text-align:left">STDCALL</th><th style="text-align:left">FASTCALL</th></tr></thead><tbody><tr><td style="text-align:left">参数</td><td style="text-align:left">从右向左压栈。调用方负责在调用后清理栈</td><td style="text-align:left">与 CDECL 相同，除了被调用方负责清理栈</td><td style="text-align:left">前两个参数通过 ECX 和 EDX 传递。其余压栈</td></tr><tr><td style="text-align:left">返回值</td><td style="text-align:left">保存在 EAX 中</td><td style="text-align:left">保存在 EAX 中</td><td style="text-align:left">保存在 EAX 中</td></tr><tr><td style="text-align:left">非易失寄存器</td><td style="text-align:left">EBP、ESP、EBX、ESI、EDI</td><td style="text-align:left">EBP、ESP、EBX、ESI、EDI</td><td style="text-align:left">EBP、ESP、EBX、ESI、EDI</td></tr></tbody></table><p>现在我们回到前面的代码片段来讨论函数<code>addme</code>是如何被调用的。</p><p>在第 1 行和第 3 行代码中把两个参数压入栈顶，<code>EXC</code>和<code>EAX</code>分别是第一个和第二个参数。第四行代码通过<code>CALL</code>指令调用了<code>addme</code>函数。这立即导致返回地址<code>0x4120FE</code>被压栈，然后<code>0x4113A0</code>处开始执行。</p><p>第 4 行代码执行后，就进入了<code>addme</code>函数的函数体。第 1 行代码把<code>EBP</code>压栈。第 2 行代码把<code>EBP</code>设置为指向当前栈顶。这个二指令序列建立了一个新的函数帧，因此通常称为<code>函数序言</code>（<code>function prologue</code>）第 4 行代码读入地址<code>EBP+8</code>的值，他是栈的第一个参数。第 5 行代码读入第二个参数。注意参数访问是以<code>EBP</code>作为基地址的。在这个上下文环境中，<code>EBP</code>被称为<code>帧基指针</code>，因为他指向了当前函数的栈帧，参数和局部变量都可以通过相对他的地址来访问。也可以通过一种称为<code>帧指针省略</code>（<code>frame pointer omission</code>）的优化方法指定编译器生成不使用<code>EBP</code>作为帧指针的代码。这种优化下，局部变量和参数的访问是相对<code>ESP</code>进行的，这时<code>EBP</code>可以作为一个通用寄存器，就像<code>EAX</code>、<code>EBX</code>、<code>EXC</code>等寄存器一样。第六行代码执行数字的加运算，并把结果放入<code>EAX</code>中。第 8 行代码把栈指针设为帧指针。第 9 行代码将之前第 1 行中保存的<code>EBP</code>数值出栈到<code>EBP</code>。这个二指令序列结束了当前的函数调用，并恢复了函数调用前的栈帧通常称为函数尾声（<code>function epilogue</code>）。这个时间点上，栈顶值为<code>CALL</code>指令保存的返回地址<code>0x4129F9</code>。第 10 行执行<code>RET</code>指令，这个指令将栈顶元素出栈并从<code>0x4129FE</code>开始继续执行。代码中的第 5 行把栈收缩了 8 字节大小，因为根据<code>CDECL</code>调用惯例的规定，栈清理的工作必须由调用者完成。</p><p>如果函数<code>addme</code>有局部变量，那么代码需要在第 2 行之后通过减小<code>ESP</code>值来增长栈大小。然后所有的局部变量都可以通过<code>EBP</code>加上一个负的偏移量来访问。</p><h4 id="控制流"><a class="markdownIt-Anchor" href="#控制流"></a> 控制流</h4><ul><li>ZF(Zero Flag， 零标志位)：指示之前算术运算的结果是否为 0</li><li>SF(Sifn Flag， 符号标志位)：设为当前结果的最高有效位</li><li>CF(Carry Flag， 借位标志位)： 指示当前结果是否需要借位。对无符号整数有效。</li><li>OF(Over Flag， 溢出标志位)： 只是当前结果是是否超过了最大值。对有符号整数有效。<br />算术运算指令会根据计算结果更新这些标志位。举例来说，<code>SUB EAX</code>,<code>EAX</code>指令会引起 ZF 标志的设置。<code>Jcc</code>指令会根据这些标志位改变控制流，其中<code>cc</code>是某个条件代码(<code>conditional code</code>)，该指令最多支持 16 中条件代码。</li></ul><table><thead><tr><th style="text-align:left">条件代码</th><th style="text-align:left">跳转条件</th><th style="text-align:left">机器描述</th></tr></thead><tbody><tr><td style="text-align:left">JZ/JE</td><td style="text-align:left">若为 0；若相等</td><td style="text-align:left">ZF = 1</td></tr><tr><td style="text-align:left">JNZ/JNE</td><td style="text-align:left">若不为 0；若不相等</td><td style="text-align:left">ZF = 0</td></tr><tr><td style="text-align:left">JS</td><td style="text-align:left">若为负</td><td style="text-align:left">SF = 1</td></tr><tr><td style="text-align:left">JNS</td><td style="text-align:left">若不为负</td><td style="text-align:left">SF = 0</td></tr><tr><td style="text-align:left">JP/JPE</td><td style="text-align:left">若 1 出现的次数为偶数</td><td style="text-align:left">PF = 1</td></tr><tr><td style="text-align:left">JNP/JPO</td><td style="text-align:left">若 1 出现的次数为奇数</td><td style="text-align:left">PF = 0</td></tr><tr><td style="text-align:left">JO</td><td style="text-align:left">若溢出</td><td style="text-align:left">OF = 1</td></tr><tr><td style="text-align:left">JNO</td><td style="text-align:left">若无溢出</td><td style="text-align:left">OF = 0</td></tr><tr><td style="text-align:left">JC/JB/JNAE</td><td style="text-align:left">若进位；若低于；若不高于等于</td><td style="text-align:left">CF = 1</td></tr><tr><td style="text-align:left">JNC/JNB/JAE</td><td style="text-align:left">若无进位；若不低于；若高于等于</td><td style="text-align:left">CF = 0</td></tr><tr><td style="text-align:left">JBE/JNA</td><td style="text-align:left">若低于等于；若不高于</td><td style="text-align:left">ZF = 1 或 CF = 1</td></tr><tr><td style="text-align:left">JNBE/JA</td><td style="text-align:left">若不低于等于；若高于</td><td style="text-align:left">ZF = 0 或 CF = 0</td></tr><tr><td style="text-align:left">JL/JNGE</td><td style="text-align:left">若小于；若不大于等于</td><td style="text-align:left">SF != OF</td></tr><tr><td style="text-align:left">JNL/JGE</td><td style="text-align:left">若不小于；若大于等于</td><td style="text-align:left">SF = OF</td></tr><tr><td style="text-align:left">JLE/JNG</td><td style="text-align:left">若小于等于；若不大于</td><td style="text-align:left">ZF != OF 或 ZF = 1</td></tr><tr><td style="text-align:left">JNLE/JG</td><td style="text-align:left">若不小于等于；若大于</td><td style="text-align:left">SF = 0 且 ZF = 0</td></tr></tbody></table><h3 id="系统机制"><a class="markdownIt-Anchor" href="#系统机制"></a> 系统机制</h3><p>两种基础系统机制：虚拟地址转换（<code>virtual address translation</code>）和异常/中断处理（<code>exception/interrupt handling</code>）</p><h4 id="地址转换"><a class="markdownIt-Anchor" href="#地址转换"></a> 地址转换</h4><p>计算机系统中的物理内存以<code>4KB</code>为单元作为一个页（<code>page</code>）。实际上页的大小也可以超过<code>4KB</code>，这里我们不讨论其他尺寸的页。内存地址分为两种：虚拟内存和物理内存。在分页启动的情况下，处理器执行的指令中使用的地址是虚拟地址。举例来说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A1 78 56 34 12 MOV EAX, [0x12345678]  ; 读入虚内地址为0x12345678的内存</span><br><span class="line">89 08 MOV [EAX], ECX  ; 把ECX写入虚拟地址为EAX处</span><br></pre></td></tr></table></figure><p>物理地址是处理器访问内存时使用的实际内存地址。处理器的<code>MMU</code>(<code>Memory Management Unit</code>， 内存管理单元)在访问内存之前透明地把虚拟地址转换为物理地址。在用户开来虚拟地址就是一个数字，而对于<code>MMU</code>来说这个地址则是结构化的。在支持<code>PAE</code>(<code>Physical Address Extension</code>， 物理地址扩展)的<code>x86</code>系统上，虚拟地址可以划分为几个部分，作为偏移量索引到三个表中，包括<code>PDPT</code>(<code>Page Directory Pointer Table</code>，页目录指针表)、<code>PD</code>(<code>Page Directory</code>，页目录)、<code>PT</code>(<code>Page Table</code>， 页表)以及<code>PTE</code>(<code>Page Table Entry</code>，页表项)。<code>PDPT</code>是<code>4个元素</code>的数组，每个元素<code>8字节</code>，指向一个<code>PD</code>。<code>PD</code>是一个有<code>512个元素</code>的数组，每个元素<code>8字节</code>，指向一个<code>PT</code>。<code>PT</code>也是一个有<code>512个元素</code>的数组，每个元素<code>8字节</code>，指向一个<code>PTE</code>。以虚拟地址<code>0xBF80EE6B</code>(转换成二进制：<code>10111111 10000000 11101110 01101011</code>)来理解，如下表：</p><table><thead><tr><th style="text-align:left">10(0x2)</th><th style="text-align:left">111111 100(0x1FC)</th><th style="text-align:left">00000 1110(0xE)</th><th style="text-align:left">1110 01101011(0xE6B)</th></tr></thead><tbody><tr><td style="text-align:left">2 位</td><td style="text-align:left">9 位</td><td style="text-align:left">9 位</td><td style="text-align:left">12 位</td></tr><tr><td style="text-align:left">索引到 PDPT</td><td style="text-align:left">索引到 PD</td><td style="text-align:left">索引到 PT</td><td style="text-align:left">页偏移量</td></tr></tbody></table><p>这些表中的 8 字节元素包含关于表、内存访问许可以及其他内存属性的数据。比如，其中有一些位用于标识这个页是只读还是可读写、是否可执行、用户是否可以访问等。</p><p>地址转换过程就围绕着这 3 个表和<code>CR3</code>寄存器。<code>CR3</code>寄存器保存着<code>PDPT</code>的物理基地址。</p><h4 id="中断与异常"><a class="markdownIt-Anchor" href="#中断与异常"></a> 中断与异常</h4><p>简单讲就是操作系统通过中断和异常机制实现系统调用，完整的实现细节参考 Windows 内核部分。</p><h3 id="x64"><a class="markdownIt-Anchor" href="#x64"></a> x64</h3><p><code>x64</code>是<code>x86</code>的扩展，所有两者的绝大多数体系结构特性都一样，只有略微不同，比如寄存器宽度，以及某些指令不可再用(比如<code>PUSHAD</code>)。</p><h4 id="寄存器组与数据类型补充"><a class="markdownIt-Anchor" href="#寄存器组与数据类型补充"></a> 寄存器组与数据类型补充</h4><p><code>x64</code>的寄存器组有<code>18个64位GPR</code>，下面画图解释这些寄存器的结构，注意前缀为<code>R</code>的是<code>64位</code>寄存器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">64      .       .       .       31      23      15      7       0</span><br><span class="line">|RAX |    |    |    |    |    |    |    |</span><br><span class="line">|       |       |       |       |EAX    |    |    |    |</span><br><span class="line">|    |    |    |    |    |    |   AX |    |</span><br><span class="line">|    |    |    |    |    |    |   AH |   AL |</span><br><span class="line"></span><br><span class="line">64      .       .       .       31      23      15      7       0</span><br><span class="line">|RBP |    |    |    |    |    |    |    |</span><br><span class="line">|       |       |       |       |EBP    |    |    |    |</span><br><span class="line">|    |    |    |    |    |    |   BP |    |</span><br><span class="line">|    |    |    |    |    |    |    |   BPL |</span><br></pre></td></tr></table></figure><p>虽然<code>RBP</code>任然可以用作帧基指针，但实际应用中编译器生成的代码很少这么用，多数<code>x64</code>编译器只是把<code>RBP</code>当作<code>GPR</code>来用，而用<code>RSP</code>作为基地址引用局部变量。</p><h4 id="数据移动补充"><a class="markdownIt-Anchor" href="#数据移动补充"></a> 数据移动补充</h4><p><code>x64</code>支持一种称为<code>RIP</code>相对寻址(<code>RIP-relative addressing</code>)的概念，其允许指令引用数据时使用相对<code>RIP</code>的地址。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0000000000000000 48 8B 05 00 00+    mov rax, qword ptr cs:loc_A</span><br><span class="line">                                    ; 最开始写作&quot;mov rax,[rip]&quot;</span><br><span class="line">0000000000000007                    loc_A:</span><br><span class="line">0000000000000007 48 31 C0           xor rax,rax</span><br><span class="line">000000000000000A 90                 nop</span><br></pre></td></tr></table></figure><p>第 1 行读入<code>loc_A</code>的地址（为<code>0x7</code>）然后保存到<code>RAX</code>中。<code>RIP</code>相对寻址主要用于产生位置无关代码。<br />多数算术运算指令都自动升级为<code>64位</code>，即使操作数只有<code>32位</code>。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">48 B8 88 77 66+     mov rax, 1122334455667788h</span><br><span class="line">31 C0               xor eax, eax ; 也会清除RAX的高32位，也就是说执行后RAX=0</span><br><span class="line">48 C7 C0 FF FF+     mov rax, 0FFFFFFFFFFFFFFFFh</span><br><span class="line">FF C0               inc eax  ; 执行后RAX=0</span><br></pre></td></tr></table></figure><h4 id="规范地址"><a class="markdownIt-Anchor" href="#规范地址"></a> 规范地址</h4><p><code>x64</code>中虚拟地址的宽度是<code>64位</code>，但多数处理器并不支持完整的<code>64位</code>虚拟地址空间。当前<code>Intel/AMD</code>处理器只使用<code>48位</code>地址空间。所有的虚拟地址必须为规范形式。如果一个虚拟地址从<code>第63位</code>到具体实现的最高有效位都是<code>1</code>或者都是<code>0</code>，那么这个虚拟地址就称为规范地址。具体来说，这意味着从<code>48到63位</code>都要和<code>47位</code>相同。如果代码引用一个非规范地址，就会触发系统异常。</p><h4 id="函数调用"><a class="markdownIt-Anchor" href="#函数调用"></a> 函数调用</h4><p><code>x86</code>上有一些调用惯例需要通过栈来传递一些参数。对于<code>x64</code>来说，多数调用惯例都是通过寄存器传递参数，比如在<code>windows x64</code>中，只有一种调用惯例用到栈，并且其中前四个参数还是通过<code>RCX</code>、<code>RDX</code>、<code>R8</code>和<code>R9</code>来传递的；其余的参数按照从左到右的顺序压栈。Linux 上，则是前 6 个参数通过<code>RDI</code>、<code>RSI</code>、<code>RDX</code>、<code>RCX</code>、<code>R8</code>和<code>R9</code>传递。<br />------------------------本次更新时间 2018-10-16 10:53</p><h2 id="arm"><a class="markdownIt-Anchor" href="#arm"></a> ARM</h2><p>这里介绍的是<code>ARM Architecture Reference Manual ARMv7-A and ARMv777-R Edition (ARM DDI 0406B)</code>中定义的<code>ARM</code>体系结构。</p><h3 id="基本特性"><a class="markdownIt-Anchor" href="#基本特性"></a> 基本特性</h3><p><code>ARM</code>是<code>RISC</code>体系结构，因此与<code>CISC</code>体系结构(<code>x86/x64</code>)有一些基本区别。(从实践的角度说，最新版本的<code>Intel</code>处理器也具有一些<code>RISC</code>的特征；也就是说，他们已经不再是纯粹的<code>CISC</code>。)首先，与<code>x86</code>相比，<code>ARM</code>的指令集是很小的，但是提供的通用寄存器更多。第二，指令的宽度是固定的（<code>16位</code>或<code>32位</code>，根据当前状态而定）。第三，<code>ARM</code>的内存访问模式是<code>加载-存储</code>模式。这意味着操作数据之前必须先要把它从内存加载到寄存器中。只有<code>加载/存储</code>指令能够访问内存，具体来说，在<code>ARM</code>中是<code>LDR</code>和<code>STR</code>指令。如果要递增某个内存地址上的<code>32位</code>数值，必须先把数值从这个地址加载到寄存器中，递增，然后再存储回去。<code>x86</code>则允许大多数指令直接操作内存中的数据，只需要简单的加载，操作，递增三步。</p><p><code>ARM</code>还提供了几种不同级别的特权模式来实现特权隔离。<code>x86</code>上的特权级别是通过 4 种<code>ring</code>级别定义的，其中<code>ring0</code>具有最高特权级别，<code>ring3</code>的特权级别最低。在<code>ARM</code>中，有 8 种不同级别的特权模式：</p><ul><li>USR(USER,用户模式)</li><li>FIQ(FAST INTERRUPT REQUEST,快速中断请求模式)</li><li>IRQ(INTERRUPT REQUEST,中断请求模式)</li><li>SVC(SUPERVISOR, 管理模式)</li><li>MON(MONITOR,监视模式)</li><li>ABT(ABORT,中止模式)</li><li>UND(UNDERFINED,未定义指令模式)</li><li>SYS(SYSTEM,系统模式)</li></ul><p>多数操作系统内核模式运行于<code>SVC</code>。在<code>Windows</code>或<code>Linux</code>上都是。</p><p><code>x64</code>处理器可以运行在<code>32位</code>或<code>64位</code>模式下，也可以交替运行于这两种模式下。<code>ARM</code>处理与之类似，他们也可以运行在两种状态下：<code>ARM</code>和<code>Thumb</code>状态。<code>ARM/Thumb</code>状态决定的只有指令集，而不是特权模式。比如运行子啊在<code>ARM</code>状态下，指令总是<code>32位宽</code>；而在<code>Thumb</code>下，指令可以是<code>16位宽</code>也可以是<code>32位宽</code>。决定处理器执行状态的是以下两个因素。</p><ul><li>通过 BX 和 BLX 指令进行分支跳转的时候，如果目标寄存器的最低有效位是 1，就切换到 Thumb 状态。（尽管指令是 2 字节对齐或 4 字节对齐的，但处理器会忽略最低有效位，因此不会有对齐的问题。）</li><li>如果当前程序状态寄存器（CPSR）中的 T 标志位被置起，就处于 Thumb 模式。CPSR 的语义会在之后详述，目前可以把它类比为 x86 中扩展的 EFLAGS 寄存器。</li></ul><p><code>ARM</code>核心启动的时候，多数情况下都是进入<code>ARM</code>状态并保持在这个状态，知道显式或隐式地切换到<code>Thumb</code>模式。具体实践中，多数较新的操作系统使用<code>Thumb</code>代码是为了获得更高的代码密度（混合使用<code>16/32位宽</code>度指令的代码大小小于全部使用<code>32位</code>指令），而且应用程序可以运行于任意模式下。因为多数<code>Thumb</code>和<code>ARM</code>指令助记符都是相同的，所以在<code>32位Thumb</code>指令后添加一个<code>.W</code>后缀标识。</p><p>注意，有一种很常见的误解，就是把<code>Thumb</code>模式看作<code>x86/x64</code>上的实模式，把<code>ARM</code>模式看作保护模式。<code>x86/x64</code>平台上的绝大多数操作系统运行于保护模式，很少会切换回实模式。位<code>ARM</code>平台上的操作系统和应用程序则可以交替运行于<code>ARM</code>状态和<code>Thumb</code>状态。还要注意，这两个状态与前面介绍的特权模式也是完全不同的概念。<br /><code>Thumb</code>有两个版本：<code>Thumb-1</code>和<code>Thumb-2</code>。<code>Thumb-1</code>用于<code>ARMv6</code>和更早期的体系结构，指令集宽度都是<code>16位</code>。<code>Thumb-2</code>增加了更多的指令，并支持<code>16位</code>和<code>32位</code>的指令宽度。<code>ARMv7</code>只用<code>Thumb-2</code>，所以只要是讨论<code>Thumb</code>，都是<code>Thumb-2</code>、<br /><code>ARM</code>状态与<code>Thumb</code>状态还有其他一些区别，这里我们没法全部介绍。比如，某些指令只在<code>ARM</code>状态下支持，而在<code>Thumb</code>状态下不可用，或者反之。要了解更多请参考<code>ARM</code>的官方文档。<br />------------------------更新时间 2018-10-17 16:34</p><h3 id="数据类型与寄存器"><a class="markdownIt-Anchor" href="#数据类型与寄存器"></a> 数据类型与寄存器</h3><p>与高级语言类似，<code>ARM</code>也支持多种数据类型的运算，包括：<code>8位</code>（字节），<code>16位</code>（半字）、<code>32位</code>（字）和<code>64位</code>（双字）。</p><p><code>ARM</code>的体系结构定义了<code>16个32位</code>通用寄存器，命名为<code>R0~R15</code>，实际开发中只用<code>前13个作为通用寄存器</code>（就像<code>x86</code>中的<code>EAX</code>、<code>EBX</code>等），最后三个有特殊的意义。</p><ul><li><p>R13 用作栈指针(Stack Point, SP)，等价于 x86/64 下的 ESP、RSP 寄存器，指向程序栈的顶端</p></li><li><p>R14 用作连接寄存器（Link Register, SP），通常用于在函数调用中保存返回地址。某些指令会隐式的使用这个寄存器。比如，BL 总是在分支跳转到目标地址之前把返回值保存在 LR 中。x86/64 中总是把返回地址放在栈上，所以没有相应的寄存器。在不使用 LR 存储返回地址的代码中，这个寄存器可以作为通用寄存器。</p></li><li><p>R15 用作程序计数器（Program Counter，PC）。在 ARM 状态下执行的时候，PC 是当前指令的地址加 8（两条 ARM 指令之后）；在 Thumb 状态下，他是当前指令的地址加 4（两条 16 位 Thumb 指令后）。这个寄存器类似与 x86/64 下的 EIP/RIP，但后者总是指向下一条执行指令的地址。另外一个主要的区别在于，ARM 下代码可以直接读写 PC 寄存器，向 PC 寄存器写入一个值会导致运行立即从那个地址开始（参考下面代码片段）。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x00008344 push &#123;lr&#125;</span><br><span class="line">0x00008346 mov r0,pc</span><br><span class="line">0x00008348 mov.w r2, r2, ls1 #31</span><br><span class="line">0x0000834C pop &#123;pc&#125;</span><br></pre></td></tr></table></figure><p>在第 2 行执行之后，<code>R0</code>的值为<code>0x0000834A</code>(=<code>0x00008346+4</code>)</p><p>与其他体系结构类似，<code>ARM</code>把当前执行状态信息保存在当前程序状态寄存器（<code>CPSR</code>）中。从应用程序开发者的角度来看，<code>CPSR</code>类似于<code>x86/x84</code>下的<code>EFLAGS/RFLAG</code>寄存器。某些文档中会提到应用程序状态寄存器（<code>APSR</code>），这是<code>CPSR</code>中某些字段的别名。<code>CPSR</code>中有很多标志位，下面列出其中的部分：</p><ul><li>E(大小端标志位，Endianness bit)：ARM 可以运行在大端或小端模式下。这一位设置为 0 表示小端，1 表示大端。多数情况下使用小端，即为 0。</li><li>T(Thumb 标志位)：在 Thumb 状态下，这一位会设为 1；否则就是 ARM 状态。从 Thumb 到 ARM 或反向的状态切换的方式之一，就是修改这一标志位。</li><li>M(模式标志位， Mode Bit)：这几位指定当前的特权模式（USR、SVC 等）。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">        31          26      15      10              9       5               4           0</span><br><span class="line">CPSR    |cond.flags |       |1T     |大小端标志位E    |       |Thumb标志位T    |模式标志位M  |</span><br></pre></td></tr></table></figure><p>------------------------更新时间 2018-10-18 09:30</p><h3 id="系统级控制与设置"><a class="markdownIt-Anchor" href="#系统级控制与设置"></a> 系统级控制与设置</h3><p><code>ARM</code>提供了协处理器的概念来支持额外的指令和系统级设置。举例来说，如果系统支持内存管理单元(<code>MMU, Memory Management Unit</code>)，那么内存管理单元的配置接口必须提供给启动代码或内核代码。在<code>x86/x64</code>上，这些设置接口是放在<code>CR0</code>和<code>CR4</code>中的；而在<code>ARM</code>上，则放在<code>CP15</code>中，<code>ARM</code>体系结构中有<code>16</code>个协处理器，编号为<code>CP0~CP15</code>.前 13 个协处理器时可选的或者是<code>ARM</code>保留的。制造商可以通过可选协处理器实现特定的指令或功能，每个协处理器提供了额外的“操作码”和寄存器，可以通过专门的<code>ARM</code>指令控制。举例来说，<code>CP10</code>和<code>CP11</code>常常用于调试和系统设置。而且<code>CP15</code>通常被称为系统控制协处理器，它保存着绝大多数系统设置（缓存、分页、异常等）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：NEON提供了单指令多数据（SIMD）指令集，通常用于多媒体应用程序。它与基于x86体系结构的SSE/MMX指令类似。</span><br></pre></td></tr></table></figure><p>每个协处理器有<code>16个寄存器</code>和<code>8个相应的操作码</code>。这些寄存器和操作码的语义是特定于协处理器的。协处理器只能通过<code>MRC</code>(读)和<code>MCR</code>(写)指令访问，这两个指令接受协处理器编号、寄存器编号和操作码作为参数。举例来说，要读出转换基址寄存器(类似于<code>x86/x64</code>中的<code>CR3</code>)并保存到<code>R0</code>中，可以使用如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MRC p15, 0, r0, c2, c0, 0 ; 保存到TTBR中</span><br></pre></td></tr></table></figure><p>这句代码表示：“使用操作码<code>0/0</code>读出<code>CP15</code>的<code>C2/C0</code>，并保存结果到通用寄存器<code>R0</code>。”因为每个协处理器有很多寄存器和操作码，需要阅读文档才能确定其中每一个的精确含义。有些寄存器（<code>C13/C0</code>）是操作系统保留的，用于保存特定于进程或线程的数据。</p><p><code>MRC</code>和<code>MCR</code>指令并不需要高特权级别才能运行（也就是说，可以在 USR 模式下执行），但有些协处理器寄存器和操作码只能在<code>SVC</code>模式下访问，如果没有足够的特权级别，该寄存器会导致异常。在实际的用户模式代码中很少看到这些指令，他们通常用在像<code>ROM</code>、<code>bootloader</code>、固件这样很底层的代码或内核模式代码中。<br />------------------------更新时间 2018-10-21 13:10</p><h3 id="指令集介绍"><a class="markdownIt-Anchor" href="#指令集介绍"></a> 指令集介绍</h3><p>相比起<code>x86</code>体系结构，除了条件执行和桶式移位器，ARM 的指令集还有几点独特之处。首先，有些指令可以一次操作一系列寄存器。比如要把 5 个寄存器<code>R6~R10</code>保存到<code>R1</code>指向的一段内存位置，可以使用指令<code>STM R1,&#123;R6-R10&#125;</code>。<code>R6</code>会保存到内存地址<code>R1</code>，<code>R7</code>保存到<code>R1+4</code>，<code>R8</code>保存到<code>R1+8</code>，以此类推。对于不连续的寄存器，可以用逗号分隔（比如<code>&#123;R1,R5,R8&#125;</code>）。<code>ARM</code>的汇编语法中，寄存器范围通常用花括号表示。其次，有些指令在读写操作之后可能会更新基址寄存器，这通常通过在寄存器名后添加感叹号<code>!</code>来表示。举例来说，如果把前面的指令改写为<code>STM R1!, &#123;R6-R10&#125;</code>并执行，那么<code>R1</code>将会被更新为保存<code>R10</code>的地址之后的下一个地址。<br />------------------------更新时间 2018-10-22 08:10</p><h3 id="数据加载与存储"><a class="markdownIt-Anchor" href="#数据加载与存储"></a> 数据加载与存储</h3><p><code>ARM</code>是一种<code>加载-存储式</code>的体系结构，这意味着数据一定要加载到寄存器中才能操作。只有加载和存储指令能够访问内存，所有其他指令都只能操作寄存器。加载是指从内存中读入数据并保存到寄存器中的过程，存储则是指把寄存器的内容写入内存中的过程。在<code>ARM</code>体系结构中，加载和存储指令包括<code>LDR/STR</code>、<code>LDM/STM</code>和<code>PUSH/POP</code>。</p><h4 id="ldr-与-str"><a class="markdownIt-Anchor" href="#ldr-与-str"></a> LDR 与 STR</h4><p><code>LDR/STR</code>指令比较基础的形式是，接受一个基址寄存器和一个偏移量作为参数。偏移量的表示有三种格式（立即数、寄存器、标量寄存器），每种格式有三种寻址形式。</p><p>第一种形式使用立即数作为偏移量。立即数就是一个整数。把这个数字与基址寄存器相加或相减，用于访问编译期偏移量可知的数据。立即数最常见的用途是访问结构或虚函数表中的某个特定字段。一般形式：</p><ul><li><code>STR Ra, [Rb, imm]</code></li><li><code>LDR Ra, [Rc, imm]</code><br /><code>Rb</code>是基址寄存器，<code>imm</code>是要加到<code>Rb</code>的偏移量</li></ul><p>第二种偏移量格式用一个寄存器作为偏移量，通常用于访问数组中的元素，其索引值是运行时计算出的情况。其一般格式如下：</p><ul><li><code>STR Ra, [Rb, Rc]</code></li><li><code>LDR Ra, [Rb, Rc]</code><br />根据上下文的不同，<code>Rb</code>或<code>Rc</code>可以是基址或偏移量。</li></ul><p>第三种偏移量格式是使用标量寄存器作为偏移量。通常这种形式用在数组的迭代循环，而桶式移位器用于计算偏移量的步长。这种格式的一般形式如下：</p><ul><li><code>STR Ra, [Rb, Rc, &lt;shifter&gt;]</code></li><li><code>LDR Ra, [Rb, Rc, &lt;shifter&gt;]</code><br />Rb 是基址寄存器，Rc 是一个立即数，<code>&lt;shifter&gt;</code>是在立即数上执行的操作，他通常通过一个左移或右移操作对立即数进行成比例放大或缩小。</li></ul><p>------------------------更新时间 2018-10-23 07:30</p><h4 id="ldr-的其他用途"><a class="markdownIt-Anchor" href="#ldr-的其他用途"></a> LDR 的其他用途</h4><p><code>LDR</code>用于从内存向寄存器中加载数据，但有时候会看到这样的形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">01: DF F8 50 82 LDR.W R8, =0x2932E00 ; LDR R8, [PC, x]</span><br><span class="line">02: 80 4A LDR R2, =a04d ; &quot;%04d&quot; ; LDR R2, [PC, y]</span><br><span class="line">03: 0E 4B LDR R3, =__imp_realloc ; LDR R3, [PC, z]</span><br></pre></td></tr></table></figure><p>伪指令内部使用了立即数寻址形式的<code>LDR</code>指令，<code>PC</code>作为基址寄存器。有时这也成为<code>PC</code>相对寻址（或在<code>x64</code>上称为<code>RIP</code>相对寻址）。<code>ARM</code>二进制文件通常有一个文本池（<code>literal pool</code>），这是某个字段中的一块内存区域，用于保存常量、字符串和用于提供位置无关索引支持的偏移量。（文本池是代码的一部分，所以在同一段中。）在前面的代码片段里，代码引用了保存在文本池中的一个<code>32</code>位常量、一个字符串和一个导入函数的偏移量。利用这种伪指令，可以只通过一个指令就把 32 位常量移入寄存器，因此它是很有用的。为了更清晰一点，下面给出一段代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">01: .text:0100B134 35 4B LDR R3, =0x68DB8BAD</span><br><span class="line">; 实际上就是LDR R3, [PC, #0xD4]</span><br><span class="line">; 这时PC = 0x0100B138</span><br><span class="line">02: ...</span><br><span class="line">03: .text:0100B20C AD 8B DB 68  dword_100B20C DCD 0x68DB8BAD</span><br></pre></td></tr></table></figure><p>因为代码处于<code>Thumb</code>状态，<code>PC</code>值是当前指令加上<code>4</code>，也就是<code>0x0100B138</code>。这里使用了立即数寻址方式，所以要读出位于<code>0x0100B20C</code>（<code>=0x0100B138+0x4D</code>）的字，这就是我们想要加载的常量。<br />------------------------更新时间 2018-10-26 07:00</p><h4 id="ldm-与-stm"><a class="markdownIt-Anchor" href="#ldm-与-stm"></a> LDM 与 STM</h4><p><code>LDM</code>和<code>STM</code>与<code>LDR/STR</code>类似，区别是前者可以从给定的基址寄存器加载多个字。<code>LDM</code>和<code>STM</code>通常用于从内存读出或写入多个数据块，通常语法为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDM&lt;mode&gt; Rn[!], &#123;Rm&#125;</span><br><span class="line">STM&lt;mode&gt; Rn[!], &#123;Rm&#125;</span><br></pre></td></tr></table></figure><p><code>Rn</code>是基址寄存器，其中保存要加载/存储的内存地址。<code>！</code>是可选的，意思是基址寄存器会更新为新的地址（写回）。<code>Rm</code>是要加载或存储的范围。<code>LDM</code>和<code>STM</code>有四种模式。</p><ul><li>IA（后递增，Increment After）模式把数据存储到基址寄存器指定的内存位置。如果有写回的话，就写回最后一个地址加 4 字节的地址。如果没有指定的话，这是默认使用的模式。</li><li>IB（前递增，Increment Before）模式把数据存储在基址寄存器加 4 的地址上。如果有写会的话，就把最后地址写回。</li><li>DA（后递减，Decrement After）模式保存数据使得最后的地址是基地址。如果有写回的话，就把最低地址减 4 写回。</li><li>DB（前递减，Decrement Before）模式存储数据使得最后的地址是基地址减 4.如果有写回的话，就把最低地址写回。</li></ul><p>下面是调试器观察的实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">(gdb) br main</span><br><span class="line">Breakpoint 1 at 0x8344</span><br><span class="line">(gdb) disas main</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">0x00008344 &lt;+0&gt;: ldr r6, =mem ; 稍有修改</span><br><span class="line">0x00008348 &lt;+4&gt;: mov r0, #10</span><br><span class="line">0x0000834c &lt;+8&gt;: mov r1, #11</span><br><span class="line">0x00008350 &lt;+12&gt;: mov r2, #12</span><br><span class="line">0x00008354 &lt;+16&gt;: ldm r6, &#123;r3,r4,r5&#125; ; IA模式</span><br><span class="line">0x00008358 &lt;+20&gt;: stm r6, &#123;r0,r1,r2&#125; ; IA模式</span><br><span class="line">...</span><br><span class="line">(gdb) r</span><br><span class="line">Breakpoint 1, 0x00008344 in main ()</span><br><span class="line">(gdb) si</span><br><span class="line">0x00008348 in main ()</span><br><span class="line">(gdb) x/3x $r6</span><br><span class="line">0x105c &lt;mem&gt;: 0x00000001 0x00000002 0x00000003</span><br><span class="line">(gdb) si</span><br><span class="line">0x0000834c in main ()</span><br><span class="line">...</span><br><span class="line">(gdb)</span><br><span class="line">0x00008358 in main ()</span><br><span class="line">(gdb) info reg r3 r4 r5</span><br><span class="line">r3 0x1 1</span><br><span class="line">r4 0x2 2</span><br><span class="line">r5 0x3 3</span><br><span class="line">(gdb) si</span><br><span class="line">0x0000835c in main ()</span><br><span class="line">(gdb) x/3x $r6</span><br><span class="line">0x1050c &lt;mem&gt;: 0x0000000a 0x0000000b 0x0000000c</span><br></pre></td></tr></table></figure><p>第 5 行把一个内存地址写入<code>R6</code>，这个内存地址（<code>0x1050c</code>）的内容是一个 3 字数据（第 17 行）。6-8 行将<code>R2～R0</code>设置为某个常量。第 9 行加载从<code>R6</code>指向的内存地址开始的 3 个字到<code>R3～R5</code>。如第 24 ～ 26 行所示，<code>R3～R5</code>的内容正是期望值。第 10 行存储<code>R0~R2</code>到<code>R6</code>指向的内存地址开始的空间。第 29 行显示了期望的写入值。下图展示前面的操作结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> mem</span><br><span class="line">|---|</span><br><span class="line">| 0x1 |  |  | ldr r6, =mem |</span><br><span class="line">| --- ||| mov r0, #10</span><br><span class="line">| 0x2 |  |  | mov r1, #11 |</span><br><span class="line">| --- ||| mov r2, #12</span><br><span class="line">| 0x3 |  |  | ldm r6, &#123;r3,r4,r5&#125; |</span><br><span class="line">| --- |\/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">|---|</span><br><span class="line">| 0x1 | r6 |  | stm r6, &#123;r0,r1,r2&#125; |</span><br><span class="line">| --- |||</span><br><span class="line">| 0x2 | r6+4 |  |</span><br><span class="line">| --- |||</span><br><span class="line">| 0x3 | r6+8 |  |</span><br><span class="line">| --- |\/</span><br><span class="line">r0=a r1=b r2=c</span><br><span class="line">r3=1 r4=2 r5=3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">|---|</span><br><span class="line">| 0xA | r6   |</span><br><span class="line">| --- |</span><br><span class="line">| 0xB | r6+4 |</span><br><span class="line">| --- |</span><br><span class="line">| 0xC | r6+8 |</span><br><span class="line">| --- |</span><br><span class="line">r0=a r1=b r2=c</span><br><span class="line">r3=1 r4=2 r5=3</span><br></pre></td></tr></table></figure><p>下面用写回模式做同样的实验：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">(gdb) br main</span><br><span class="line">Breakpoint 1 at 0x8344</span><br><span class="line">(gdb) disaa main</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">0x00008344 &lt;+0&gt;: ldr r6, =mem ; 稍有修改</span><br><span class="line">0x00008348 &lt;+4&gt;: mov r0, #10</span><br><span class="line">0x0000834c &lt;+8&gt;: mov r1, #11</span><br><span class="line">0x00008350 &lt;+12&gt;:mov r2, #12</span><br><span class="line">0x00008354 &lt;+16&gt;:ldm r6!, &#123;r3, r4, r5&#125; ; IA带写回模式</span><br><span class="line">0x00008358 &lt;+20&gt;:stmia r6!, &#123;r0, r1, r2&#125; ; IA带写回模式</span><br><span class="line">...</span><br><span class="line">(gdb) r</span><br><span class="line">Breakpoint 1, 0x0008344 in main ()</span><br><span class="line">(gdb) si</span><br><span class="line">0x00008348 in main ()</span><br><span class="line">...</span><br><span class="line">(gdb)</span><br><span class="line">0x00008354 in main ()</span><br><span class="line">(gdb) x/3x $r6</span><br><span class="line">0x1050c &lt;mem&gt;： 0x000001 0x00000002 0x00000003</span><br><span class="line">(gdb) si</span><br><span class="line">0x00008358 in main ()</span><br><span class="line">(gdb) info reg r6</span><br><span class="line">r6 0x10518 66840</span><br><span class="line">(gdb) si</span><br><span class="line">0x0000835c in main ()</span><br><span class="line">(gdb) info reg $r6</span><br><span class="line">r6 0x10524 66852</span><br><span class="line">(gdb) x/4x $r6-12</span><br><span class="line">0x10518 : 0x0000000a 0x0000000b 0x0000000c</span><br></pre></td></tr></table></figure><p><code>0x00000000</code></p><p>第 9 行使用<code>IA</code>写回模式，所以<code>R6</code>更新为最后地址加 4 的值（第 23 行）。第 10 行、27 行和 30 行可以看到同样的模式。下图展示了实验代码片段执行的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> mem</span><br><span class="line">|---|</span><br><span class="line">| 0x1 | 0x1050c |  | ldr r6, =mem |</span><br><span class="line">| --- ||| mov r0, #10</span><br><span class="line">| 0x2 | 0x1050c+4 |  | mov r1, #11 |</span><br><span class="line">| --- ||| mov r2, #12</span><br><span class="line">| 0x3 | 0x1050c+8 |  | ldm r6!, &#123;r3,r4,r5&#125; |</span><br><span class="line">| --- |0x1050c+c \/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">|---|</span><br><span class="line">| 0x1 | 0x1050c |  | stm r6, &#123;r0,r1,r2&#125; |</span><br><span class="line">| --- |||</span><br><span class="line">| 0x2 | 0x1050c+4 |  |</span><br><span class="line">| --- |||</span><br><span class="line">| 0x3 | 0x1050c+8 |  |</span><br><span class="line">| --- |0x1050c+c r6 \/</span><br><span class="line">r0=a r1=b r2=c</span><br><span class="line">r3=1 r4=2 r5=3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">|---|</span><br><span class="line">| 0x1 | 0x1050c       |</span><br><span class="line">| --- |</span><br><span class="line">| 0x2 | 0x1050c+4     |</span><br><span class="line">| --- |</span><br><span class="line">| 0x3 | 0x1050c+8     |</span><br><span class="line">| --- |</span><br><span class="line">| 0xA | 0x1050c+c     |</span><br><span class="line">| --- |</span><br><span class="line">| 0xB | 0x1050c+10    |</span><br><span class="line">| --- |</span><br><span class="line">| 0xC | 0x1050c+14    |</span><br><span class="line">| --- | 0x1050c+18 r6 |</span><br></pre></td></tr></table></figure><p><code>LDM</code>和<code>STM</code>指令可以一次写入多个字，所以通常用于块复制和块移动操作。比如有时用这些指令来执行编译时复制长度已知的内联<code>memcpy</code>。这类似于<code>x86</code>中带有<code>REP</code>前缀的<code>movs</code>指令。</p><ul><li>注意<br /><code>STM/LDM</code>后面经常会出现后缀<code>FD</code>、<code>FA</code>、<code>ED</code>或<code>EA</code>。它们就是不同模式下（<code>IA/IB</code>等）的<code>STM/LDM</code>指令的伪指令，分别对应于<code>STMFD/STMDB</code>、<code>STMFA/STMIB</code>、<code>STMED/STMDA</code>、<code>STMEA/STMIA</code>、<code>LDMFD/LDMIA</code>、<code>LDMFA/LDMDA</code>和<code>LDMEA/LDMDB</code>。因为这些对应关系太难记忆，建议为每个指令画一个图。</li></ul><p>------------------------更新时间 2018-11-4 08:00</p><h4 id="push-与-pop"><a class="markdownIt-Anchor" href="#push-与-pop"></a> PUSH 与 POP</h4><p>加载/存储指令的最后一组是<code>PUSH</code>和<code>POP</code>。他们类似于<code>LDM/STM</code>，但有两点不同：</p><ul><li>他们隐式地使用 SP 作为基地址；</li><li>SP 会自动更新。</li></ul><p>和<code>x86/x64</code>中的一样，栈是朝下向低地址方向增长的。通用的语法是<code>PUSH/POP &#123;Rn&#125;</code>,其中<code>Rn</code>可以是一个寄存器范围。</p><p><code>PUSH</code>指令把一个或多个寄存器保存在栈中，使得最后一个的位置位于当前栈指针向下 4 字节处，然后把<code>SP</code>更新为第一个位置的地址。<code>POP</code>从当前栈指针处开始向寄存器加载数据，然后更新<code>SP</code>为最后一个位置的地址的向上 4 字节处。<code>PUSH/POP</code>实际上就是以<code>SP</code>作为基地址指针的带写回的<code>STMDB/LDMIA</code>。</p><p>最常用到<code>PUSH/POP</code>的地方就是在函数的起始和结束处，在这里他们被用作函数序言和尾声（就像<code>ARM</code>状态下的<code>STMFD/LDMFD</code>一样）。举例来说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2D E9 F0 4F PUSH.W &#123;R4-R11, LR&#125; ; 保存寄存器和返回地址</span><br><span class="line">...</span><br><span class="line">BD E9 F0 8F POP.W &#123;R4-R11, PC&#125; ; 恢复寄存器值并返回</span><br></pre></td></tr></table></figure><p>------------------------更新时间 2018-11-5 07:00</p><h3 id="函数与函数调用"><a class="markdownIt-Anchor" href="#函数与函数调用"></a> 函数与函数调用</h3><p><code>x86/x64</code>只有一个用于函数调用的指令（<code>CALL</code>）和一个用于分支跳转的指令（<code>JMP</code>）。与之不同，根据目标地址的编码方式，ARM 则提供了多种指令。调用函数的时候，处理器需要知道函数返回后从哪里继续执行，这个位置通常被称为返回地址。在<code>x86</code>中，<code>CALL</code>指令在跳转到目标函数之前隐式地把返回地址压入栈顶，等到目标函数执行完毕，会把栈顶弹出到<code>EIP</code>，从而从返回地址恢复执行。</p><p><code>ARM</code>体系结构上的机制本质上也是如此，只有几点微小的区别。首先，返回地址可以保存在栈上，也可以保存在链接寄存器（<code>LR</code>）中；调用结束后要恢复执行，需要显式地把返回地址从栈上弹出到<code>PC</code>寄存器，否则会无条件跳转到<code>LR</code>。其次，根据目标地址的最低位（<code>LSB</code>）不同，一次分支跳转可以在<code>ARM</code>状态和<code>Thumb</code>状态之间切换。第三点，<code>ARM</code>定义了标准调用惯例：前 4 个 32 位参数通过寄存器（<code>R0-R3</code>）传递，其余的参数放在栈上。返回值保存在<code>R0</code>中。</p><p><code>ARM</code>中函数调用的指令是<code>B</code>、<code>BX</code>、<code>BL</code>和<code>BLX</code>。</p><p>尽管在函数调用的上下文中很少看到<code>B</code>指令，但这条指令确实可以用于控制传递。他就是一条简单的无条件跳转指令，于<code>x86</code>中的<code>JMP</code>指令相同，通常在循环和条件执行内部用于跳转到开头或跳出循环，还可以用于调用永不返回的函数。</p><p><code>B</code>指令只能使用标签偏移量作为其目标地址，而不能使用寄存器。在这种情况下，<code>B</code>指令的语法为<code>B imm</code>，其中<code>imm</code>是相对于当前指令的偏移量。（这里没有考虑条件执行标志位，将会在之后的笔记中详细介绍。）需要记住的是：因为<code>ARM</code>和<code>Thumb</code>指令是<code>2字节</code>或<code>4字节</code>对齐的，所以目标偏移量必须是一个偶数。</p><p><code>BX</code>是分支跳转并交换（<code>Branch and Exchange</code>）。与<code>B</code>指令的相似之处在于，两者都是把控制转移到某个目标地址处，但<code>BX</code>能够在<code>ARM</code>和<code>Thumb</code>状态间切换，并且目标地址是保存在寄存器中的。分支跳转指令以<code>X</code>结尾，表示这条指令能切换状态。如果目标地址最低位是 1，那么处理器会自动切换到<code>Thumb</code>状态，否则就执行在<code>ARM</code>状态。指令的格式是<code>BX&lt;寄存器&gt;</code>，其中寄存器中存有目标地址。这条指令有两种最常用的方式，一种是通过跳转到<code>LR</code>（也即 <code>BX LR</code>）从函数返回，还有一种是用于切换到不同状态的代码（也即从<code>ARM</code>切换到<code>Thumb</code>状态或反之）。在编译后的代码中，函数结尾处几乎总会出现<code>BX LR</code>，基本上于<code>x86</code>中的<code>RET</code>相同。</p><p><code>BL</code>是分支跳转并连接（<code>Branch with Link</code>），它类似于<code>B</code>指令，但他可以在把控制切换到目标偏移量之前把返回地址保存到<code>LR</code>。这也许是和<code>x86</code>中的<code>CALL</code>指令最为接近的一条指令，经常在函数调用中使用。<code>BL</code>指令格式与<code>B</code>指令相同（也就是说，只接受偏移量参数）。下面这段代码解释了函数调用和返回的过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">00014350 BL foo ; LR = 0x00014354</span><br><span class="line">00014354 MOVS R4, #0x15</span><br><span class="line">...</span><br><span class="line">0001B224 foo</span><br><span class="line">0001B224 PUSH &#123;R1-R3&#125;</span><br><span class="line">0001B226 MOV R3, 0x6124</span><br><span class="line">...</span><br><span class="line">0001B24C BX LR ; 返回到0x00014354</span><br></pre></td></tr></table></figure><p>上面代码的第 1 行使用<code>BL</code>调用函数<code>foo</code>。在转换控制到目标之前，<code>BL</code>在<code>LR</code>中保存了返回地址（<code>0x000014354</code>）。<code>foo</code>做了一些工作然后返回到调用者（<code>BX LR</code>）。</p><p><code>BLX</code>是指跳转加连接和交换（<code>Branch with Link and Exchange</code>）。于<code>BL</code>类似，<code>BLX</code>也可以支持状态切换。两者主要的区别在于，<code>BLX</code>可以接受偏移量或寄存器作为跳转目标，而且在<code>BLX</code>指令使用偏移量的情况下，处理器总是会切换状态（<code>ARM</code>到<code>Thumb</code>或反之）。因为这条指令于<code>BL</code>的特性相同，也可以把它当做<code>x86</code>中的<code>CALL</code>指令。实际使用中，<code>BL</code>和<code>BLX</code>都用于实现函数调用。如果函数在<code>32MB</code>范围之内，通常使用<code>BL</code>，而目标区域不确定（比如函数指针）的时候常用<code>BLX</code>。通常在<code>Thumb</code>状态下运行的时候，使用<code>BLX</code>指令调用库例程，而在<code>ARM</code>状态下使用<code>BL</code>。</p><p>------------------------更新时间 2018-11-9 07:00</p><h3 id="算术运算"><a class="markdownIt-Anchor" href="#算术运算"></a> 算术运算</h3><p>把数值从内存加载到寄存器之后，代码就可以上面执行各种操作了。最简单的操作就是通过<code>mov</code>指令把数据移动到另一个寄存器中。操作源可以是常量、寄存器或桶式移位器的运算结果。桶式移位器运算包括左移（<code>LSL</code>）、右移（<code>LSR</code>、<code>ASR</code>）和循环移位（<code>ROR</code>、<code>RRX</code>）。桶式移位器让指令可以操作无法以立即数形式编码的常量，因此很有用处。<code>ARM</code>和<code>Thumb</code>指令的宽度可能是<code>16</code>位或<code>32</code>位，所以无法直接使用<code>32</code>位常数作为参数。有了桶式移位器，立即数可以被转换为一个更大值然后移动到其他寄存器。另一种移动<code>32</code>位常量到寄存器的方法是把常量分割为两个<code>16位</code>数值，分两次移动；这通常通过<code>MOVW</code>和<code>MOVT</code>指令实现。<code>MOVT</code>设置寄存器的<code>高16位</code>，<code>MOVW</code>设置<code>低16位</code>。</p><p>基本算术和逻辑运算包括<code>ADD</code>、<code>SUB</code>、<code>MUL</code>、<code>AND</code>、<code>ORR</code>和<code>EOR</code>。</p><p>注意：<code>ARM</code>没有原生的除法指令。（<code>ARMv7-R</code>和<code>ARMv7-M</code>内核有<code>SDIV</code>和<code>UDIV</code>指令，但这里不讨论）实际应用中，运行时会使用软件实现来进行除法运算，代码只要按需调用。下面是<code>Windows C</code>运行时的一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">41 46 MOV R1， R8</span><br><span class="line">40 46 MOV R0,R6</span><br><span class="line">35 F0 9E 9F BL __rt_udiv ; udiv的软件实现</span><br></pre></td></tr></table></figure><p>------------------------更新时间 2018-11-11 07:00</p><h3 id="分支跳转与条件执行"><a class="markdownIt-Anchor" href="#分支跳转与条件执行"></a> 分支跳转与条件执行</h3><p>前面讨论的都是按照线性顺序执行的例子，而绝大多数程序都包含有条件与循环。在汇编代码层级，这些结构是通过存储在应用程序状态寄存器（<code>APSR</code>）中的条件标志位实现的。<code>APSR</code>是<code>CPSR</code>的别名，类似于<code>x86</code>中的<code>EFLAG</code>寄存器。</p><ul><li>N（Negative，负值标志位）：如果运算的结果是负数，这个标志就会被设置（结果的最高有效位为 1）</li><li>Z（Zero，零标志位）：运算结果为 0 时设置</li><li>C（Carry，借位标志位）：两个无符号值计算结果溢出时设置</li><li>V（Overflow，溢出标志位）：两个有符号值计算结果溢出时设置</li><li>IT（If-then 标志位）：这些标志位编码了 Thumb 指令 IT 使用的各种条件。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        31          26      15      10              9       5               4           0</span><br><span class="line">CPSR    |cond.flags |       |1T     |大小端标志位E    |       |Thumb标志位T    |模式标志位M  |</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">APSR |N|Z|C|V|Q  |       |保留|</span><br><span class="line"> 31 26 15 0</span><br></pre></td></tr></table></figure><p>N、Z、C 和 V 标志位与 x86 中的 EFLAG 寄存器的 SF、ZF、CF 和 OF 标志位相同。在更高级的语言中，使用这些标志位来实现条件和循环；在指令级代码中，也通过这些标志位支持条件执行。通过这些标志位来描述相等性。</p><table><thead><tr><th style="text-align:left">后缀/编码</th><th style="text-align:left">意义</th><th style="text-align:left">标志位</th></tr></thead><tbody><tr><td style="text-align:left">EQ</td><td style="text-align:left">等于</td><td style="text-align:left">Z==1</td></tr><tr><td style="text-align:left">NE</td><td style="text-align:left">不等于</td><td style="text-align:left">Z==0</td></tr><tr><td style="text-align:left">MI</td><td style="text-align:left">减、负</td><td style="text-align:left">N==1</td></tr><tr><td style="text-align:left">PL</td><td style="text-align:left">加、正或者为 0</td><td style="text-align:left">N==0</td></tr><tr><td style="text-align:left">HI</td><td style="text-align:left">无符号大于</td><td style="text-align:left">C<mark>1 且 Z</mark>0</td></tr><tr><td style="text-align:left">LS</td><td style="text-align:left">无符号小于</td><td style="text-align:left">C<mark>0 或 Z</mark>1</td></tr><tr><td style="text-align:left">GE</td><td style="text-align:left">有符号大于等于</td><td style="text-align:left">N==V</td></tr><tr><td style="text-align:left">LT</td><td style="text-align:left">有符号小于</td><td style="text-align:left">N！=V</td></tr><tr><td style="text-align:left">GT</td><td style="text-align:left">有符号大于</td><td style="text-align:left">Z<mark>0 且 N</mark>V</td></tr><tr><td style="text-align:left">LE</td><td style="text-align:left">有符号小于等于</td><td style="text-align:left">Z==1 或 N！=V</td></tr></tbody></table><p>默认情况下指令不会更新条件标志位，除非使用了 S 后缀。比较指令（CBZ、CMP、TST、CMN 和 TEO）会自动更新标志位，因为通常他们被用于分支指令之前。</p><p>最常用的比较指令可能就是 CMP。其语法为 CMP Rn, X，其中 Rn 是寄存器，X 可以是立即数、寄存器或桶式移位操作。其语义与 x86 中的同名指令相同：执行 Rn - X，设置相应的标志位，然后丢弃结果。通常这条指令后面会跟随一个条件分支跳转。下面是一个用法示例及其伪代码：<br />ARM</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">B3 EB E7 7F CMP.W  R3, R7, ASR #31</span><br><span class="line">05 DB BLT  loc_less</span><br><span class="line">01 DC  BGT  loc_greater</span><br><span class="line">BD 42 CMP  R5, R7</span><br><span class="line">02 D9  BLS  loc_less</span><br><span class="line"> loc_greater</span><br><span class="line">07 3D  SUBS  R5, #7</span><br><span class="line">6E F1 00 0E  SBC.W  LR, LR, #0</span><br><span class="line"> loc_less</span><br><span class="line">A5 FB 08 12  UMULL.W R1, R2, R5, R8</span><br><span class="line">87 FB 08 04  SMULL.W R0, R4, R7, R8</span><br><span class="line">0E FB 08 23  MLA.W  R3, LR, R8, R2</span><br></pre></td></tr></table></figure><p>C 伪代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (r3 &lt; r7) &#123;goto loc_less;&#125;</span><br><span class="line"> else if (r3 &gt; r7) &#123;goto loc_greater;&#125;</span><br><span class="line"> else if (r5 &lt; r7) &#123;goto loc_less;&#125;</span><br></pre></td></tr></table></figure><p>------------------------更新时间 2018-11-12 07:00</p><h4 id="thunb-状态"><a class="markdownIt-Anchor" href="#thunb-状态"></a> Thunb 状态</h4><h4 id="switch-case"><a class="markdownIt-Anchor" href="#switch-case"></a> switch-case</h4><h3 id="杂项"><a class="markdownIt-Anchor" href="#杂项"></a> 杂项</h3><h2 id="windows-内核"><a class="markdownIt-Anchor" href="#windows-内核"></a> Windows 内核</h2><h2 id="调试与自动化"><a class="markdownIt-Anchor" href="#调试与自动化"></a> 调试与自动化</h2><h2 id="代码混淆"><a class="markdownIt-Anchor" href="#代码混淆"></a> 代码混淆</h2><h2 id="代码研究"><a class="markdownIt-Anchor" href="#代码研究"></a> 代码研究</h2><h3 id="windows-内核代码"><a class="markdownIt-Anchor" href="#windows-内核代码"></a> windows 内核代码</h3><p>片段 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">; NTSTATUS __cdecl sub_4038f0(PFILE_OBJECT FileObject, HANDLE Handle, BOOLEAN flag)</span><br><span class="line">sub_4038F0 proc near</span><br><span class="line">push rbx ; rbx压栈</span><br><span class="line">push rbp ; rbp压栈</span><br><span class="line">push rsi ; rsi压栈</span><br><span class="line">push rdi ; rdi压栈</span><br><span class="line">push r12 ; r12压栈</span><br><span class="line">sub rsp, 60h ; rsp的值减去0x60</span><br><span class="line">mov bpl, r8b ; r8p的值入bpl</span><br><span class="line">mov r12, rdx ; 将rdx的值放进栈r12中</span><br><span class="line">mov rdi, rcx ; 将rcx的值放进栈rdi中</span><br><span class="line">mov cs:IoGetRelatedDeviceObject ; IoGetRelatedDeviceObject返回值指向相应设备对象的指针</span><br><span class="line">mov [rsp+88h+arg_18], 1 ; 把1赋给[rsp+88h+arg_18]</span><br><span class="line">xor edx, edx ; ChargeQuota 将edx初始化置0</span><br><span class="line">mov cl, [rax+4ch] ; StackSize 栈空间大小</span><br><span class="line">mov rsi, rax ; 将rax的值放进栈rsi中</span><br><span class="line">call cs:IoAllocateIrp ; IoAllocateIrp例程分配一个IRP（为每个驱动层下的调用者给定I/O堆栈数量和选项）</span><br><span class="line">test rax, rax ; 相当于and rax rax，根据结果设置标志位，不会保存结果。（影响标志位C,O,P,Z,S。其中C与O两个标志会被设为0）</span><br><span class="line">mov rbx, rax ; 将rax的值放进栈rbx中</span><br><span class="line">jnz short loc_403932 ; 如果Z标志位为0，就跳转到loc_403932中</span><br><span class="line">mov eax, 0C0000017h ; 把立即数0C0000017h放进eax（此处用来表示跳转失败）。立即数必须以数开头，以字母开头会被认为是寄存器或变量。</span><br><span class="line">jmp loc_403A0C ; 无条件跳转到 loc_403A0C方法（loc_403A0C方法的作用是清理栈空间）</span><br><span class="line">loc_403932:</span><br><span class="line">lea rax, [rsp+88h+arg_18] ; rax获取[rsp+88h+arg_18]的地址</span><br><span class="line">xor r8d, r8d ; State 状态值初始化为0</span><br><span class="line">lea rcx, [rsp+88h+Event] ; Event rcx获取[rsp+88h+Event]的地址</span><br><span class="line">mov [rbx+18h], rax ; IRP.AssociatedIrp.SystemBuffer 把rax所指向地址的值赋给[rbx+18h]，也就是把1赋给[rbx+18h]</span><br><span class="line">lea rax, [rsp+88h+Event] ; rax获取[rsp+88h+Event]的地址</span><br><span class="line">lea edx, [r8+1] ; Type 类型 edx获取[r8+1]的地址</span><br><span class="line">mov [rbx+50h], rax ; IRP.UserEvent 把rax所指向[rsp+88h+Event]地址的值赋给[rbx+50h]，作为用户事件</span><br><span class="line">lea rax, [rsp+88h+var_58] ; rax获取[rsp+88h+var_58]的地址</span><br><span class="line">mov [rbx+48h], rax ; IRP.UserIosb 把rax所指向[rsp+88h+var_58]地址的值赋给[rbx+48h]</span><br><span class="line">mov rax, gs:+188h ; KPCR.Prcb.CurrentThread gs寄存器基址+18h得到的地址处的值，赋给rax</span><br><span class="line">mov [rbx+0C0h], rdi ; IRP.Tail.OVerlay.OriginalFileObiect 把寄存器rdi的值（也就是前面rcx的值）放进内存[rbx+48h]中</span><br><span class="line">mov [rbx+98h], rax ; IRP.Tail.Overlay.Thread gs寄存器基址+18h处的值放进内存[rbx+98h]</span><br><span class="line">mov byte ptr [rbx+40h], 0 ; IRP.RequestorMode 把[rbx+40h]处的一个字节填为0</span><br><span class="line">call cs:KeInitializeEvent ; 调用 KeInitializeEvent方法将一个事件对象初始化为一个同步或通知类型的事件，并且设置为一个有信号或无信号的状态</span><br><span class="line">test bpl, bpl ; and bpl bpl，根据结果设置标志位，不会保存结果。C与O会被设置为0.</span><br><span class="line">mov rcx, [rbx+0B8h] ; 将内存[rbx+0B8h]处的值放进rcx中</span><br><span class="line">mov byte ptr [rbx+40h], 6 ; IRP_MJ_SET_INFORMATION 把[rbx+40h]处的一个字节填为6</span><br><span class="line">mov [rcx-20h], rsi ; IO_STACK_LOCATION.DeviceObject 将rsi处的值放进内存[rcx-20h]中</span><br><span class="line">mov [rcx-18h], rdi ; IO_STACK_LOCATION.FileObject 将rdi处的值放进内存[rcx-18h]中</span><br><span class="line">jz short loc_4039A6 ; 如果Z标志位为1，就跳转到loc_4039A6中</span><br><span class="line">mov rax, [rdi+28h] ; FILE_OBJECT.SectionObjectPointer 将内存[rdi+28h]中的值放进rax中</span><br><span class="line">test rax, rax ; and rax rax，根据结果设置标志位，不会保存结果。C与O会被设置为0.</span><br><span class="line">jz short loc_4039A6 ; 如果Z标志位为1，就跳转到loc_4039A6中</span><br><span class="line">mov [rax+10h], 0 ; SECTION_OBJECT_POINTERS.ImageSectionObject 将[rax+10h]置为0</span><br><span class="line">loc_4039A6:</span><br><span class="line">mov [rcx-28h], r12 ; IO_STACK_LOCATION.Parameters.SetFile.DeleteHandle   将寄存器r12中的值放进[rcx-28h]中</span><br><span class="line">mov [rcx-30h], rdi ; IO_STACK_LOCATION.Parameters.SetFile.Object  将寄存器rdi中的值放进[rcx-30h]中</span><br><span class="line">mov dword ptr [rcx-38h], 0Dh ; FileDispositionInformation IO_STACK_LOCATION.Parameters.SetFile.FileInfomationClass 将[rcx-38h]处的双字设置为0Dh</span><br><span class="line">mov dword ptr [rcx-40h],1 ; IO_STACK_LOCATION.Parameters.SetFile.Length  将[rcx-40h]处的双字设置为1</span><br><span class="line">mov rax, [rbx+0b8h] ; CurrentIrpStackLocation 将[rbx+0b8h]处的值放进rax中</span><br><span class="line">lea rcx, sub_4038B4 ; completionroutine rcx获取sub_4038B4的地址</span><br><span class="line">mov [rax-10h], rcx ; IO_STACK_LOCATION.ComplerionRoutine 将rcx指向sub_4038B4的地址处的值放进[rax-10h]中</span><br><span class="line">mov rcx, rsi ; DeviceObject 将rsi处的值放进rcx中</span><br><span class="line">mov rdx, rbx ; Irp 将rbx处的值放进rdx中</span><br><span class="line">mov qword ptr [rax-8], 0 ; 将内存[rax-8]处的双字设置为0</span><br><span class="line">mov byte ptr [rax-45h], 0E0h ; flag 将内存[rax-45h]处的一个字节设置为0</span><br><span class="line">call cs:IofCallDriver ; 调用IofCallDriver方法</span><br><span class="line">cmp eax, 103h ; STATUS_PENDING 比较eax和103h</span><br><span class="line">jnz short loc_403A09 ; 如果eax和103h不相等就跳转到loc_403A09</span><br><span class="line">lea rcx, [rsp+88h+Event] ; Object rcx获取[rsp+88h+Event]的地址</span><br><span class="line">mov r9b, 1 ; Alertable 将r9b赋值为1</span><br><span class="line">xor r8d, r8d ; WaitMode r8d置为0</span><br><span class="line">xor edx, edx ; WaitReason edx置为0</span><br><span class="line">mov [rsp+88h+var_68], 0 ; 将[rsp+88h+var_68]置为0</span><br><span class="line">call cs:KeWaitForSingleObject ; 调用该方法将当前线程(ethread里以Wait开头的字段WaitIrql,WaitMode,WaitStatus)置为等待状态,直到提供的分发机器对象被置为已处理状态或第五个参数给出的Timeout走完。</span><br><span class="line">loc_403A09:</span><br><span class="line">mov eax, [rbx+30h] ; IRP.IoStatus.Status 将内存[rbx+30h]处的值赋给eax</span><br><span class="line">loc_403A0C: ; 清理栈</span><br><span class="line">add rsp, 60h ; 栈指针rsp+60h进行复位</span><br><span class="line">pop r12 ; 出栈r12</span><br><span class="line">pop rdi ; 出栈rdi</span><br><span class="line">pop rsi ; 出栈rsi</span><br><span class="line">pop rbp ; 出栈rbp</span><br><span class="line">pop rbx ; 出栈rbx</span><br><span class="line">retn</span><br><span class="line">sub_4038F0 endp</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何编写一个简单内核</title>
      <link href="2018/09/04/noteKernelProgram/"/>
      <url>2018/09/04/noteKernelProgram/</url>
      
        <content type="html"><![CDATA[<p>编写一个简单的内核，可以再 x86 系统上加载 GRUB 引导加载程序。此内核将在屏幕上显示一条信息，然后挂起。</p><span id="more"></span><h2 id="x86-机器是如何启动的"><a class="markdownIt-Anchor" href="#x86-机器是如何启动的"></a> x86 机器是如何启动的</h2><p>在我们考虑编写内核之前，让我们看看机器是如何启动并将控制转移到内核的。</p><p>上电后，<code>x86 CPU</code>的大多数寄存器都有明确定义的值。指令指针（<code>EIP</code>）寄存器保存处理器正在执行的指令的存储器地址。<code>EIP</code>硬编码为值<code>0xFFFFFFF0</code>，因此，<code>x86 CPU</code>硬连线开始在物理地址<code>0xFFFFFFF0</code>处执行。实际上，它是<code>32</code>位地址空间的最后<code>16</code>个字节。该存储器地址称为复位向量。</p><p>现在，芯片组的内存映射确保<code>0xFFFFFFF0</code>映射到<code>BIOS</code>的某个部分，而不是<code>RAM</code>。同时，<code>BIOS</code>将自身复制到<code>RAM</code>以便更快地访问，我们称之为<code>shadowing</code>。地址<code>0xFFFFFFF0</code>只包含一条跳转指令，指向<code>BIOS</code>复制自身的内存中的地址。</p><p>到这里，<code>BIOS</code>代码开始执行。<code>BIOS</code>首先按配置的引导设备顺序搜索可引导设备。它会检查某个幻数以确定设备是否可引导（第一扇区的字节 511 和 512 是否为<code>0xAA55</code>）。</p><p>一旦<code>BIOS</code>找到可引导设备，它就会从物理地址<code>0x7c00</code>开始将设备第一个扇区的内容复制到<code>RAM</code>中，然后跳转到地址并执行刚刚加载的代码，此代码称为引导加载程序。</p><p>然后，引导加载程序将内核加载到物理地址<code>0x100000</code>。地址<code>0x100000</code>用作<code>x86</code>计算机上所有大内核的起始地址。</p><p>所有<code>x86</code>处理器都以简单的<code>16</code>位模式开始，称为实模式。<code>GRUB</code>引导加载程序通过将<code>CR0</code>寄存器的最低位设置为<code>1</code>来切换到<code>32</code>位保护模式，因此，内核以<code>32</code>位保护模式加载。</p><p>请注意，在<code>Linux</code>内核的情况下，<code>GRUB</code>会检测<code>Linux</code>启动协议并以实模式加载<code>Linux</code>内核。<code>Linux</code>内核本身可以切换到保护模式。</p><h2 id="我们需要什么"><a class="markdownIt-Anchor" href="#我们需要什么"></a> 我们需要什么</h2><ul><li><p>一台 x86 电脑</p></li><li><p>Linux</p></li><li><p>NASM 汇编程序</p></li><li><p>gcc</p></li><li><p>ld（GNU 链接器）</p></li><li><p>grub</p></li></ul><h2 id="源代码"><a class="markdownIt-Anchor" href="#源代码"></a> 源代码</h2><p>源代码可以在 Github 存储库中找到<a href="https://github.com/arjun024/mkernel">mkernel</a></p><h2 id="使用程序集的入口点"><a class="markdownIt-Anchor" href="#使用程序集的入口点"></a> 使用程序集的入口点</h2><p>我们喜欢用 C 语言编写所有内容，但我们无法避免一些组装。我们将用<code>x86</code>汇编语言编写一个小文件，以此来作为我们内核的起点。我们所有的汇编文件都会调用一个外部函数，我们将用 C 编写，然后暂停程序流程。</p><p>我们如何确保此汇编代码将作为内核的起点呢？</p><p>我们将使用链接脚本来链接目标文件以生成最终的内核可执行文件（稍后将详细解释）。在此链接描述文件中，我们将明确指定我们希望将二进制文件加载到地址<code>0x100000</code>。正如我之前所说，这个地址是内核的预期。因此，引导加载程序将负责触发内核的入口点。</p><p>这是汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">;;kernel.asm</span><br><span class="line"></span><br><span class="line">bits 32                     ;nasm directive - 32 bit</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line"></span><br><span class="line">global start</span><br><span class="line"></span><br><span class="line">extern kmain                ;kmain is defined in the c file</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line"></span><br><span class="line">    cli ;block interrupts</span><br><span class="line"></span><br><span class="line">    mov esp, stack_space    ;set stack pointer</span><br><span class="line"></span><br><span class="line">    call kmain</span><br><span class="line"></span><br><span class="line">    hlt                     ;halt the CPU</span><br><span class="line"></span><br><span class="line">section .bss</span><br><span class="line"></span><br><span class="line">resb 8192                   ;8KB for stack</span><br><span class="line"></span><br><span class="line">stack_space:</span><br></pre></td></tr></table></figure><p>第一条指令<code>bits 32</code>不是<code>x86</code>汇编指令，它是<code>NASM</code>汇编程序的一个指令，它指定它应该生成代码，以在<code>32</code>位模式下运行的处理器上运行。在我们的例子中，它并不是强制性的，但是这里包含了它，因为它确实是一个良好实践。</p><p>第二行开始文本部分（又名代码部分），这是我们放置所有代码的地方。</p><p><code>global</code>是另一个将源代码中的符号设置为全局的<code>NASM</code>指令，通过这样做，链接器知道符号的<code>start</code>位置，这恰好是我们的切入点。</p><p><code>kmain</code>是我们的函数，将在我们的<code>kernel.c</code>文件中定义。<code>extern</code>声明该函数在其他地方声明。</p><p>然后，我们有了<code>start</code>函数，它调用<code>kmain</code>函数并使用<code>hlt</code>指令暂停<code>CPU</code>。中断可以从<code>hlt</code>指令中唤醒<code>CPU</code>，所以我们事先使用<code>cli</code>指令禁用中断。<code>cli</code>是明显中断的缩写。</p><p>理想情况下，我们应该为堆栈留出一些内存并将堆栈指针（<code>esp</code>）指向它。但是，似乎<code>GRUB</code>这样做就已经设置了堆栈指针。但是，为了以防万一，我们将在<code>BSS</code>部分中分配一些空间，并将堆栈指针指向分配的内存的开头。我们使用<code>resb</code>以字节为单位保留内存的指令，在它之后，留下一个标签，指向保留的内存块的边缘。在<code>kmain</code>调用之前，堆栈指针（<code>esp</code>）使用<code>mov</code>指令使指向该空间。</p><h2 id="c-中的内核"><a class="markdownIt-Anchor" href="#c-中的内核"></a> C 中的内核</h2><p>在<code>kernel.asm</code>，我们调用了该函数<code>kmain()</code>。所以我们的<code>C</code>代码将开始执行<code>kmain()</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  kernel.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmain</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *str = <span class="string">&quot;my first kernel&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *vidptr = (<span class="keyword">char</span>*)<span class="number">0xb8000</span>; <span class="comment">//video mem begins here.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* this loops clears the screen</span></span><br><span class="line"><span class="comment">     * there are 25 lines each of 80 columns; each element takes 2 bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt; <span class="number">80</span> * <span class="number">25</span> * <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* blank character */</span></span><br><span class="line"></span><br><span class="line">        vidptr[j] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* attribute-byte - light grey on black screen */</span></span><br><span class="line"></span><br><span class="line">        vidptr[j+<span class="number">1</span>] = <span class="number">0x07</span>;</span><br><span class="line"></span><br><span class="line">        j = j + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* this loop writes the string to video memory */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(str[j] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* the character&#x27;s ascii */</span></span><br><span class="line"></span><br><span class="line">        vidptr[i] = str[j];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* attribute-byte: give character black bg and light grey fg */</span></span><br><span class="line"></span><br><span class="line">        vidptr[i+<span class="number">1</span>] = <span class="number">0x07</span>;</span><br><span class="line"></span><br><span class="line">        ++j;</span><br><span class="line"></span><br><span class="line">        i = i + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们所有的内核都会清除屏幕并写入字符串“我的第一个内核”。</p><p>首先，我们创建一个指向<code>vidptr</code>地址<code>0xb8000</code>的指针，该地址是受保护模式下的视频内存的开始。屏幕的文本内存只是我们地址空间中的一块内存，屏幕的内存映射输入/输出从<code>0xb8000</code>开始，支持<code>25</code>行，每行包含<code>80</code>个<code>ASCII</code>字符。</p><p>该文本存储器中的每个字符元素由<code>16位</code>（<code>2字节</code>）表示，而不是我们习惯的<code>8位</code>（<code>1字节</code>）。第一个字节应该具有<code>ASCII</code>中的字符表示，第二个字节是<code>attribute-byte</code>。这描述了其特征属性，比如说颜色。</p><p>如果要<code>s</code>在黑色背景上打印绿色字符，我们只需要将字符<code>s</code>存储在视频存储器地址的第一个字节中，将值<code>0x02</code>存储在第二个字节中即可。<code>0</code>代表黑色背景，<code>2</code>代表绿色前景。</p><p>请查看下表中的不同颜色：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0 - Black,</span><br><span class="line">1 - Blue,</span><br><span class="line">2 - Green,</span><br><span class="line">3 - Cyan,</span><br><span class="line">4 - Red,</span><br><span class="line">5 - Magenta,</span><br><span class="line">6 - Brown,</span><br><span class="line">7 - Light Grey,</span><br><span class="line">8 - Dark Grey,</span><br><span class="line">9 - Light Blue,</span><br><span class="line">10/a - Light Green,</span><br><span class="line">11/b - Light Cyan,</span><br><span class="line">12/c - Light Red,</span><br><span class="line">13/d - Light Magenta,</span><br><span class="line">14/e - Light Brown,</span><br><span class="line">15/f – White.</span><br></pre></td></tr></table></figure><p>在我们的内核中，我们将在黑色背景上使用浅灰色字符，所以我们的属性字节必须具有值<code>0x07</code>。</p><p>在第一个<code>while</code>循环中，程序在 25 行的 80 列中写入具有<code>0x07</code>属性的空白字符，这样就可以清除屏幕。</p><p>在第二个<code>while</code>循环中，空终止字符串<code>“my first kernel”</code>的字符被写入视频内存块，每个字符保存一个<code>0x07</code>的属性字节。</p><p>这将会在屏幕上显示字符串。</p><h2 id="链接部分"><a class="markdownIt-Anchor" href="#链接部分"></a> 链接部分</h2><p>我们将<code>kernel.asm</code>与<code>NASM</code>组装成一个目标文件，然后使用<code>GCC</code>，将<code>kernel.c</code>编译成另一个目标文件。现在，我们的工作是将这些对象链接到可执行的可引导内核。</p><p>为此，我们使用显式链接脚本，它可以作为参数传递给<code>ld</code>（我们的链接器）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"></span><br><span class="line"> *  link.ld</span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">OUTPUT_FORMAT(elf32-i386)</span><br><span class="line"></span><br><span class="line">ENTRY(start)</span><br><span class="line"></span><br><span class="line">SECTIONS &#123;</span><br><span class="line"></span><br><span class="line">   . = 0x100000;</span><br><span class="line"></span><br><span class="line">   .text : &#123; *(.text) &#125;</span><br><span class="line"></span><br><span class="line">   .data : &#123; *(.data) &#125;</span><br><span class="line"></span><br><span class="line">   .bss  : &#123; *(.bss)  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们将输出可执行文件的输出格式设置为<code>32位</code>可执行文件和可链接格式（<code>ELF</code>）。ELF 是<code>x86</code>架构上类<code>Unix</code>系统的标准二进制文件格式。</p><p><code>ENTRY</code>有一个论点，它指定应该是我们的可执行文件的入口点的符号名称。</p><p><code>SECTIONS</code>是我们最重要的部分，在这里，我们定义可执行文件的布局。我们可以指定如何合并不同的部分以及每个部分的放置位置。</p><p>在<code>SECTIONS</code>语句后面的大括号内，句点字符（<code>.</code>）表示位置计数器。</p><p>在<code>SECTIONS</code>块的开头，位置计数器始终初始化为<code>0x0</code>，这可以通过为其分配新值来修改它。</p><p>记住前文中说过的，内核的代码应该从地址<code>0x100000</code>开始，所以我们将位置计数器设置为<code>0x100000</code>。</p><p>看看下一行<code>.text：&#123;*（.text）&#125;</code></p><p>星号（<code>*</code>）是一个匹配任何文件名的通配符，因此，表达式<code>*(.text)</code>表示<code>.text</code>来自所有输入文件的所有输入节。</p><p>因此，链接器将目标文件的所有文本部分，合并到位置计数器中存储地址的可执行文件部分，所以我们的可执行文件的代码部分从<code>0x100000</code>开始。</p><p>链接器放置文本输出节之后，位置计数器的值将变为<code>0x1000000 +</code>文本输出节的大小。</p><p>类似的，数据和<code>bss</code>部分被合并并放置在<code>location-counter</code>的<code>then</code>值处。</p><h2 id="grub-和-multiboot"><a class="markdownIt-Anchor" href="#grub-和-multiboot"></a> Grub 和 Multiboot</h2><p>现在，我们准备好构建内核的所有文件。但是，既然我们想用<code>GRUB</code>引导程序引导我们的内核，那么还有一步。</p><p>有一个使用引导加载程序加载各种<code>x86</code>内核的标准，称为<code>Multiboot spec</code>（多重引导规范）。</p><p>如果<code>GRUB</code>符合<code>Multiboot</code>规范，它将只加载我们的内核。</p><p>根据规范，内核必须在其前<code>8个千字节</code>内包含一个头，称为<code>Multiboot header</code>（多引导头）。</p><p>此外，此<code>Multiboot</code>标头必须包含<code>3个字节</code>，即 4 字节对齐，即：</p><ul><li><p>一个魔术字段（<code>magic field</code>）：包含幻数<code>0x1BADB002</code>，以识别头部。</p></li><li><p>一个标志字段（<code>flags field</code>）：我们不关心这个字段，只需将其设置为零。</p></li><li><p>一个校验字段（<code>checksum field</code>）：添加<code>“magic”</code>和<code>“flags”</code>的校验字段必须为零。</p></li></ul><p>所以我们的<code>kernel.asm</code>就会变成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">;;kernel.asm</span><br><span class="line"></span><br><span class="line">;nasm directive - 32 bit</span><br><span class="line"></span><br><span class="line">bits 32</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line"></span><br><span class="line">        ;multiboot spec</span><br><span class="line"></span><br><span class="line">        align 4</span><br><span class="line"></span><br><span class="line">        dd 0x1BADB002               ;magic</span><br><span class="line"></span><br><span class="line">        dd 0x00                     ;flags</span><br><span class="line"></span><br><span class="line">        dd - (0x1BADB002 + 0x00)    ;checksum. m+f+c should be zero</span><br><span class="line"></span><br><span class="line">global start</span><br><span class="line"></span><br><span class="line">extern kmain                        ;kmain is defined in the c file</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line"></span><br><span class="line">  cli ;block interrupts</span><br><span class="line"></span><br><span class="line">  mov esp, stack_space              ;set stack pointer</span><br><span class="line"></span><br><span class="line">  call kmain</span><br><span class="line"></span><br><span class="line">  hlt ;halt the CPU</span><br><span class="line"></span><br><span class="line">section .bss</span><br><span class="line"></span><br><span class="line">resb 8192                           ;8KB for stack</span><br><span class="line"></span><br><span class="line">stack_space:</span><br></pre></td></tr></table></figure><p><code>DD</code>定义大小为 4 个字节的双字。</p><h2 id="构建内核"><a class="markdownIt-Anchor" href="#构建内核"></a> 构建内核</h2><p>现在，我们将创建从目标文件<code>kernel.asm</code>和<code>kernel.c</code>，然后使用我们的链接脚本链接。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nasm -f elf32 kernel.asm -o kasm.o</span><br></pre></td></tr></table></figure><p>将运行汇编程序以<code>ELF-32位</code>格式创建目标文件<code>kasm.o</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 -c kernel.c -o kc.o</span><br></pre></td></tr></table></figure><p><code>'-c'</code>选项确保在编译之后，链接不会隐式发生。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld -m elf_i386 -T link.ld -o kernel kasm.o kc.o</span><br></pre></td></tr></table></figure><p>将使用我们的链接描述文件运行链接器并生成名为<code>kernel</code>的可执行文件。</p><h2 id="配置你的-grub-并运行你的内核"><a class="markdownIt-Anchor" href="#配置你的-grub-并运行你的内核"></a> 配置你的 grub 并运行你的内核</h2><p><code>GRUB</code>要求您的内核具有名称模式<code>kernel-&lt;version&gt;</code>，所以，我们需要重命名内核。我将内核可执行文件重命名为<code>kernel-701</code>。</p><p>现在将它放在<code>/ boot</code>目录中。（需要超级用户权限才能执行此操作。）</p><p>在<code>GRUB</code>配置文件中，<code>grub.cfg</code>应该添加一个条目，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">title myKernelroot (hd0,0)kernel /boot/kernel-701 ro</span><br></pre></td></tr></table></figure><p>不要忘记删除指令<code>hiddenmenu</code>（如果存在的话）。</p><p>重新启动计算机，你将获得列出内核名称的列表选择。</p><p>那就是你的内核!!</p><h2 id="ps"><a class="markdownIt-Anchor" href="#ps"></a> PS</h2><ul><li><p>始终建议给自己设置一个虚拟机，用于各种内核黑客攻击。</p></li><li><p>要在<code>grub2</code> 上运行它，这是新发行版的默认引导加载程序，你的配置应如下所示：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">menuentry &#x27;kernel 701&#x27; &#123;set root=&#x27;hd0,msdos1&#x27;multiboot /boot/kernel-701 ro&#125;</span><br></pre></td></tr></table></figure><ul><li>此外，如果您想在 qemu 模拟器上运行内核而不是使用 GRUB 启动内核，你可以通过以下方式执行此操作：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-i386 -kernel kernel</span><br></pre></td></tr></table></figure><h2 id="参考和感谢"><a class="markdownIt-Anchor" href="#参考和感谢"></a> 参考和感谢</h2><ol><li><p><a href="https://github.com/arjun024/mkernel">arjun024 的源码及思路</a></p></li><li><p><a href="http://wiki.osdev.org">wiki.osdev.org</a></p></li><li><p><a href="http://osdever.net">osdever.net</a></p></li><li><p>Multiboot spec</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Mac生产力工具</title>
      <link href="2018/03/31/tipsMac/"/>
      <url>2018/03/31/tipsMac/</url>
      
        <content type="html"><![CDATA[<p>Mac 机写代码除了逼格高一点，生产力是真的显著提高～</p><p>以下简单介绍一些在 Mac 上提高生产力的小技巧。</p><span id="more"></span><p>以 PHP 开发环境为例，干净的 Mac 系统（重装系统后未作任何配置）</p><h2 id="安装命令行终端"><a class="markdownIt-Anchor" href="#安装命令行终端"></a> 安装命令行终端</h2><p>这里我们选择<code>iTerm2</code>，<code>iTerm2</code>功能强大，可以替代系统默认的命令行终端。下载解压后，将<code>iTerm2</code>直接拖入&quot;应用程序&quot;目录。</p><h2 id="安装-xcode"><a class="markdownIt-Anchor" href="#安装-xcode"></a> 安装 Xcode</h2><p><code>Xcode</code>是苹果出品的包含一系列工具及库的开发套件。<br />通过 <code>App Store</code> 安装最新版本的 <code>Xcode</code>。我们一般不会用 <code>Xcode</code> 来开发 PHP 项目。但这一步也是必需的，因为 <code>Xcode</code> 会帮你附带安装一些如 <code>Git</code> 等必要的软件。当然你也可以通过源码包安装 <code>Git</code>。</p><h2 id="安装-xcode-command-line-tools"><a class="markdownIt-Anchor" href="#安装-xcode-command-line-tools"></a> 安装 Xcode Command Line Tools</h2><p>这一步会帮你安装许多常见的基于 <code>Unix</code> 的工具。<code>Xcode</code> 命令行工具作为 <code>Xcode</code> 的一部分，包含了 <code>GCC</code> 编译器。在命令行中执行以下命令即可安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure><h2 id="安装包管理器"><a class="markdownIt-Anchor" href="#安装包管理器"></a> 安装包管理器</h2><p><code>Homebrew</code> 作为 <code>macOS</code> 不可或缺的套件管理器，用来安装、升级以及卸载常用的软件。在命令行中执行以下命令即可安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>安装后可以修改 <code>Homebrew</code> 源，国外源一直不是很给力，这里我们将 <code>Homebrew</code> 的 <code>git</code> 远程仓库改为中国科学技术大学开源软件镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(brew --repo)</span>&quot;</span></span><br><span class="line">git remote set-url origin git://mirrors.ustc.edu.cn/brew.git</span><br></pre></td></tr></table></figure><h2 id="安装-http-服务器"><a class="markdownIt-Anchor" href="#安装-http-服务器"></a> 安装 HTTP 服务器</h2><p>这里我们选择 <code>nginx</code> 代替系统自带的 <code>Apache</code>，作为我们的 <code>HTTP</code> 服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install nginx</span><br></pre></td></tr></table></figure><p>安装完成后，<code>nginx</code> 的一些常用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo nginx <span class="comment"># 启动 nginx 服务</span></span><br><span class="line">nginx -h <span class="comment"># nginx 帮助信息</span></span><br><span class="line">sudo nginx -s stop|quit|reopen|reload <span class="comment"># 停止|退出|重启|重载 nginx 服务</span></span><br></pre></td></tr></table></figure><h2 id="安装数据库"><a class="markdownIt-Anchor" href="#安装数据库"></a> 安装数据库</h2><p>这里我们选择 <code>MySQL</code> 作为我们的数据库服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install mysql</span><br></pre></td></tr></table></figure><p>当然，你也可以选择安装 <code>PostgreSQL</code> 或者 <code>MariaDB</code>。</p><p>安装完成后，启动 <code>MySQL</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld</span><br></pre></td></tr></table></figure><p>如果不执行上述操作，直接通过命令行进入 <code>MySQL</code>，一般会报一个这样的错误。<br />ERROR 2002 (HY000): Can’t connect to local MySQL server through socket ‘/tmp/mysql.sock’</p><h3 id="进入-mysql-服务器"><a class="markdownIt-Anchor" href="#进入-mysql-服务器"></a> 进入 MySQL 服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><h2 id="开启-php-fpm"><a class="markdownIt-Anchor" href="#开启-php-fpm"></a> 开启 PHP-FPM</h2><p><code>nginx</code> 本身不能处理 <code>PHP</code>，它只是个 <code>HTTP</code> 服务器，当接收一个 <code>PHP</code> 请求后，<code>nginx</code> 会将其交由 <code>PHP</code> 解释器处理，并把结果返回给客户端。<code>nginx</code> 一般是把请求发 <code>FastCGI</code> 管理进程处理，<code>FastCGI</code> 管理进程选择 <code>CGI</code> 子进程处理结果并返回被 <code>nginx</code>。</p><p><code>PHP-FPM</code>是一个 <code>PHP FastCGI</code> 管理器，一开始只是 <code>PHP</code> 源代码的一个补丁，旨在将 <code>FastCGI</code> 进程管理整合进 <code>PHP</code>包中。必须将它 <code>patch</code> 到 <code>PHP</code> 源代码中，在编译安装 <code>PHP</code>后才可以使用。<code>PHP</code> 从版本 <code>5.3</code> 开始官方集成<code>PHP-FPM</code>。</p><h2 id="添加-php-fpm-的配置文件"><a class="markdownIt-Anchor" href="#添加-php-fpm-的配置文件"></a> 添加 PHP-FPM 的配置文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp /private/etc/php-fpm.conf.default /private/etc/php-fpm.conf</span><br><span class="line">php-fpm --fpm-config /private/etc/php-fpm.conf</span><br></pre></td></tr></table></figure><h2 id="修改-php-fpm-的-error_log-路径"><a class="markdownIt-Anchor" href="#修改-php-fpm-的-error_log-路径"></a> 修改 PHP-FPM 的 error_log 路径</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi /var/<span class="built_in">log</span>/php-fpm.log <span class="comment"># 新建文件</span></span><br><span class="line">vi /private/etc/php-fpm.conf <span class="comment"># 将 error_log=log/php-fpm.log 修改为：error_log = /var/log/php-fpm.log，保存</span></span><br></pre></td></tr></table></figure><h2 id="启动-php-fpm"><a class="markdownIt-Anchor" href="#启动-php-fpm"></a> 启动 PHP-FPM</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo php-fpm</span><br></pre></td></tr></table></figure><h2 id="关闭-php-fpm"><a class="markdownIt-Anchor" href="#关闭-php-fpm"></a> 关闭 PHP-FPM</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps aux|grep php-fpm</span><br><span class="line">sudo <span class="built_in">kill</span> php-fpm min pid <span class="comment"># 杀死 php-fpm 最小的进程id</span></span><br></pre></td></tr></table></figure><p>配置 <code>nginx.conf</code> 文件<br />通过以下命令可以查看<code>nginx.conf</code>文件的位置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -h</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">nginx version: nginx/1.10.1</span><br><span class="line">Usage: nginx [-?hvVtTq] [-s signal] [-c filename] [-p prefix] [-g directives]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -?,-h         : this <span class="built_in">help</span></span><br><span class="line">  -v            : show version and <span class="built_in">exit</span></span><br><span class="line">  -V            : show version and configure options <span class="keyword">then</span> <span class="built_in">exit</span></span><br><span class="line">  -t            : <span class="built_in">test</span> configuration and <span class="built_in">exit</span></span><br><span class="line">  -T            : <span class="built_in">test</span> configuration, dump it and <span class="built_in">exit</span></span><br><span class="line">  -q            : suppress non-error messages during configuration testing</span><br><span class="line">  -s signal     : send signal to a master process: stop, quit, reopen, reload</span><br><span class="line">  -p prefix     : <span class="built_in">set</span> prefix path (default: /usr/<span class="built_in">local</span>/Cellar/nginx/1.10.1/)</span><br><span class="line">  -c filename   : <span class="built_in">set</span> configuration file (default: /usr/<span class="built_in">local</span>/etc/nginx/nginx.conf)</span><br><span class="line">  -g directives : <span class="built_in">set</span> global directives out of configuration file</span><br></pre></td></tr></table></figure><p>打开配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/<span class="built_in">local</span>/etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><p>在文件末尾可以看到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include servers/*;</span><br></pre></td></tr></table></figure><p>它将同目录下的<code>servers</code>目录里的文件都包含了进来，由此，我们可以在<code>servers</code>文件里创建开发项目的配置信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> servers/</span><br><span class="line">vi test.conf</span><br></pre></td></tr></table></figure><p>将以下配置信息，写入 <code>test.conf</code>文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       8099;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    root /home/www/php_project;</span><br><span class="line">    rewrite . /index.php;</span><br><span class="line">    location / &#123;</span><br><span class="line">        index index.php index.html index.htm;</span><br><span class="line">        autoindex on;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #proxy the php scripts to php-fpm</span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        include /usr/local/etc/nginx/fastcgi.conf;</span><br><span class="line">        fastcgi_intercept_errors on;</span><br><span class="line">        fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述的<code>/home/www/php_project</code>的目录下，我们创建一个 <code>index.php</code>文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/www/php_project</span><br><span class="line">vi test.php</span><br></pre></td></tr></table></figure><p>写入内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;? php</span><br><span class="line">phpinfo();</span><br></pre></td></tr></table></figure><h2 id="重启-nginx"><a class="markdownIt-Anchor" href="#重启-nginx"></a> 重启 nginx</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo nginx -s stop</span><br><span class="line">sudo nginx</span><br></pre></td></tr></table></figure><p>打开浏览器，访问<code>localhost:8099</code>。可以看到关于 <code>PHP</code> 配置的信息。</p><p>至此，<code>MNMP(MacOS-nginx-MySQL-PHP)</code>环境已经搭建完成。</p><h2 id="安装-php-扩展"><a class="markdownIt-Anchor" href="#安装-php-扩展"></a> 安装 PHP 扩展</h2><p>环境搭建完成后，你可能还需要安装一些 PHP 扩展，如 <code>MemCache</code>、<code>Redis</code>、<code>Mongo</code>、<code>Solr</code>等。</p><p>在安装<code>PHP</code>扩展之前，你需要完成一些必要的操作。</p><h2 id="关闭-sip"><a class="markdownIt-Anchor" href="#关闭-sip"></a> 关闭 SIP</h2><p>这是安装 <code>PHP</code> 扩展前的必要操作。如果跳过这一操作，即使你用 <code>sudo</code> 命令安装扩展，依旧会报 <code>Operation not permitted</code> 的错误。这是因为 <code>OSX 10.11 El Capitan</code>（或更高）新添加了一个新的安全机制叫系统完整性保护 <code>System Integrity Protection (SIP)</code>，所以对于以下目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/System</span><br><span class="line">/sbin</span><br><span class="line">/usr 不包含(/usr/<span class="built_in">local</span>/)</span><br></pre></td></tr></table></figure><p>仅仅供系统使用，其它用户或者程序无法直接使用，而我们的 <code>/usr/lib/php/extensions/</code> 则刚好在受保护范围内（误伤世界上最好的语言）。</p><p>所以解决方法就是禁掉 <code>SIP</code> 保护机制，步骤是：</p><p>重启系统<br />按住 <code>Command + R</code>（重新亮屏之后就开始按，象征地按几秒再松开，直到出现苹果标志性的 <code>Logo</code>）<br />菜单“实用工具” ==&gt;&gt; “终端” ==&gt;&gt; 输入：<code>csrutil disable</code>。执行后会输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Successfully disabled System Integrity Protection. Please restart the machine <span class="keyword">for</span> the changes to take effect</span><br></pre></td></tr></table></figure><p>重启系统<br />当然，<code>PHP</code> 扩展安装完成后，就可以重新打开 <code>SIP</code>，方法同上，命令改为：<code>csrutil enable</code>。</p><p>安装一些必要的依赖包<br />安装 <code>autoconf</code>，<code>PHP</code>动态编译 <code>phpize</code> 时需要：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install autoconf</span><br></pre></td></tr></table></figure><p>安装 <code>openssl</code>，安装某些 <code>php</code> 扩展如 <code>mongo</code> 时需要。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install openssl</span><br></pre></td></tr></table></figure><p><code>mongo</code> 扩展安装是可能会报 <code>openssl</code> 错误，解决方法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/<span class="built_in">local</span>/Cellar/openssl/1.0.2j/include/openssl /usr/include/openssl</span><br></pre></td></tr></table></figure><h3 id="正式安装扩展"><a class="markdownIt-Anchor" href="#正式安装扩展"></a> 正式安装扩展</h3><p>这里有两种方法安装 <code>php</code> 扩展：</p><p>通过 <code>pecl</code> 管理工具安装<br />通过源码包安装<br />通过 <code>pecl</code> 管理工具安装</p><h3 id="首先安装-pecl"><a class="markdownIt-Anchor" href="#首先安装-pecl"></a> 首先安装 pecl</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/lib/php</span><br><span class="line">sudo php install-pear-nozlib.phar</span><br></pre></td></tr></table></figure><p><code>pecl</code> 一般就会安装成功，如果失败，换另一种方式安装 <code>pecl</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -O http://pear.php.net/go-pear.phar</span><br><span class="line">sudo php -d detect_unicode=0 go-pear.phar</span><br><span class="line">输入 1，回车，输入/usr/<span class="built_in">local</span>/pear</span><br><span class="line">输入 4，回车，输入/usr/<span class="built_in">local</span>/bin</span><br><span class="line">回车</span><br></pre></td></tr></table></figure><p>安装好<code>pecl</code> 之后，我们就可以愉快地安装 <code>PHP</code> 扩展了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo pecl install solr</span><br><span class="line">sudo pecl install memcache</span><br><span class="line">sudo pecl install mongodb</span><br></pre></td></tr></table></figure><p>通过源码包安装<br />除了通过 <code>pecl</code> 安装，我们还可以通过下载源码包来进行安装扩展：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget http://pecl.php.net/get/redis-2.2.8.tgz</span><br><span class="line">tar -zxvf redis-2.2.8.tgz</span><br><span class="line"><span class="built_in">cd</span> redis-2.2.8</span><br><span class="line">phpize</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>扩展安装完成后，我们还需最后一步，修改<code>php.ini</code>文件，并重启 <code>PHP-FPM</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /private/etc/</span><br><span class="line">cp php.ini.default php.ini</span><br><span class="line">vi php.ini</span><br></pre></td></tr></table></figure><p>追加扩展信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extension=memcache.so</span><br><span class="line">extension=mongo.so</span><br><span class="line">extension=redis.so</span><br><span class="line">extension=solr.so</span><br></pre></td></tr></table></figure><p>重启 <code>PHP-FPM</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps aux|grep php-fpm</span><br><span class="line">sudo <span class="built_in">kill</span> php-fpm min pid <span class="comment"># 杀死 php-fpm 最小的进程id</span></span><br><span class="line">sudo php-fpm</span><br></pre></td></tr></table></figure><p>打开浏览器，访问<code>localhost:8099</code>。查看扩展是否安装成功。</p>]]></content>
      
      
      <categories>
          
          <category> tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu搭建渗透测试环境</title>
      <link href="2017/02/16/tipsLinuxBaseConfig/"/>
      <url>2017/02/16/tipsLinuxBaseConfig/</url>
      
        <content type="html"><![CDATA[<h2 id="常用工具"><a class="markdownIt-Anchor" href="#常用工具"></a> 常用工具</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install vim git gedit wget curl vlc whois meld deepin-screenshot qbittorrent transmission fonts-wqy-microhei mtr unrar unrar-free ascii unicode filezilla unrar unace rar unrar p7zip zip unzip p7zip-full p7zip-rar file-roller -y</span><br></pre></td></tr></table></figure><ul><li><p>编辑器<br />vim gedit vscode</p></li><li><p>下载工具</p><p>wget curl uget</p></li><li><p>截图工具</p><p>deepin-screenshot flameshot</p></li><li><p>中文字体</p><p>fonts-wqy-microhei</p></li><li><p>压缩工具</p><p>unrar unrar-free p7zip zip unzip p7zip-full p7zip-rar</p></li><li><p>ASCII 编码和 UNICODE 编码</p><p>ascii unicode</p></li><li><p>whois 查询工具<br />whois</p></li><li><p>文件比较工具</p><p>meld</p></li><li><p>BT 下载工具</p><p>qbittorrent transmission</p></li><li><p>mtr</p></li><li><p>Office 软件</p><p>wps for linux / only office</p></li><li><p>系统清理工具（Stacer）</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install stacer</span><br></pre></td></tr></table></figure><ul><li><p>思维导图</p><p>mindmaster</p></li><li><p>即时通讯软件 telegram</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:atareao/telegram</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install telegram</span><br></pre></td></tr></table></figure><ul><li>邮件工具：thunderbird</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install thunderbird</span><br></pre></td></tr></table></figure><ul><li>JAVA：Oracle-Java-11（下载后解压）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 创建文件夹并拷贝</span><br><span class="line">sudo mkdir -p /usr/local/java</span><br><span class="line">sudo cp -r jdk-11.0.7/ /usr/local/java/</span><br><span class="line"># 接下来配置JDK的环境变量</span><br><span class="line">sudo gedit /etc/profile</span><br><span class="line"># 复制以下内容追加到文件末尾</span><br><span class="line">JAVA_HOME=/usr/local/java/jdk-11.0.7</span><br><span class="line">PATH=$PATH:$HOME/bin:$JAVA_HOME/bin</span><br><span class="line">export JAVA_HOME</span><br><span class="line">export PATH</span><br><span class="line"># 告诉系统JDK的位置，最后2行代码不是重复，是要执行2次</span><br><span class="line">sudo update-alternatives --install &quot;/usr/bin/java&quot; &quot;java&quot; &quot;/usr/local/java/jdk-11.0.7/bin/java&quot; 1</span><br><span class="line">sudo update-alternatives --install &quot;/usr/bin/javac&quot; &quot;javac&quot; &quot;/usr/local/java/jdk-11.0.7/bin/javac&quot; 1</span><br><span class="line">sudo update-alternatives --install &quot;/usr/bin/javaws&quot; &quot;javaws&quot; &quot;/usr/local/java/jdk-11.0.7/bin/javaws&quot; 1</span><br><span class="line">sudo update-alternatives --install &quot;/usr/bin/javaws&quot; &quot;javaws&quot; &quot;/usr/local/java/jdk-11.0.7/bin/javaws&quot; 1</span><br><span class="line"># 设置新的JDK为默认,代码也是执行2次</span><br><span class="line">sudo update-alternatives --set java /usr/local/java/jdk-11.0.7/bin/java</span><br><span class="line">sudo update-alternatives --set javac /usr/local/java/jdk-11.0.7/bin/javac</span><br><span class="line"># 重载Profile文件</span><br><span class="line">source /etc/profile</span><br><span class="line"># 输入命令查看Java版本号</span><br><span class="line">java -version</span><br><span class="line"># 至此就应该安装成功了</span><br></pre></td></tr></table></figure><ul><li>中文输入法：ibus</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ibus ibus-pinyin ibus-sunpinyin ibus-rime</span><br><span class="line">im-config</span><br><span class="line">reboot</span><br><span class="line">添加智能拼音输入法</span><br><span class="line">ibus-setup  #取消embed勾选项</span><br></pre></td></tr></table></figure><ul><li>编辑器 sublime text3（用来写 python 还不错）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget -qO - https://download.sublimetext.com/sublimehq-pub.gpg | sudo apt-key add -</span><br><span class="line">echo &quot;deb https://download.sublimetext.com/ apt/stable/&quot; | sudo tee /etc/apt/sources.list.d/sublime-text.list</span><br><span class="line">sudo apt update &amp;&amp; sudo apt install sublime-text</span><br><span class="line">要删除编辑器，请运行命令：sudo apt remove --autoremove sublime-text</span><br></pre></td></tr></table></figure><ul><li>虚拟机</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VMware Workstation / VirtualBox</span><br></pre></td></tr></table></figure><ul><li>安装 docker</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg-agent \</span><br><span class="line">    software-properties-common</span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line">sudo apt-key fingerprint 0EBFCD88</span><br><span class="line">sudo add-apt-repository \</span><br><span class="line">   &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span><br><span class="line">   $(lsb_release -cs) \</span><br><span class="line">   stable&quot;</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose</span><br><span class="line">sudo docker run hello-world        #veriy</span><br><span class="line">docker -v    #查看docker-ce版本</span><br><span class="line">sudo usermod -aG docker $&#123;USER&#125;        #将user加入docker组</span><br><span class="line">su - $&#123;USER&#125;    #应用新的组成员身份，系统将提示您输入用户密码以继续</span><br><span class="line">sudo systemctl enable docker    #设置docker开机自启动</span><br><span class="line"></span><br><span class="line">docker镜像加速（我用的阿里云的镜像加速）</span><br><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://hecn3mxv.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line">sudo systemctl enable docker</span><br></pre></td></tr></table></figure><ul><li>Gnome 扩展</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gnome-tweaks chrome-gnome-shell</span><br></pre></td></tr></table></figure><ul><li>CPU 微码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install intel-microcode    #适用于Intel的CPU</span><br><span class="line">sudo apt install amd64-microcode    #适用于AMD的CPU</span><br></pre></td></tr></table></figure><ul><li>优化笔记本电池寿命（使用 tlp 自动优化）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install tlp tlp-rdw</span><br></pre></td></tr></table></figure><ul><li>Firejail 沙箱</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install firejail</span><br></pre></td></tr></table></figure><ul><li>Chrome 浏览器</li></ul><h2 id="渗透测试工具"><a class="markdownIt-Anchor" href="#渗透测试工具"></a> 渗透测试工具</h2><h3 id="添加-kali-源和数字签名"><a class="markdownIt-Anchor" href="#添加-kali-源和数字签名"></a> 添加 kali 源和数字签名</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#添加kali源，将下面两行写入该文件</span><br><span class="line">sudo vim /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line">deb http://mirrors.cloud.tencent.com/kali/ kali-rolling main contrib non-free</span><br><span class="line">deb-src http://mirrors.cloud.tencent.com/kali/ kali-rolling main contrib non-free</span><br><span class="line"></span><br><span class="line">#添加数字签名</span><br><span class="line">wget -q -O - https://archive.kali.org/archive-key.asc | apt-key add</span><br></pre></td></tr></table></figure><h3 id="安装-metasploit-framework"><a class="markdownIt-Anchor" href="#安装-metasploit-framework"></a> 安装 metasploit-framework</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 直接安装msf就可以了</span><br><span class="line">sudo apt update &amp;&amp; sudo apt install metaspliot-framework</span><br><span class="line"></span><br><span class="line"># 更新msf</span><br><span class="line">sudo apt update; sudo apt install metasploit-framework</span><br></pre></td></tr></table></figure><h3 id="searchsploit"><a class="markdownIt-Anchor" href="#searchsploit"></a> searchsploit</h3><p>这是一个 Exploit-DB 的命令行搜索工具，它还允许您随身携带漏洞利用数据库的副本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 安装漏洞利用数据库</span><br><span class="line">sudo apt update &amp;&amp; sudo apt -y install exploitdb</span><br><span class="line"></span><br><span class="line"># 更新数据库</span><br><span class="line">searchsploit -u</span><br></pre></td></tr></table></figure><h3 id="nmap-sqlmap"><a class="markdownIt-Anchor" href="#nmap-sqlmap"></a> nmap、sqlmap</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install nmap sqlmap</span><br></pre></td></tr></table></figure><h3 id="安装-wireshark"><a class="markdownIt-Anchor" href="#安装-wireshark"></a> 安装 wireshark</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install wireshark</span><br><span class="line"># 安装时，系统将询问你是否允许非超级用户捕获数据包。选择“Yes”允许，选择“No”限制非超级用户捕获数据包，最后完成安装</span><br><span class="line"># 如果在上一次安装中选择了“No”，则以 root 用户身份运行以下命令：sudo dpkg-reconfigure wireshark-common</span><br><span class="line"></span><br><span class="line">sudo usermod -aG wireshark $(whoami)    # 使用 usermod 命令将自己添加到 wireshark 组</span><br><span class="line">sudo groupadd wireshark    # 添加wireshark用户组</span><br><span class="line">sudo chgrp wireshark /usr/bin/dumpcap   # 将dumpcap更改为wireshark用户组</span><br><span class="line">sudo chmod 4755 /usr/bin/dumpcap    # 让wireshark用户组有root权限使用dumpcap</span><br><span class="line">sudo gpasswd -a simple wireshark   # 将所使用的用户名加入wireshark用户组，例如simple</span><br></pre></td></tr></table></figure><h3 id="安装-openvas"><a class="markdownIt-Anchor" href="#安装-openvas"></a> 安装 openvas</h3><p>OpenVAS 是一个可用于漏洞扫描和漏洞管理的开源套件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openvas</span><br><span class="line">sudo apt-get install sqlite3</span><br><span class="line">sudo openvas-nvt-sync</span><br><span class="line">sudo openvas-scapdata-sync</span><br><span class="line">sudo openvas-certdata-sync</span><br><span class="line"></span><br><span class="line">sudo service openvas-scanner restart</span><br><span class="line">sudo service openvas-manager restart</span><br><span class="line">sudo openvasmd --rebuild --progress</span><br></pre></td></tr></table></figure><h3 id="hash-破解工具"><a class="markdownIt-Anchor" href="#hash-破解工具"></a> hash 破解工具</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install hashid hachcat johnny</span><br></pre></td></tr></table></figure><h3 id="截断工具burpsuite"><a class="markdownIt-Anchor" href="#截断工具burpsuite"></a> 截断工具：burpsuite</h3><h3 id="msf-图形化界面kage"><a class="markdownIt-Anchor" href="#msf-图形化界面kage"></a> msf 图形化界面：kage</h3><p>这个工具虽然还不是很完善，但是做一些概念验证还是可以的！</p><h3 id="主机发现工具"><a class="markdownIt-Anchor" href="#主机发现工具"></a> 主机发现工具</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install arping netdiscover fping hping3</span><br></pre></td></tr></table></figure><h3 id="端口扫描工具"><a class="markdownIt-Anchor" href="#端口扫描工具"></a> 端口扫描工具</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install nmap masscan nast koncker</span><br></pre></td></tr></table></figure><h3 id="目录扫描工具"><a class="markdownIt-Anchor" href="#目录扫描工具"></a> 目录扫描工具</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># dirb</span><br><span class="line">sudo apt install dirb</span><br><span class="line"></span><br><span class="line"># Dirmap：一款高级Web目录文件扫描工具</span><br><span class="line">git clone https://github.com/H4ckForJob/dirmap.git &amp;&amp; cd dirmap &amp;&amp; python3 -m pip install -r requirement.txt</span><br><span class="line"></span><br><span class="line"># dirsearch</span><br><span class="line">git clone https://github.com/maurosoria/dirsearch</span><br><span class="line"></span><br><span class="line"># Webdirscan：webdirscan是一个很简单的多线程Web目录扫描工具，它是使用Python语言编写的，主要调用了requests第三方库实现</span><br><span class="line">git clone https://github.com/TuuuNya/webdirscan/</span><br></pre></td></tr></table></figure><h3 id="网站指纹识别"><a class="markdownIt-Anchor" href="#网站指纹识别"></a> 网站指纹识别</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install whatweb</span><br></pre></td></tr></table></figure><h3 id="web-扫描器"><a class="markdownIt-Anchor" href="#web-扫描器"></a> web 扫描器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、sudo apt install nikto shipfish zaproxy</span><br><span class="line">2、AWVS13 （用docker安装吧，方便一点）</span><br><span class="line">3、nessus</span><br><span class="line">4、nexpose</span><br></pre></td></tr></table></figure><h3 id="密码破解"><a class="markdownIt-Anchor" href="#密码破解"></a> 密码破解</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install hydra john</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux主机安全策略部署</title>
      <link href="2017/02/16/opsLinuxSec/"/>
      <url>2017/02/16/opsLinuxSec/</url>
      
        <content type="html"><![CDATA[<p>搭了测试机记得初始化配置策略。</p><h2 id="启用-authpriv-和-cron-系统日志审计"><a class="markdownIt-Anchor" href="#启用-authpriv-和-cron-系统日志审计"></a> 启用 authpriv 和 cron 系统日志审计</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">危险等级:中级</span><br><span class="line">类型：安全基线</span><br><span class="line">描述：启用authpriv和cron系统日志审计。 authpriv －包括特权信息如用户名在内的认证活动 cron －与 cron 和 at 有关的计划任务信息。</span><br><span class="line">参考链接：无</span><br><span class="line">操作步骤：</span><br><span class="line">    1. 修改/etc/rsyslog.conf，添加或取消注释如下配置（中间的分隔符是tab）：</span><br><span class="line">        authpriv.* /var/log/secure</span><br><span class="line">        cron.* /var/log/cron</span><br><span class="line">    2. 重启rsyslog服务</span><br></pre></td></tr></table></figure><h2 id="linux-帐户口令生存期策略"><a class="markdownIt-Anchor" href="#linux-帐户口令生存期策略"></a> Linux 帐户口令生存期策略</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">危险等级:中级</span><br><span class="line">类型：安全基线</span><br><span class="line">描述：口令老化（Password aging）是一种增强的系统口令生命期认证机制，能够确保用户的口令定期更换，提高系统安全性。</span><br><span class="line">参考链接：http://man7.org/linux/man-pages/man5/login.defs.5.html</span><br><span class="line">操作步骤：修改文件/etc/login.defs，配置PASS_MAX_DAYS 90</span><br></pre></td></tr></table></figure><h2 id="限制-root-权限用户远程登录"><a class="markdownIt-Anchor" href="#限制-root-权限用户远程登录"></a> 限制 root 权限用户远程登录</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">危险等级:中级</span><br><span class="line">类型：安全基线</span><br><span class="line">描述：限制root权限远程登录。先以普通权限用户远程登录后，再切换到超级管理员权限账号后执行相应操作，可以提升系统安全性。</span><br><span class="line">参考链接：无</span><br><span class="line">操作步骤：</span><br><span class="line">    1. 修改文件/etc/ssh/sshd_config配置</span><br><span class="line">        PermitRootLogin no</span><br><span class="line">    2. 重启sshd服务</span><br></pre></td></tr></table></figure><h2 id="linux-帐户超时自动登出配置"><a class="markdownIt-Anchor" href="#linux-帐户超时自动登出配置"></a> Linux 帐户超时自动登出配置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">危险等级:中级</span><br><span class="line">类型：安全基线</span><br><span class="line">描述：配置帐户超时自动登出，在用户输入空闲一段时间后自动断开。</span><br><span class="line">参考链接：无</span><br><span class="line">操作步骤：</span><br><span class="line">    修改/etc/profile文件，设置定时账户自动登出时间</span><br><span class="line">    export TMOUT=180</span><br></pre></td></tr></table></figure><h2 id="linux-未配置账户登录失败锁定策略"><a class="markdownIt-Anchor" href="#linux-未配置账户登录失败锁定策略"></a> Linux 未配置账户登录失败锁定策略</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">危险等级:中级</span><br><span class="line">类型：安全基线</span><br><span class="line">描述：设置账户登录失败锁定策略，加大用户口令被暴力破解的难度。</span><br><span class="line">参考链接：http://man7.org/linux/man-pages/man8/pam_tally2.8.html</span><br><span class="line">操作步骤：</span><br><span class="line">    设置连续输错5次口令，帐号锁定5分钟。</span><br><span class="line">    在进行此项安全加固工作前，请先检查PAM模块版本，搜索pam_tally2是否存在，如果pam_tally2存在，修改配置文件。【注意： 各系统配置不一，请根据当前系统进行适当配置，并仔细评估对系统的影响】</span><br><span class="line">    修复方案（仅供参考，请勿直接配置）：</span><br><span class="line">    centos</span><br><span class="line">        修改配置/etc/pam.d/password-auth（将配置添加到合适的位置）:</span><br><span class="line">        auth required pam_tally2.so deny=5 unlock_time=300 even_deny_root root_unlock_time=300</span><br><span class="line">        account required pam_tally2.so</span><br><span class="line"></span><br><span class="line">    ubuntu,debian：</span><br><span class="line">        修改配置/etc/pam.d/common-auth（将配置添加到合适的位置）:</span><br><span class="line">        auth required pam_tally2.so deny=5 unlock_time=300 even_deny_root root_unlock_time=300</span><br><span class="line">        修改配置/etc/pam.d/common-account参数（将配置添加到合适的位置）:</span><br><span class="line">        account required pam_tally2.so</span><br></pre></td></tr></table></figure><h2 id="删除系统特殊的的用户帐号"><a class="markdownIt-Anchor" href="#删除系统特殊的的用户帐号"></a> 删除系统特殊的的用户帐号</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">危险等级:中级</span><br><span class="line">类型：安全基线</span><br><span class="line">描述：禁止所有默认的被操作系统本身启动的且不需要的帐号，当你第一次装上系统时就应该做此检查，Linux提供了各种帐号，你可能不需要，如果你不需要这个帐号，就移走它，你有的帐号越多，就越容易受到攻击。</span><br><span class="line">参考链接：无</span><br><span class="line">操作步骤：</span><br><span class="line">    #为删除你系统上的用户，用下面的命令：</span><br><span class="line">    [root@c1gstudio]# userdel username</span><br><span class="line">    #批量删除方式</span><br><span class="line">    #这里删除&quot;adm lp sync shutdown halt mail news uucp operator games gopher ftp &quot;账号</span><br><span class="line">    #如果你开着ftp等服务可以把ftp账号保留下来。</span><br><span class="line">    for i in adm lp sync shutdown halt mail news uucp ope</span><br><span class="line">    rator games gopher ftp ;do userdel $i ;done</span><br></pre></td></tr></table></figure><h2 id="删除系统特殊的组帐号"><a class="markdownIt-Anchor" href="#删除系统特殊的组帐号"></a> 删除系统特殊的组帐号</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">危险等级:中级</span><br><span class="line">类型：安全基线</span><br><span class="line">描述：</span><br><span class="line">参考链接：无</span><br><span class="line">操作步骤：</span><br><span class="line">    [root@c1gstudio]# groupdel groupname</span><br><span class="line">    #批量删除方式</span><br><span class="line">    for i in adm lp mail news uucp games dip pppusers pop</span><br><span class="line">    users slipusers ;do groupdel $i ;done</span><br></pre></td></tr></table></figure><h2 id="用户密码设置"><a class="markdownIt-Anchor" href="#用户密码设置"></a> 用户密码设置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">危险等级:中级</span><br><span class="line">类型：安全基线</span><br><span class="line">描述：安装linux时默认的密码最小长度是5个字节，但这并不够，要把它设为8个字节。修改最短密码长度需要编辑login.defs文件#vi /etc/login.defs</span><br><span class="line">参考链接：无</span><br><span class="line">操作步骤：</span><br><span class="line">    PASS_MAX_DAYS  99999  ##密码设置最长有效期（默认值）</span><br><span class="line">    PASS_MIN_DAYS  0    ##密码设置最短有效期</span><br><span class="line">    PASS_MIN_LEN  5    ##设置密码最小长度，将5改为8</span><br><span class="line">    PASS_WARN_AGE  7    ##提前多少天警告用户密码即将过期。</span><br><span class="line">    然后修改Root密码</span><br><span class="line">    #passwd root</span><br><span class="line">    New UNIX password:</span><br><span class="line">    Retype new UNIX password:</span><br><span class="line">    passwd: all authentication tokens updated successfully.</span><br></pre></td></tr></table></figure><h2 id="修改自动注销帐号时间"><a class="markdownIt-Anchor" href="#修改自动注销帐号时间"></a> 修改自动注销帐号时间</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">危险等级:中级</span><br><span class="line">类型：安全基线</span><br><span class="line">描述：自动注销帐号的登录，在Linux系统中root账户是具有最高特权的。如果系统管理员在离开系统之前忘记注销root账户，那将会带来很大的安全隐患，应该让系统会自动注销。通过修改账户中“TMOUT”参数，可以实现此功能。TMOUT按秒计算。</span><br><span class="line">参考链接：无</span><br><span class="line">操作步骤：</span><br><span class="line">    编辑你的profile文件（vi /etc/profile）,在&quot;HISTSIZE=&quot;后面加入下面这行：</span><br><span class="line">    TMOUT=300</span><br><span class="line">    # 300，表示300秒，也就是表示5分钟。这样，如果系统中登陆的用户在5分钟内都没有动作，那么系统会自动注销这个账户。</span><br></pre></td></tr></table></figure><h2 id="限制-shell-命令记录大小"><a class="markdownIt-Anchor" href="#限制-shell-命令记录大小"></a> 限制 Shell 命令记录大小</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">危险等级:中级</span><br><span class="line">类型：安全基线</span><br><span class="line">描述：默认情况下，bash shell会在文件$HOME/.bash_history中存放多达500条命令记录(根据具体的系统不同，默认记录条数不同)。系统中每个用户的主目录下都有一个这样的文件。在此笔者强烈建议限制该文件的大小。</span><br><span class="line">参考链接：无</span><br><span class="line">操作步骤：</span><br><span class="line">    您可以编辑/etc/profile文件，修改其中的选项如下:</span><br><span class="line"></span><br><span class="line">    HISTFILESIZE=30或HISTSIZE=30</span><br><span class="line">    #vi /etc/profile</span><br><span class="line">    HISTSIZE=30</span><br></pre></td></tr></table></figure><h2 id="注销时删除命令记录"><a class="markdownIt-Anchor" href="#注销时删除命令记录"></a> 注销时删除命令记录</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">危险等级:中级</span><br><span class="line">类型：安全基线</span><br><span class="line">描述：</span><br><span class="line">参考链接：无</span><br><span class="line">操作步骤：</span><br><span class="line">    编辑/etc/skel/.bash_logout文件，增加如下行:</span><br><span class="line"></span><br><span class="line">    rm -f $HOME/.bash_history</span><br><span class="line">    这样，系统中的所有用户在注销时都会删除其命令记录。</span><br><span class="line">    如果只需要针对某个特定用户，如root用户进行设置，则可只在该用户的主目录下修改/$HOME/.bash_history文件，增加相同的一行即可。</span><br></pre></td></tr></table></figure><h2 id="用下面的命令加需要的用户组和用户帐号"><a class="markdownIt-Anchor" href="#用下面的命令加需要的用户组和用户帐号"></a> 用下面的命令加需要的用户组和用户帐号</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">危险等级:中级</span><br><span class="line">类型：安全基线</span><br><span class="line">描述：</span><br><span class="line">参考链接：无</span><br><span class="line">操作步骤：</span><br><span class="line">    [root@c1gstudio]# groupadd</span><br><span class="line">    例如：增加website 用户组，groupadd website</span><br><span class="line">    然后调用vigr命令查看已添加的用户组</span><br><span class="line">    用下面的命令加需要的用户帐号</span><br><span class="line">    [root@c1gstudio]# useradd username –g website //添加用户到website组（作为webserver的普通管理员，而非root管理员）</span><br><span class="line">    然后调用vipw命令查看已添加的用户</span><br><span class="line">    用下面的命令改变用户口令（至少输入8位字母和数字组合的密码，并将密码记录于本地机的专门文档中，以防遗忘）</span><br><span class="line">    [root@c1gstudio]# passwd username</span><br></pre></td></tr></table></figure><h2 id="阻止任何人-su-作为-root"><a class="markdownIt-Anchor" href="#阻止任何人-su-作为-root"></a> 阻止任何人 su 作为 root</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">危险等级:中级</span><br><span class="line">类型：安全基线</span><br><span class="line">描述：</span><br><span class="line">参考链接：无</span><br><span class="line">操作步骤：</span><br><span class="line">    如果你不想任何人能够su作为root,你能编辑/etc/pam.d/su加下面的行：</span><br><span class="line"></span><br><span class="line">    #vi /etc/pam.d/su</span><br><span class="line">    auth sufficient /lib/security/$ISA/pam_rootok.so debug</span><br><span class="line">    auth required /lib/security/$ISA/pam_wheel.so group=website</span><br><span class="line">    意味着仅仅website组的用户可以su作为root.</span><br></pre></td></tr></table></figure><h2 id="修改-ssh-服务的-root-登录权限"><a class="markdownIt-Anchor" href="#修改-ssh-服务的-root-登录权限"></a> 修改 ssh 服务的 root 登录权限</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">危险等级:中级</span><br><span class="line">类型：安全基线</span><br><span class="line">描述：</span><br><span class="line">参考链接：无</span><br><span class="line">操作步骤：</span><br><span class="line">    修改ssh服务配置文件，使的ssh服务不允许直接使用root用户来登录，这样减少系统被恶意登录攻击的机会。</span><br><span class="line"></span><br><span class="line">    #vi /etc/ssh/sshd_config</span><br><span class="line">    PermitRootLogin yes</span><br><span class="line">    将这行前的＃去掉后，修改为：</span><br><span class="line"></span><br><span class="line">    PermitRootLogin no</span><br></pre></td></tr></table></figure><h2 id="修改-ssh-服务的-sshd-端口"><a class="markdownIt-Anchor" href="#修改-ssh-服务的-sshd-端口"></a> 修改 ssh 服务的 sshd 端口</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">危险等级:中级</span><br><span class="line">类型：安全基线</span><br><span class="line">描述：ssh默认会监听在22端口，你可以修改至6022端口以避过常规的扫描。</span><br><span class="line">注意：修改端口错误可能会导致你下次连不到服务器，可以先同时开着22和6022两个端口，然后再关掉22端口；</span><br><span class="line">重启sshd不会弹掉你当前的连接，可以另外开一个客户端来测试服务;</span><br><span class="line">参考链接：无</span><br><span class="line">操作步骤：</span><br><span class="line">    #vi /etc/ssh/sshd_config</span><br><span class="line">    #增加修改</span><br><span class="line">    #Port 22 #关闭22端口</span><br><span class="line">    Port 6022 #增加6022端口</span><br><span class="line">    #重启sshd服务</span><br><span class="line">    service sshd restart</span><br><span class="line">    检查一下sshd的监听端口对不对</span><br><span class="line">    netstat -lnp|grep ssh</span><br><span class="line">    #iptables开放sshd的6022端口</span><br><span class="line">    vi /etc/sysconfig/iptables</span><br><span class="line">    #如果使用redhat默认规则则增加</span><br><span class="line">    -A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 6022 -j ACCEPT</span><br><span class="line">    #或</span><br><span class="line">    iptables -A INPUT -p tcp --dport 6022 -j ACCEPT</span><br><span class="line">    iptables -A OUTPUT -p udp --sport 6022 -j ACCEPT</span><br><span class="line">    重启iptables 服务</span><br><span class="line">    service iptables restart</span><br><span class="line">    #测试两个端口是否都能连上，连上后再将22端口删除</span><br></pre></td></tr></table></figure><h2 id="关闭系统不使用的服务"><a class="markdownIt-Anchor" href="#关闭系统不使用的服务"></a> 关闭系统不使用的服务：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">危险等级:中级</span><br><span class="line">类型：安全基线</span><br><span class="line">描述：</span><br><span class="line">参考链接：无</span><br><span class="line">操作步骤：</span><br><span class="line">    cd /etc/init.d # 进入到系统init进程启动目录</span><br><span class="line">    在这里有两个方法，可以关闭init目录下的服务。</span><br><span class="line">    一个是将init目录下的文件名mv成*.old类的文件名，即修改文件名，作用就是在系统启动的时候找不到这个服务的启动文件。</span><br><span class="line">    另一个是使用chkconfig系统命令来关闭系统启动等级的服务。</span><br><span class="line">    注：在使用以下任何一种方法时，请先检查需要关闭的服务是否是本服务器特别需要启动支持的服务，以防关闭正常使用的服务。</span><br><span class="line"></span><br><span class="line">    使用chkcofig命令来关闭不使用的系统服务 (level前面为2个减号)要想在修改启动脚本前了解有多少服务正在运行，输入：</span><br><span class="line">    ps aux | wc -l</span><br><span class="line"></span><br><span class="line">    然后修改启动脚本后，重启系统，再次输入上面的命令，就可计算出减少了多少项服务。越少服务在运行，安全性就越好。另外运行以下命令可以了解还有多少服务在运行：</span><br><span class="line">    netstat -na --ip</span><br><span class="line"></span><br><span class="line">    批量方式先停止服务</span><br><span class="line">    for i in acpid anacron apmd atd auditd autofs avahi-daemon avahi-dnsconfd bluetooth cpuspeed cups dhcpd firstboot gpm haldaemon hidd ip6tables ipsec isdn kudzu lpd mcstrans messagebus microcode_ctl netfs nfs nfslock nscd pcscd portmap readahead_early restorecond rpcgssd rpcidmapd rstatd sendmai</span><br><span class="line">    l setroubleshoot snmpd sysstat xfs xinetd yppasswdd ypserv yum-updatesd ;do service $i stop;done</span><br><span class="line"></span><br><span class="line">    关闭启动服务</span><br><span class="line">    for i in acpid anacron apmd atd auditd autofs avahi-daemon avahi-dnsconfd bluetooth cpuspeed cups dhcpd firstboot gpm haldaemon hidd ip6tables ipsec isdn kudzu lpd mcstrans messagebus microcode_ctl netfs nfs nfslock nscd pcscd portmap readahead_early restorecond rpcgssd rpcidmapd rstatd sendmai</span><br><span class="line">    l setroubleshoot snmpd sysstat xfs xinetd yppasswdd ypserv yum-updatesd ;do chkconfig $i off;done</span><br><span class="line"></span><br><span class="line">    以下为手动方式及解释,执行批量方式后不需再执行了</span><br><span class="line">    chkconfig --level 345 apmd off ##笔记本需要</span><br><span class="line">    chkconfig --level 345 netfs off ## nfs客户端</span><br><span class="line">    chkconfig --level 345 yppasswdd off ## NIS服务器，此服务漏洞很多</span><br><span class="line">    chkconfig --level 345 ypserv off ## NIS服务器，此服务漏洞很多</span><br><span class="line">    chkconfig --level 345 dhcpd off ## dhcp服务</span><br><span class="line">    chkconfig --level 345 portmap off ##运行rpc(111端口)服务必需</span><br><span class="line">    chkconfig --level 345 lpd off ##打印服务</span><br><span class="line">    chkconfig --level 345 nfs off ## NFS服务器，漏洞极多</span><br><span class="line">    chkconfig --level 345 sendmail off ##邮件服务, 漏洞极多</span><br><span class="line">    chkconfig --level 345 snmpd off ## SNMP，远程用户能从中获得许多系统信息</span><br><span class="line">    chkconfig --level 345 rstatd off ##避免运行r服务，远程用户可以从中获取很多信息</span><br><span class="line">    chkconfig --level 345 atd off ##和cron很相似的定时运行程序的服务</span><br><span class="line">    注：以上chkcofig 命令中的3和5是系统启动的类型，以下为数字代表意思</span><br><span class="line">    0:开机(请不要切换到此等级)</span><br><span class="line">    1:单人使用者模式的文字界面</span><br><span class="line">    2:多人使用者模式的文字界面,不具有网络档案系统(NFS)功能</span><br><span class="line">    3:多人使用者模式的文字界面,具有网络档案系统(NFS)功能</span><br><span class="line">    4:某些发行版的linux使用此等级进入x windows system</span><br><span class="line">    5:某些发行版的linux使用此等级进入x windows system</span><br><span class="line">    6:重新启动</span><br><span class="line"></span><br><span class="line">    如果不指定--level 单用on和off开关，系统默认只对运行级3，4，5有效</span><br><span class="line">    chkconfig cups off #打印机</span><br><span class="line">    chkconfig bluetooth off # 蓝牙</span><br><span class="line">    chkconfig hidd off # 蓝牙</span><br><span class="line">    chkconfig ip6tables off # ipv6</span><br><span class="line">    chkconfig ipsec off # vpn</span><br><span class="line">    chkconfig auditd off #用户空间监控程序</span><br><span class="line">    chkconfig autofs off #光盘软盘硬盘等自动加载服务</span><br><span class="line">    chkconfig avahi-daemon off #主要用于Zero Configuration Networking ，一般没什么用建议关闭</span><br><span class="line">    chkconfig avahi-dnsconfd off #主要用于Zero Configuration Networking ,同上,建议关闭</span><br><span class="line">    chkconfig cpuspeed off #动态调整CPU频率的进程，在服务器系统中这个进程建议关闭</span><br><span class="line">    chkconfig isdn off #isdn</span><br><span class="line">    chkconfig kudzu off #硬件自动监测服务</span><br><span class="line">    chkconfig nfslock off #NFS文档锁定功能。文档共享支持，无需的能够关了</span><br><span class="line">    chkconfig nscd off #负责密码和组的查询，在有NIS服务时需要</span><br><span class="line">    chkconfig pcscd off #智能卡支持，,如果没有可以关了</span><br><span class="line">    chkconfig yum-updatesd off #yum更新</span><br><span class="line">    chkconfig acpid off</span><br><span class="line">    chkconfig autofs off</span><br><span class="line">    chkconfig firstboot off</span><br><span class="line">    chkconfig mcstrans off #selinux</span><br><span class="line">    chkconfig microcode_ctl off</span><br><span class="line">    chkconfig rpcgssd off</span><br><span class="line">    chkconfig rpcidmapd off</span><br><span class="line">    chkconfig setroubleshoot off</span><br><span class="line">    chkconfig xfs off</span><br><span class="line">    chkconfig xinetd off</span><br><span class="line">    chkconfig messagebus off</span><br><span class="line">    chkconfig gpm off #鼠标</span><br><span class="line">    chkconfig restorecond off #selinux</span><br><span class="line">    chkconfig haldaemon off</span><br><span class="line">    chkconfig sysstat off</span><br><span class="line">    chkconfig readahead_early off</span><br><span class="line">    chkconfig anacron off</span><br><span class="line"></span><br><span class="line">    需要保留的服务</span><br><span class="line">    crond , irqbalance , microcode_ctl ,network , sshd ,syslog</span><br><span class="line">    因为有些服务已运行，所以设置完后需重启</span><br><span class="line">    chkconfig</span><br><span class="line">    /*</span><br><span class="line">        语法：chkconfig [--add][--del][--list][系统服务] 或 chkconfig [--level &lt;等级代号&gt;][系统服务][on/off/reset]</span><br><span class="line"></span><br><span class="line">        补充说明：这是Red Hat公司遵循GPL规则所开发的程序，它可查询操作系统在每一个执行等级中会执行哪些系统服务，其中包括各类常驻服务。</span><br><span class="line"></span><br><span class="line">        参数：</span><br><span class="line"></span><br><span class="line">        　--add 　增加所指定的系统服务，让chkconfig指令得以管理它，并同时在系统启动的叙述文件内增加相关数据。</span><br><span class="line">        　--del 　删除所指定的系统服务，不再由chkconfig指令管理，并同时在系统启动的叙述文件内删除相关数据。</span><br><span class="line">        　--level&lt;等级代号&gt; 　指定读系统服务要在哪一个执行等级中开启或关毕</span><br><span class="line">    */</span><br></pre></td></tr></table></figure><h2 id="阻止系统响应任何从外部内部来的-ping-请求"><a class="markdownIt-Anchor" href="#阻止系统响应任何从外部内部来的-ping-请求"></a> 阻止系统响应任何从外部/内部来的 ping 请求</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">危险等级:中级</span><br><span class="line">类型：安全基线</span><br><span class="line">描述：既然没有人能ping通你的机器并收到响应，你可以大大增强你的站点的安全性。你可以加下面的一行命令到/etc/rc.d/rc.local，以使每次启动后自动运行。</span><br><span class="line">参考链接：无</span><br><span class="line">操作步骤：</span><br><span class="line">    echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</span><br><span class="line">    #这个可以不做哈</span><br></pre></td></tr></table></figure><h2 id="修改etchostconf文件"><a class="markdownIt-Anchor" href="#修改etchostconf文件"></a> 修改&quot;/etc/host.conf&quot;文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">危险等级:中级</span><br><span class="line">类型：安全基线</span><br><span class="line">描述：</span><br><span class="line">参考链接：无</span><br><span class="line">操作步骤：</span><br><span class="line">    &quot;/etc/host.conf&quot;说明了如何解析地址。编辑&quot;/etc/host.conf&quot;文件（vi /etc/host.conf），加入下面这行：</span><br><span class="line">    # Lookup names via DNS first then fall back to /etc/hosts.</span><br><span class="line">    order hosts,bind</span><br><span class="line">    # We have machines with multiple IP addresses.</span><br><span class="line">    multi on</span><br><span class="line">    # Check for IP address spoofing.</span><br><span class="line">    nospoof on</span><br><span class="line">    第一项设置首先通过DNS解析IP地址，然后通过hosts文件解析。</span><br><span class="line">    第二项设置检测是否“/etc/hosts”文件中的主机是否拥有多个IP地址（比如有多个以太口网卡）。</span><br><span class="line">    第三项设置说明要注意对本机未经许可的电子欺骗。</span><br></pre></td></tr></table></figure><h2 id="不允许从不同的控制台进行-root-登陆"><a class="markdownIt-Anchor" href="#不允许从不同的控制台进行-root-登陆"></a> 不允许从不同的控制台进行 root 登陆</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">危险等级:中级</span><br><span class="line">类型：安全基线</span><br><span class="line">描述：</span><br><span class="line">参考链接：无</span><br><span class="line">操作步骤：</span><br><span class="line">    &quot;/etc/securetty&quot;文件允许你定义root用户可以从那个TTY设备登陆。你可以编辑&quot;/etc/securetty&quot;文件，再不需要登陆的TTY设备前添加“#”标志，来禁止从该TTY设备进行root登陆。</span><br><span class="line"></span><br><span class="line">    在/etc/inittab文件中有如下一段话：</span><br><span class="line"></span><br><span class="line">    # Run gettys in standard runlevels</span><br><span class="line">    1:2345:respawn:/sbin/mingetty tty1</span><br><span class="line">    2:2345:respawn:/sbin/mingetty tty2</span><br><span class="line">    # 3:2345:respawn:/sbin/mingetty tty3</span><br><span class="line">    # 4:2345:respawn:/sbin/mingetty tty4</span><br><span class="line">    # 5:2345:respawn:/sbin/mingetty tty5</span><br><span class="line">    # 6:2345:respawn:/sbin/mingetty tty6</span><br><span class="line">    系统默认的可以使用6个控制台，即Alt+F1,Alt+F2...，这里在3，4，5，6前面加上“#”，注释该句话，这样现在只有两个控制台可供使用，最好保留两个。然后重新启动init进程，改动即可生效！</span><br></pre></td></tr></table></figure><h2 id="禁止-control-alt-delete-键盘关闭命令"><a class="markdownIt-Anchor" href="#禁止-control-alt-delete-键盘关闭命令"></a> 禁止 Control-Alt-Delete 键盘关闭命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">危险等级:中级</span><br><span class="line">类型：安全基线</span><br><span class="line">描述：</span><br><span class="line">参考链接：无</span><br><span class="line">操作步骤：</span><br><span class="line">    在&quot;/etc/inittab&quot; 文件中注释掉下面这行（使用#）：</span><br><span class="line">    ca::ctrlaltdel:/sbin/shutdown -t3 -r now</span><br><span class="line">    改为：</span><br><span class="line">    # ca::ctrlaltdel:/sbin/shutdown -t3 -r now</span><br><span class="line">    为了使这项改动起作用，输入下面这个命令：</span><br><span class="line">    # /sbin/init q</span><br></pre></td></tr></table></figure><h2 id="用-chattr-命令给下面的文件加上不可更改属性"><a class="markdownIt-Anchor" href="#用-chattr-命令给下面的文件加上不可更改属性"></a> 用 chattr 命令给下面的文件加上不可更改属性。</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">危险等级:中级</span><br><span class="line">类型：安全基线</span><br><span class="line">描述：</span><br><span class="line">参考链接：无</span><br><span class="line">操作步骤：</span><br><span class="line">    [root@c1gstudio]# chattr +i /etc/passwd</span><br><span class="line">    [root@c1gstudio]# chattr +i /etc/shadow</span><br><span class="line">    [root@c1gstudio]# chattr +i /etc/group</span><br><span class="line">    [root@c1gstudio]# chattr +i /etc/gshadow</span><br><span class="line">    【注：chattr是改变文件属性的命令，参数i代表不得任意更动文件或目录,此处的i为不可修改位(immutable)。查看方法：lsattr /etc/passwd，撤销为chattr –i /etc/group】</span><br><span class="line"></span><br><span class="line">    补充说明：这项指令可改变存放在ext2文件系统上的文件或目录属性，这些属性共有以下8种模式：</span><br><span class="line"></span><br><span class="line">    　a：让文件或目录仅供附加用途。</span><br><span class="line">    　b：不更新文件或目录的最后存取时间。</span><br><span class="line">    　c：将文件或目录压缩后存放。</span><br><span class="line">    　d：将文件或目录排除在倾倒操作之外。</span><br><span class="line">    　i：不得任意更动文件或目录。</span><br><span class="line">    　s：保密性删除文件或目录。</span><br><span class="line">    　S：即时更新文件或目录。</span><br><span class="line">    　u：预防以外删除。</span><br><span class="line">    参数：</span><br><span class="line"></span><br><span class="line">    　-R 递归处理，将指定目录下的所有文件及子目录一并处理。</span><br><span class="line">    　-v&lt;版本编号&gt; 设置文件或目录版本。</span><br><span class="line">    　-V 显示指令执行过程。</span><br><span class="line">    　+&lt;属性&gt; 开启文件或目录的该项属性。</span><br><span class="line">    　-&lt;属性&gt; 关闭文件或目录的该项属性。</span><br><span class="line">    　=&lt;属性&gt; 指定文件或目录的该项属性。</span><br></pre></td></tr></table></figure><h2 id="给系统服务端口列表文件加锁"><a class="markdownIt-Anchor" href="#给系统服务端口列表文件加锁"></a> 给系统服务端口列表文件加锁</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">危险等级:中级</span><br><span class="line">类型：安全基线</span><br><span class="line">描述：主要作用是防止未经许可的删除或添加服务</span><br><span class="line">参考链接：无</span><br><span class="line">操作步骤：</span><br><span class="line">    chattr +i /etc/services</span><br><span class="line">    【查看方法：lsattr /etc/ services，撤销为chattr –i /etc/ services】</span><br></pre></td></tr></table></figure><h2 id="系统文件权限修改"><a class="markdownIt-Anchor" href="#系统文件权限修改"></a> 系统文件权限修改</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">危险等级:中级</span><br><span class="line">类型：安全基线</span><br><span class="line">描述：Linux文件系统的安全主要是通过设置文件的权限来实现的。每一个Linux的文件或目录，都有3组属性，分别定义文件或目录的所有者，用户组和其他人的使用权限（只读、可写、可执行、允许SUID、允许SGID等）。特别注意，权限为SUID和SGID的可执行文件，在程序运行过程中，会给进程赋予所有者的权限，如果被黑客发现并利用就会给系统造成危害。</span><br><span class="line">参考链接：无</span><br><span class="line">操作步骤：</span><br><span class="line">    (1)修改init目录文件执行权限：</span><br><span class="line"></span><br><span class="line">    chmod -R 700 /etc/init.d/* （递归处理，owner具有rwx，group无，others无）</span><br><span class="line">    (2)修改部分系统文件的SUID和SGID的权限：</span><br><span class="line">    chmod a-s /usr/bin/chage</span><br><span class="line">    chmod a-s /usr/bin/gpasswd</span><br><span class="line">    chmod a-s /usr/bin/wall</span><br><span class="line">    chmod a-s /usr/bin/chfn</span><br><span class="line">    chmod a-s /usr/bin/chsh</span><br><span class="line">    chmod a-s /usr/bin/newgrp</span><br><span class="line">    chmod a-s /usr/bin/write</span><br><span class="line">    chmod a-s /usr/sbin/usernetctl</span><br><span class="line">    chmod a-s /usr/sbin/traceroute</span><br><span class="line">    chmod a-s /bin/mount</span><br><span class="line">    chmod a-s /bin/umount</span><br><span class="line">    chmod a-s /sbin/netreport</span><br><span class="line">    (3)修改系统引导文件</span><br><span class="line"></span><br><span class="line">    chmod 600 /etc/grub.conf</span><br><span class="line">    chattr +i /etc/grub.conf</span><br><span class="line">    【查看方法：lsattr /etc/grub.conf，撤销为chattr –i /etc/grub.conf】</span><br></pre></td></tr></table></figure><h2 id="增加-dns"><a class="markdownIt-Anchor" href="#增加-dns"></a> 增加 dns</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">危险等级:中级</span><br><span class="line">类型：安全基线</span><br><span class="line">描述：</span><br><span class="line">参考链接：无</span><br><span class="line">操作步骤：</span><br><span class="line">    # vi /etc/resolv.conf</span><br><span class="line">    nameserver 8.8.8.8 #google dns</span><br><span class="line">    nameserver 8.8.4.4</span><br></pre></td></tr></table></figure><h2 id="hostname-修改"><a class="markdownIt-Anchor" href="#hostname-修改"></a> hostname 修改</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">危险等级:低级</span><br><span class="line">类型：安全基线</span><br><span class="line">描述：</span><br><span class="line">参考链接：无</span><br><span class="line">操作步骤：</span><br><span class="line">    # 注意需先把mysql、postfix等服务停了</span><br><span class="line">    1.hostname servername</span><br><span class="line">    2.vi /etc/sysconfig/network</span><br><span class="line">    service network restart</span><br><span class="line">    3.vi /etc/hosts</span><br></pre></td></tr></table></figure><h2 id="selinux-修改"><a class="markdownIt-Anchor" href="#selinux-修改"></a> selinux 修改</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">危险等级:中级</span><br><span class="line">类型：安全基线</span><br><span class="line">描述：</span><br><span class="line">参考链接：无</span><br><span class="line">操作步骤：</span><br><span class="line">    开启selinux可以增加安全性，但装软件时可能会遇到一些奇怪问题</span><br><span class="line">    以下是关闭方法</span><br><span class="line"></span><br><span class="line">    # vi /etc/selinux/config</span><br><span class="line">    改成disabled</span><br></pre></td></tr></table></figure><h2 id="关闭-ipv6"><a class="markdownIt-Anchor" href="#关闭-ipv6"></a> 关闭 ipv6</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">危险等级:中级</span><br><span class="line">类型：安全基线</span><br><span class="line">描述：</span><br><span class="line">参考链接：无</span><br><span class="line">操作步骤：</span><br><span class="line">    echo &quot;alias net-pf-10 off&quot; &gt;&gt; /etc/modprobe.conf</span><br><span class="line">    echo &quot;alias ipv6 off&quot; &gt;&gt; /etc/modprobe.conf</span><br><span class="line">    # vi /etc/sysconfig/network</span><br><span class="line">    NETWORKING_IPV6=no</span><br><span class="line">    重启服务</span><br><span class="line"></span><br><span class="line">    Service ip6tables stop</span><br><span class="line">    Service network restart</span><br><span class="line">    关闭自动启动</span><br><span class="line"></span><br><span class="line">    chkconfig --level 235 ip6tables off</span><br></pre></td></tr></table></figure><h2 id="设置-iptables"><a class="markdownIt-Anchor" href="#设置-iptables"></a> 设置 iptables</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">危险等级:中级</span><br><span class="line">类型：安全基线</span><br><span class="line">描述：</span><br><span class="line">参考链接：无</span><br><span class="line">操作步骤：</span><br><span class="line">    iptables 默认安全规则脚本</span><br><span class="line"></span><br><span class="line">    重启系统</span><br><span class="line"></span><br><span class="line">    以上大部分设置可以运行脚本来完成。linux安全设置快捷脚本</span><br><span class="line"></span><br><span class="line">    设置完成后重启系统</span><br></pre></td></tr></table></figure><h2 id="其它设置项"><a class="markdownIt-Anchor" href="#其它设置项"></a> 其它设置项</h2><h3 id="linux-调整系统时区时间的方法"><a class="markdownIt-Anchor" href="#linux-调整系统时区时间的方法"></a> linux 调整系统时区/时间的方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">危险等级:低级</span><br><span class="line">类型：安全基线</span><br><span class="line">描述：</span><br><span class="line">参考链接：无</span><br><span class="line">操作步骤：</span><br><span class="line">    把/usr/share/zoneinfo里相应的时区与/etc/localtime做个软link.比如使用上海时区的时间:ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 如果要使用UTC计时方式，则应在/etc/sysconfig/clock文件里改UTC=TRUE 时间的设置: 使用date 命令加s参数修改，注意linux的时间格式为&quot;月日时分年&quot;,也可以只修改时间date -s 22:30:20,如果修改的是年月日和时间，格式为&quot;月日时分年.秒&quot;,2007-03-18 11:01:56则应写为&quot;date -s 031811012007.56 硬件时间与当前时间更新: hwclock --systohc 如果硬件记时用UTC,则为 hwclock --systohc --utc</span><br><span class="line"></span><br><span class="line">    linux调整系统时区/时间的方法</span><br><span class="line"></span><br><span class="line">    1) 找到相应的时区文件</span><br><span class="line"></span><br><span class="line">    /usr/share/zoneinfo/Asia/Shanghai</span><br><span class="line">    用这个文件替换当前的/etc/localtime文件。</span><br><span class="line">    步骤：cp –i /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line"></span><br><span class="line">    选择覆盖</span><br><span class="line"></span><br><span class="line">    2) 修改/etc/sysconfig/clock文件，修改为：</span><br><span class="line"></span><br><span class="line">    ZONE=&quot;Asia/Shanghai&quot;</span><br><span class="line">    UTC=false</span><br><span class="line">    ARC=false</span><br><span class="line">    3)</span><br><span class="line">    时间设定成2005年8月30日的命令如下：</span><br><span class="line"></span><br><span class="line">    # date -s 08/30/2005</span><br><span class="line">    将系统时间设定成下午6点40分0秒的命令如下：</span><br><span class="line"></span><br><span class="line">    # date -s 18:40:00</span><br><span class="line">    4)同步BIOS时钟，强制把系统时间写入CMOS，命令如下：</span><br><span class="line"></span><br><span class="line">    # clock -w</span><br><span class="line">    安装ntpd</span><br><span class="line"></span><br><span class="line">    # yum install ntp</span><br><span class="line">    # chkconfig --levels 235 ntpd on</span><br><span class="line">    # ntpdate ntp.api.bz #先手动校准下</span><br><span class="line">    # service ntpd start</span><br></pre></td></tr></table></figure><h3 id="设置语言"><a class="markdownIt-Anchor" href="#设置语言"></a> 设置语言</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">危险等级:低级</span><br><span class="line">类型：安全基线</span><br><span class="line">描述：英文语言，中文支持</span><br><span class="line">参考链接：无</span><br><span class="line">操作步骤：</span><br><span class="line">    # vi /etc/sysconfig/i18n</span><br><span class="line">    LANG=&quot;en_US.UTF-8&quot;</span><br><span class="line">    SUPPORTED=&quot;zh_CN.UTF-8:zh_CN:zh&quot;</span><br><span class="line">    SYSFONT=&quot;latarcyrheb-sun16&quot;</span><br><span class="line">    tmpwatch 定时清除</span><br><span class="line"></span><br><span class="line">    假设服务器自定义了php的session和upload目录</span><br><span class="line"></span><br><span class="line">    # vi /etc/cron.daily/tmpwatch</span><br><span class="line">    在240 /tmp 前增加</span><br><span class="line">    -x /tmp/session -x /tmp/upload</span><br><span class="line">    # mkdir /tmp/session</span><br><span class="line">    # mkdir /tmp/upload</span><br><span class="line">    # chown nobody:nobody /tmp/upload</span><br><span class="line">    # chmod 0770 /tmp/upload</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ops </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>碎碎念</title>
      <link href="2016/08/01/lifeMind/"/>
      <url>2016/08/01/lifeMind/</url>
      
        <content type="html"><![CDATA[<p>不要放弃对生命的思索，对自己的真实。</p><span id="more"></span><h3 id="202008"><a class="markdownIt-Anchor" href="#202008"></a> 2020.08</h3><p>将每次谈判、每次沟通当作最后一次机会。就会谨慎地思考，严密地部署，全力一搏地行动，拥有置死地而后生的勇气。</p><h3 id="202006"><a class="markdownIt-Anchor" href="#202006"></a> 2020.06</h3><p>我不喜欢过于情绪化和过于戾气的人，甚至于会下意识远离，因为自知本身也不是耐心太好脾气太好的人。<br />我不觉得自己有改变他人的能力，只求好不容易培养起的耐性不会随意被耗尽。</p><h3 id="202002"><a class="markdownIt-Anchor" href="#202002"></a> 2020.02</h3><p>这个世界没有那么完美，也没有那么丑恶。我们从事网络安全的，本来就是与魔共舞。对世界的热爱，是在知道它的不完美后，依然能矢志不渝，去尽自己的绵薄之力。</p><h3 id="201910"><a class="markdownIt-Anchor" href="#201910"></a> 2019.10</h3><p>凡事有交代，件件有着落，事事有回音。</p><h3 id="201906"><a class="markdownIt-Anchor" href="#201906"></a> 2019.06</h3><p>每个人都有自己的选择。<br />— QS.Wang</p><h3 id="201905"><a class="markdownIt-Anchor" href="#201905"></a> 2019.05</h3><p>“增删改查”业务系统的技术含量不在于如何实现，而在于如何对现实世界的抽象，如何应对复杂的需求及变更，如何把控项目的质量和进度。<br />能否实现功能，会不会一门新技术只是程序员的基本要求，而且在信息如此发达的当下，这些已经没有任何难度，也不会成为程序员的核心竞争力，而深入理解计算机系统，设计能力，高质量代码能力，项目的把控能力才是要坚持苦练的内功也是架构师和码农的本质区别。<br />— J.Xu</p><h3 id="201608"><a class="markdownIt-Anchor" href="#201608"></a> 2016.08</h3><p>所思所想，所感所做，感极而悲。<br />“大难临头，何以为之。”<br />“世受国恩，死生系之。”</p><p>往事不回头，未来不将就。</p>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>利用多核CPU加速Linux命令</title>
      <link href="2015/08/14/tipsLinuxCommand/"/>
      <url>2015/08/14/tipsLinuxCommand/</url>
      
        <content type="html"><![CDATA[<p>要想让<code>Linux</code>命令使用所有的<code>CPU</code>内核，我们需要用到<code>GNU Parallel</code>命令，它让我们所有的<code>CPU</code>内核在单机内做神奇的<code>map-reduce</code>操作，当然，这还要借助很少用到的<code>–pipes 参数(也叫做–spreadstdin)</code>。这样，你的负载就会平均分配到各<code>CPU</code>上。</p><span id="more"></span><p>你是否曾经有过要计算一个非常大的数据(几百 GB)的需求？或在里面搜索，或其它操作——一些无法并行的操作。数据专家们，我是在对你们说。你可能有一个 4 核或更多核的 CPU，但我们合适的工具，例如 <code>grep</code>, <code>bzip2</code>, <code>wc</code>, <code>awk</code>, <code>sed</code>等等，都是单线程的，只能使用一个 CPU 内核。</p><p>借用卡通人物 Cartman 的话，“如何我能使用这些内核”?</p><p>要想让 Linux 命令使用所有的 CPU 内核，我们需要用到<a href="https://www.gnu.org/software/parallel/">GNU Parallel</a>命令，它让我们所有的 CPU 内核在单机内做神奇的 map-reduce 操作，当然，这还要借助很少用到的–pipes 参数(也叫做–spreadstdin)。这样，你的负载就会平均分配到各 CPU 上，真的。</p><h2 id="bzip2"><a class="markdownIt-Anchor" href="#bzip2"></a> BZIP2</h2><p>bzip2 是比 gzip 更好的压缩工具，但它很慢！别折腾了，我们有办法解决这问题。<br />以前的做法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat bigfile.bin | bzip2 –best &gt; compressedfile.bz2</span><br></pre></td></tr></table></figure><p>现在这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat bigfile.bin | parallel –pipe –recend ” -k bzip2 –best &gt; compressedfile.bz2</span><br></pre></td></tr></table></figure><p>尤其是针对 bzip2，GNU parallel 在多核 CPU 上是超级的快。你一不留神，它就执行完成了。</p><h2 id="grep"><a class="markdownIt-Anchor" href="#grep"></a> GREP</h2><p>如果你有一个非常大的文本文件，以前你可能会这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep pattern bigfile.txt</span><br></pre></td></tr></table></figure><p>现在你可以这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat bigfile.txt | parallel  –pipe grep ‘pattern’</span><br></pre></td></tr></table></figure><p>或者这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat bigfile.txt | parallel –block 10M –pipe grep ‘pattern’</span><br></pre></td></tr></table></figure><p>这第二种用法使用了 <code>–block 10</code>M 参数，这是说每个内核处理 1 千万行——你可以用这个参数来调整每个 CUP 内核处理多少行数据。</p><h2 id="awk"><a class="markdownIt-Anchor" href="#awk"></a> AWK</h2><p>下面是一个用 awk 命令计算一个非常大的数据文件的例子。<br />常规用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat rands20M.txt | awk ‘&#123;s+=<span class="variable">$1</span>&#125; END &#123;<span class="built_in">print</span> s&#125;’</span><br></pre></td></tr></table></figure><p>现在这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat rands20M.txt | parallel –pipe awk \<span class="string">&#x27;&#123;s+=\$1&#125; END &#123;print s&#125;\’ | awk ‘&#123;s+=$1&#125; END &#123;print s&#125;’</span></span><br></pre></td></tr></table></figure><p>这个有点复杂：<code>parallel</code>命令中的<code>–pipe</code>参数将<code>cat</code>输出分成多个块分派给<code>awk</code>调用，形成了很多子计算操作。这些子计算经过第二个管道进入了同一个<code>awk</code>命令，从而输出最终结果。第一个<code>awk</code>有三个反斜杠，这是<code>GNU parallel</code>调用<code>awk</code>的需要。</p><h2 id="wc"><a class="markdownIt-Anchor" href="#wc"></a> WC</h2><p>想要最快的速度计算一个文件的行数吗？<br />传统做法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc -l bigfile.txt</span><br></pre></td></tr></table></figure><p>现在你应该这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat bigfile.txt | parallel  –pipe wc -l | awk ‘&#123;s+=<span class="variable">$1</span>&#125; END &#123;<span class="built_in">print</span> s&#125;’</span><br></pre></td></tr></table></figure><p>非常的巧妙，先使用<code>parallel</code>命令<code>mapping</code>出大量的<code>wc -l</code>调用，形成子计算，最后通过管道发送给<code>awk</code>进行汇总。</p><h2 id="sed"><a class="markdownIt-Anchor" href="#sed"></a> SED</h2><p>想在一个巨大的文件里使用 sed 命令做大量的替换操作吗？<br />常规做法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed s^old^new^g bigfile.txt</span><br></pre></td></tr></table></figure><p>现在你可以：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat bigfile.txt | parallel –pipe sed s^old^new^g</span><br></pre></td></tr></table></figure><p>然后你可以使用管道把输出存储到指定的文件里。</p>]]></content>
      
      
      <categories>
          
          <category> tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Plan Do Review</title>
      <link href="2015/03/20/lifePersonPlan/"/>
      <url>2015/03/20/lifePersonPlan/</url>
      
        <content type="html"><![CDATA[<p>凡事豫则立，不豫则废。言前定则不跲，事前定则不困，行前定则不疚，道前定则不穷。</p><span id="more"></span><h2 id="个人成长"><a class="markdownIt-Anchor" href="#个人成长"></a> 个人成长</h2><ul><li><p>确立个人方向，结合工作内容，找出对应短板</p><p>该领域主要专家们的工作是否了解？<br />相关网络协议，文件格式是否熟悉？<br />相关的技术和主要工具是否都看过？用过？</p></li><li><p>阅读只是学习过程的起点，不能止于阅读</p><p>工具的每个参数每个菜单都要看、要试；<br />学习网络协议要实际抓包分析，学习文件格式要读代码实现；<br />学习老漏洞一定要调试，搞懂别人代码每一个字节的意义，之后要完全自己重写一个<code>Exploit</code>；<br />细节、细节、细节，刨根问底；</p></li></ul><h2 id="建立学习参考目标"><a class="markdownIt-Anchor" href="#建立学习参考目标"></a> 建立学习参考目标</h2><ul><li><p>短期参考什么？比自己优秀的同龄人</p><p>阅读他们的文章和其他工作成果，从细节中观察他们的学习方式和工作方式。</p></li><li><p>中期参考什么？你的方向上的业内专家</p><p>了解他们的成长轨迹，跟踪他们关注的内容。</p></li><li><p>长期参考什么？业内老牌企业和先锋企业</p><p>把握行业发展、技术趋势，为未来做积累。</p></li></ul><h2 id="推荐的学习方式"><a class="markdownIt-Anchor" href="#推荐的学习方式"></a> 推荐的学习方式</h2><ul><li><p>以工具为线索</p><p>一个比较省事的学习目录：<code>Kali Linux</code></p><p>学习思路，以<code>Metasploit</code>为例：</p><pre><code>  遍历每个子目录，除了 Exploit 里面还有什么？  每个工具分别有什么功能？原理是什么？涉及哪些知识？  能否改进优化？能否发展、组合出新的功能？</code></pre></li><li><p>以专家为线索</p><p>你的技术方向里有哪些专家？</p><p>他们的邮箱、主页、社交网络账号是什么？</p><p>他们在该方向上有哪些作品？发表过哪些演讲？</p><p>跟踪关注，一个一个学。</p></li></ul><h2 id="处理好学习-工作和生活"><a class="markdownIt-Anchor" href="#处理好学习-工作和生活"></a> 处理好学习、工作和生活</h2><ul><li><p>学习、工作和生活是矛盾统一的</p></li><li><p>三者都需要时间，你一天只有 24 小时</p><p>调和矛盾的关键：提高效率。</p></li></ul><h2 id="如何提高效率"><a class="markdownIt-Anchor" href="#如何提高效率"></a> 如何提高效率</h2><ul><li>做好预研，收集相关前人成果，避免无谓的重复劳动</li><li>在可行性判断阶段，能找到工具就不写代码，能用脚本语言写就不要用编译语言，能把完美主义放在最终实现阶段</li><li>做好笔记并定期整理，遗忘会让所有的投入都白费</li><li>多和同事交流，别人说的一个工具的名字可能让你节约数小时</li><li>咖啡可以提高思维效率，而且合法</li><li>无论怎么提高效率，要成为专家，都需要大量的时间投入</li></ul>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
