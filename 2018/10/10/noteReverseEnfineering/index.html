<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name="renderer" content="webkit"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="theme-color" content="#000000"><meta http-equiv="window-target" content="_top"><title>逆向笔记梳理 | debug.cool</title><meta name="description" content="先把大纲列出来，有空就慢慢更新完善。"><meta property="og:type" content="article"><meta property="og:title" content="逆向笔记梳理"><meta property="og:url" content="http://debug.cool/2018/10/10/noteReverseEnfineering/index.html"><meta property="og:site_name" content="Kirk"><meta property="og:description" content="先把大纲列出来，有空就慢慢更新完善。"><meta property="og:locale" content="en_US"><meta property="article:published_time" content="2018-10-09T23:33:25.000Z"><meta property="article:modified_time" content="2021-05-07T07:30:39.984Z"><meta property="article:author" content="ClanceyHuang"><meta property="article:tag" content="debug"><meta name="twitter:card" content="summary"><link rel="canonical" href="http://debug.cool/2018/10/10/noteReverseEnfineering/index.html"><link rel="alternate" href="/atom.xml" title="Kirk" type="application/atom+xml"><link rel="icon" href="/avatar.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 5.4.0"><link rel="stylesheet" href="/css/prism-vs.css" type="text/css"></head><body class="main-center" itemscope itemtype="http://schema.org/WebPage"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="slimContent"><div class="navbar-header"><div class="profile-block text-center"><a id="avatar" href="/" target="_blank"><img class="img-circle img-rotate" src="/avatar.png" width="200" height="200"></a><h2 id="name" class="hidden-xs hidden-sm">ClanceyHuang</h2><h3 id="title" class="hidden-xs hidden-sm hidden-md">Low Level Researcher</h3><small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shanghai, China</small></div><div class="search" id="search-form-wrap"><form class="search-form sidebar-form" method="GET" action="https://www.baidu.com/s?"><div class="input-group"><input name="wd" type="text" class="form-control search-form-input" placeholder="Search"> <span class="input-group-btn"><button type="submit" class="btn btn-flat search-form-submit"><i class="icon icon-search"></i></button></span></div></form></div><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button></div><nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation"><ul class="nav navbar-nav main-nav menu-highlight"><li class="menu-item menu-item-home"><a href="/."><i class="icon icon-home-fill"></i> <span class="menu-title">Home</span></a></li><li class="menu-item menu-item-archives"><a href="/archives"><i class="icon icon-archives-fill"></i> <span class="menu-title">Archives</span></a></li><li class="menu-item menu-item-categories"><a href="/categories"><i class="icon icon-folder"></i> <span class="menu-title">Categories</span></a></li><li class="menu-item menu-item-tags"><a href="/tags"><i class="icon icon-tags"></i> <span class="menu-title">Tags</span></a></li><li class="menu-item menu-item-repository"><a href="/repository"><i class="icon icon-project"></i> <span class="menu-title">Repository</span></a></li><li class="menu-item menu-item-links"><a href="/links"><i class="icon icon-friendship"></i> <span class="menu-title">Links</span></a></li><li class="menu-item menu-item-about"><a href="/about"><i class="icon icon-cup-fill"></i> <span class="menu-title">About</span></a></li></ul><ul class="social-links"><li><a href="https://github.com/ClanceyHuang" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul></nav></div></header><aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><div class="widget"><h3 class="widget-title">Board</h3><div class="widget-body"><div id="board"><div class="content"><p>Think Twice Code Once.</p></div></div></div></div><div class="widget"><h3 class="widget-title">Tag Cloud</h3><div class="widget-body tagcloud"><a href="/tags/Kafka/" style="font-size:13px">Kafka</a> <a href="/tags/Matplotlib/" style="font-size:13px">Matplotlib</a></div></div><div class="widget"><h3 class="widget-title">Recent Posts</h3><div class="widget-body"><ul class="recent-post-list list-unstyled no-thumbnail"><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/dev/">dev</a></p><p class="item-title"><a href="/2021/04/23/hvv2021/" class="title">2021HVV漏洞公布</a></p><p class="item-date"><time datetime="2021-04-23T07:44:00.000Z" itemprop="datePublished">2021-04-23</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/sec/">sec</a></p><p class="item-title"><a href="/2021/04/01/sandboxEscapePy3/" class="title">Python3的一个沙箱逃逸技巧</a></p><p class="item-date"><time datetime="2021-03-31T16:10:00.000Z" itemprop="datePublished">2021-04-01</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/tips/">tips</a></p><p class="item-title"><a href="/2021/01/20/tipsWSL/" class="title">Windows10下WSL开发环境搭建</a></p><p class="item-date"><time datetime="2021-01-20T14:44:00.000Z" itemprop="datePublished">2021-01-20</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/dev/">dev</a></p><p class="item-title"><a href="/2020/12/09/devDiyExpress/" class="title">DiyExpress - 自定义表达式计算引擎</a></p><p class="item-date"><time datetime="2020-12-08T16:00:00.000Z" itemprop="datePublished">2020-12-09</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/tips/">tips</a></p><p class="item-title"><a href="/2020/03/15/tipsDoubleSystem/" class="title">Window10下双系统grub修复</a></p><p class="item-date"><time datetime="2020-03-15T15:10:00.000Z" itemprop="datePublished">2020-03-15</time></p></div></li></ul></div></div></div></aside><aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><nav id="toc" class="article-toc"><h3 class="toc-title">Catalogue</h3><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#x86-%E4%B8%8E-x64"><span class="toc-number">1.</span> <span class="toc-text">x86 与 x64</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%84%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">寄存器组与数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="toc-number">1.2.</span> <span class="toc-text">指令集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">1.2.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%A7%BB%E5%8A%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text">数据移动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E6%93%8D%E4%BD%9C%E4%B8%8E%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">1.2.3.</span> <span class="toc-text">栈操作与函数调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="toc-number">1.2.4.</span> <span class="toc-text">控制流</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.</span> <span class="toc-text">系统机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.3.1.</span> <span class="toc-text">地址转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8"><span class="toc-number">1.3.2.</span> <span class="toc-text">中断与异常</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#x64"><span class="toc-number">1.4.</span> <span class="toc-text">x64</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%84%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%A1%A5%E5%85%85"><span class="toc-number">1.4.1.</span> <span class="toc-text">寄存器组与数据类型补充</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%A7%BB%E5%8A%A8%E8%A1%A5%E5%85%85"><span class="toc-number">1.4.2.</span> <span class="toc-text">数据移动补充</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%84%E8%8C%83%E5%9C%B0%E5%9D%80"><span class="toc-number">1.4.3.</span> <span class="toc-text">规范地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">1.4.4.</span> <span class="toc-text">函数调用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arm"><span class="toc-number">2.</span> <span class="toc-text">ARM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7"><span class="toc-number">2.1.</span> <span class="toc-text">基本特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.2.</span> <span class="toc-text">数据类型与寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%BA%A7%E6%8E%A7%E5%88%B6%E4%B8%8E%E8%AE%BE%E7%BD%AE"><span class="toc-number">2.3.</span> <span class="toc-text">系统级控制与设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.4.</span> <span class="toc-text">指令集介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%98%E5%82%A8"><span class="toc-number">2.5.</span> <span class="toc-text">数据加载与存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ldr-%E4%B8%8E-str"><span class="toc-number">2.5.1.</span> <span class="toc-text">LDR 与 STR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ldr-%E7%9A%84%E5%85%B6%E4%BB%96%E7%94%A8%E9%80%94"><span class="toc-number">2.5.2.</span> <span class="toc-text">LDR 的其他用途</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ldm-%E4%B8%8E-stm"><span class="toc-number">2.5.3.</span> <span class="toc-text">LDM 与 STM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#push-%E4%B8%8E-pop"><span class="toc-number">2.5.4.</span> <span class="toc-text">PUSH 与 POP</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">2.6.</span> <span class="toc-text">函数与函数调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97"><span class="toc-number">2.7.</span> <span class="toc-text">算术运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E8%B7%B3%E8%BD%AC%E4%B8%8E%E6%9D%A1%E4%BB%B6%E6%89%A7%E8%A1%8C"><span class="toc-number">2.8.</span> <span class="toc-text">分支跳转与条件执行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#thunb-%E7%8A%B6%E6%80%81"><span class="toc-number">2.8.1.</span> <span class="toc-text">Thunb 状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#switch-case"><span class="toc-number">2.8.2.</span> <span class="toc-text">switch-case</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%82%E9%A1%B9"><span class="toc-number">2.9.</span> <span class="toc-text">杂项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#windows-%E5%86%85%E6%A0%B8"><span class="toc-number">3.</span> <span class="toc-text">Windows 内核</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E4%B8%8E%E8%87%AA%E5%8A%A8%E5%8C%96"><span class="toc-number">4.</span> <span class="toc-text">调试与自动化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86"><span class="toc-number">5.</span> <span class="toc-text">代码混淆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A0%94%E7%A9%B6"><span class="toc-number">6.</span> <span class="toc-text">代码研究</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#windows-%E5%86%85%E6%A0%B8%E4%BB%A3%E7%A0%81"><span class="toc-number">6.1.</span> <span class="toc-text">windows 内核代码</span></a></li></ol></li></ol></nav></div></aside><main class="main" role="main"><div class="content"><article id="post-noteReverseEnfineering" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting"><div class="article-header"><h1 class="article-title" itemprop="name">逆向笔记梳理</h1><div class="article-meta"><span class="article-date"><i class="icon icon-calendar-check"></i> <a href="/2018/10/10/noteReverseEnfineering/" class="article-date"><time datetime="2018-10-09T23:33:25.000Z" itemprop="datePublished">2018-10-10</time> </a></span><span class="article-category"><i class="icon icon-folder"></i> <a class="article-category-link" href="/categories/notes/">notes</a> </span><span class="article-read hidden-xs"><i class="icon icon-eye-fill" aria-hidden="true"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span> </span></span><span class="post-comment"><i class="icon icon-comment"></i> <a href="/2018/10/10/noteReverseEnfineering/#comments" class="article-comment-link">Comments</a></span> <span class="post-wordcount hidden-xs" itemprop="wordCount">Word Count: 12.5k(words)</span> <span class="post-readcount hidden-xs" itemprop="timeRequired">Read Count: 49(minutes)</span></div></div><div class="article-entry marked-body" itemprop="articleBody"><p>先把大纲列出来，有空就慢慢更新完善。</p><span id="more"></span><h2 id="x86-与-x64"><a class="markdownIt-Anchor" href="#x86-与-x64"></a> x86 与 x64</h2><p><code>x86</code>是基于<code>intel 8086</code>处理器的小端（<code>little-endian</code>）体系结构（<code>IA-32</code>的<code>32位</code>实现），他在两种操作模式下执行</p><ul><li>实模式：处理机刚刚上电后只支持 16 位指令集的状态。</li><li>保护模式：处理机支持虚拟内存、分页及其他功能的状态。<br>该体系的<code>64位</code>扩展称为<code>x64</code>或<code>x86-64</code>，<code>x86</code>通过一种称为环级别(<code>ring level</code>)的抽象来支持特权隔离(<code>privilege separation</code>)。</li></ul><h3 id="寄存器组与数据类型"><a class="markdownIt-Anchor" href="#寄存器组与数据类型"></a> 寄存器组与数据类型</h3><p>运行于保护模式下的<code>x86</code>体系结构有 8 个<code>32位</code>通用寄存器(<code>General Purpose Registers, GPR</code>):<code>EAX</code>、<code>EBX</code>、<code>ECX</code>、<code>EDX</code>、<code>EDI</code>、<code>ESI</code>、<code>EBP</code>、<code>ESP</code>。这些寄存器还能进一步分化成<code>8位</code>和<code>16位</code>寄存器。指令指针存储在<code>EIP</code>寄存器中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">31  23  15  7   0</span><br><span class="line">|       EAX     |</span><br><span class="line">|   |   |   AX  |</span><br><span class="line">|   |   |AH |AL |</span><br><span class="line"></span><br><span class="line">31  23  15  7   0       31  23  15  7   0</span><br><span class="line">|       EBP     |       |       ESP     |</span><br><span class="line">|       |   BP  |       |       |   SP  |</span><br><span class="line"></span><br><span class="line">31  23  15  7   0       31  23  15  7   0</span><br><span class="line">|       ESI     |       |       EDI     |</span><br><span class="line">|       |   SI  |       |       |   DI  |</span><br><span class="line"></span><br><span class="line">31  23  15  7   0       31  23  15  7   0</span><br><span class="line">|       EIP     |       |       EFLAGS  |</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">寄存器</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left">ECX</td><td style="text-align:left">循环计数</td></tr><tr><td style="text-align:left">ESI</td><td style="text-align:left">字符串/内存操作的源</td></tr><tr><td style="text-align:left">EDI</td><td style="text-align:left">字符串/内存操作中的目标</td></tr><tr><td style="text-align:left">EBP</td><td style="text-align:left">帧基指针</td></tr><tr><td style="text-align:left">ESP</td><td style="text-align:left">栈指针</td></tr></tbody></table><p>常用的数据类型有以下几种：</p><ul><li>字节(Byte): 8 位，比如 AL、BL、CL。</li><li>字(Word): 16 位，比如 AX、BX、CX。</li><li>双字(Double Word): 32 位，比如 EAX、EBX、ECX。</li><li>四字(Quad Word): 64 位，虽然 x86 并不支持 64 位 GPR，但是在某些场景下可以把两个寄存器(通常是 EDA:EAX)的内容合并起来当作 64 位的值。比如 RDTSC 指令会把一个 64 位值写入 EDX:EAX 寄存器。</li></ul><p><code>32位</code>寄存器<code>EFLAGS</code>用于存储运算状态以及其他运行状态（比如陷阱标志位）。</p><p>除了通用寄存器、<code>EIP</code>和<code>EFLAGS</code>，还有一些寄存器用于控制重要的底层系统机制，比如虚拟内存、终端和调试等。例如：<code>CR0</code>寄存器控制分页机制的开关，<code>CR2</code>寄存器中保存着导致缺页异常发生的线性地址，<code>CR3</code>是分页数据结构的基地址，<code>CR4</code>控制硬件虚拟化设置。<code>DR0～DR7</code>寄存器用于设置内存断点。（注意，虽然调试寄存器有 8 个，但系统只支持 4 个内存断点<code>DR0～DR3</code>，其余寄存器用于保存状态）</p><h3 id="指令集"><a class="markdownIt-Anchor" href="#指令集"></a> 指令集</h3><p><code>x86</code>指令集为寄存器和内存之间的数据移动提供了很大的灵活性。数据移动可以分为 5 种方式：</p><ul><li>立即数到寄存器</li><li>寄存器到寄存器</li><li>立即数到内存</li><li>寄存器到内存，或反向</li><li>内存到内存</li></ul><p>前四种是所有现代体系结构都支持的，而最后一种是<code>x86</code>独有的。像 ARM 这样的经典<code>RISC</code>体系结构只支持通过加载/存储指令（<code>LDR/STR</code>）从内存读出或反向内存写入数据。比如递增内存中数据值需要执行 3 条指令：</p><ol><li>把数据从内存读入到寄存器中（LDR）</li><li>寄存器加 1（ADD）</li><li>把寄存器值写回内存（STR）<br>而对已<code>x86</code>来说，因为可以直接访问内存，这样的操作只需要一条指令（<code>INC或ADD</code>）。<code>MOVS</code>指令可以同时读写内存。<br>ARM：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1B 68   LDR     R3, [R3]</span><br><span class="line">; 读入地址R3处的值并保存在R2中</span><br><span class="line">5A 1C   ADDS    R2, R3, #1</span><br><span class="line">; 加1</span><br><span class="line">1A 60   STR     R2, [R3]</span><br><span class="line">; 把更新后的值写回地址R3处</span><br></pre></td></tr></table></figure><p>x86：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FF 00   inc     dword ptr [eax]</span><br><span class="line">; 直接递增地址EAX处的值</span><br></pre></td></tr></table></figure><p><code>x86</code>的另一个重要特性是使用了变长指令——指令的长度从<code>1到15字节</code>不等。而在<code>ARM</code>上，指令长度只能是<code>2字节或4字节</code>。</p><h4 id="语法"><a class="markdownIt-Anchor" href="#语法"></a> 语法</h4><p>根据<code>汇编器/反汇编器</code>的不同，x86 汇编代码有两种记法：<code>Intel</code>和<code>AT&amp;T</code>。<br>Intel(Windows 上的记法)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ecx, AABBCCDDh</span><br><span class="line">mov ecx, [eax]</span><br><span class="line">mov ecx, eax</span><br></pre></td></tr></table></figure><p>AT&amp;T(unix 上的 GCC 记法):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl $0xAABBCCDD, %ecx</span><br><span class="line">movl (%eax), %ecx</span><br><span class="line">movl %eax, %ecx</span><br></pre></td></tr></table></figure><ul><li>AT&amp;T 记法在寄存器前加前缀%，立即数前加$。Intel 记法不加前缀。</li><li>AT&amp;T 记法加入了指示指令宽度的后缀，比如 MOVL(长整型)、MOVB(字节)等。Intel 记法没有这种标记。</li><li>AT&amp;T 记法把源操作数放在目标操作数之前。Intel 记法与之相反。</li></ul><h4 id="数据移动"><a class="markdownIt-Anchor" href="#数据移动"></a> 数据移动</h4><p>指令用于操作来自寄存器或主内存中的数据。</p><h4 id="栈操作与函数调用"><a class="markdownIt-Anchor" href="#栈操作与函数调用"></a> 栈操作与函数调用</h4><p>C 语言的局部变量就存储在函数的栈空间中。操作系统从<code>ring3</code>切换到<code>ring0</code>时，要把状态信息保存在栈上。具体来讲，<code>x86</code>上的栈是<code>ESP</code>指向的一段连续内存区域，他向下增长。压栈（<code>push指令</code>）递减<code>ESP</code>的值，然后把数据写入 ESP 指向的位置；出栈（<code>pop</code>指令）读出<code>ESP</code>指向位置的数据并递增<code>ESP</code>。默认的自动递增/递减值为 4，但是通过前缀这个值也可以替换为 1 或 2。实际上，这个值几乎总是 4，因为 OS 要求栈双字对齐。<br>假定<code>ESP</code>最初指向<code>0xb20000</code>，然后执行下面的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">; 起始值ESP=0xb20000</span><br><span class="line">B8 AA AA AA AA      MOV     EAX,0AAAAAAAAh</span><br><span class="line">BB BB BB BB BB      MOV     EBX,0BBBBBBBBh</span><br><span class="line">B9 CC CC CC CC      MOV     ECX,0CCCCCCCCh</span><br><span class="line">BA DD DD DD DD      MOV     EDX,0DDDDDDDDh</span><br><span class="line">50                  PUSH    EAX</span><br><span class="line">; 地址0xb1fffc值将会是0xAAAAAAAA，ESP将会是0xb1fffc （=0xb20000-4）</span><br><span class="line">53                  PUSH    EBX</span><br><span class="line">; 地址0xb1fff8的值将会是0xBBBBBBBB，ESP将会是0xb1fff8 （=0xb1fffc-4）</span><br><span class="line">5E                  POP     ESI</span><br><span class="line">; ESI值将会是0xBBBBBBBB，ESP将会是0xb1fffc （=0xb1fff8+4）</span><br><span class="line">5F                  POP     EDI</span><br><span class="line">; EDI值将会是0xAAAAAAAA，ESP将会是0xb20000 （=0xb1fffc+4）</span><br></pre></td></tr></table></figure><p>其他一些指令也可以直接修改<code>ESP</code>，比如<code>ADD</code>和<code>SUB</code></p><p>高级语言中有函数的概念，函数可以被调用也可以返回，而处理器本身并没有提供这样的抽象。在最底层，处理器只操作具体对象，比如寄存器或内存中的数据。在机器语言这一层级通过栈数据结构来实现函数。</p><p>C 代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function">__cdecl <span class="title">addme</span><span class="params">(<span class="keyword">short</span> a, <span class="keyword">short</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rerurn a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">004113A0 55             push    ebp</span><br><span class="line">004113A1 8B EC          mov     ebp, esp</span><br><span class="line">...</span><br><span class="line">004113BE 0F BF 45 08    movsx   eax, word ptr [ebp+8]</span><br><span class="line">004113C2 0F BF 4D 0C    movsx   ecx, word ptr [ebp+0ch]</span><br><span class="line">...</span><br><span class="line">004113CB 8B E5          mov     esp, ebp</span><br><span class="line">004113CD 5D             pop     ebp</span><br><span class="line">004113CE C3             retn</span><br><span class="line">; retn 指令就是把存储在栈顶的地址出栈到EIP，然后把控制传递给他（完全与POP EIP类似，但是x86上并没有这样的指令序列）</span><br></pre></td></tr></table></figure><p>通过下面的代码调用函数：</p><p>C 代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum = addme(x,y);</span><br></pre></td></tr></table></figure><p>汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">004129F3 50             push    eax</span><br><span class="line">...</span><br><span class="line">004129F8 51             push    ecx</span><br><span class="line">004129F9 E8 F1 E7 FF FF call    addme</span><br><span class="line">004129FE 83 C4 08       add     esp, 8</span><br></pre></td></tr></table></figure><p>先了解一下调用惯例，调用惯例规定了在机器层面如何进行函数调用。对于特定的系统来说他是由应用程序二进制接口(<code>Application Binary Interface, ABI</code>)所定义的。</p><table><thead><tr><th style="text-align:left">调用惯例</th><th style="text-align:left">CDECL</th><th style="text-align:left">STDCALL</th><th style="text-align:left">FASTCALL</th></tr></thead><tbody><tr><td style="text-align:left">参数</td><td style="text-align:left">从右向左压栈。调用方负责在调用后清理栈</td><td style="text-align:left">与 CDECL 相同，除了被调用方负责清理栈</td><td style="text-align:left">前两个参数通过 ECX 和 EDX 传递。其余压栈</td></tr><tr><td style="text-align:left">返回值</td><td style="text-align:left">保存在 EAX 中</td><td style="text-align:left">保存在 EAX 中</td><td style="text-align:left">保存在 EAX 中</td></tr><tr><td style="text-align:left">非易失寄存器</td><td style="text-align:left">EBP、ESP、EBX、ESI、EDI</td><td style="text-align:left">EBP、ESP、EBX、ESI、EDI</td><td style="text-align:left">EBP、ESP、EBX、ESI、EDI</td></tr></tbody></table><p>现在我们回到前面的代码片段来讨论函数<code>addme</code>是如何被调用的。</p><p>在第 1 行和第 3 行代码中把两个参数压入栈顶，<code>EXC</code>和<code>EAX</code>分别是第一个和第二个参数。第四行代码通过<code>CALL</code>指令调用了<code>addme</code>函数。这立即导致返回地址<code>0x4120FE</code>被压栈，然后<code>0x4113A0</code>处开始执行。</p><p>第 4 行代码执行后，就进入了<code>addme</code>函数的函数体。第 1 行代码把<code>EBP</code>压栈。第 2 行代码把<code>EBP</code>设置为指向当前栈顶。这个二指令序列建立了一个新的函数帧，因此通常称为<code>函数序言</code>（<code>function prologue</code>）第 4 行代码读入地址<code>EBP+8</code>的值，他是栈的第一个参数。第 5 行代码读入第二个参数。注意参数访问是以<code>EBP</code>作为基地址的。在这个上下文环境中，<code>EBP</code>被称为<code>帧基指针</code>，因为他指向了当前函数的栈帧，参数和局部变量都可以通过相对他的地址来访问。也可以通过一种称为<code>帧指针省略</code>（<code>frame pointer omission</code>）的优化方法指定编译器生成不使用<code>EBP</code>作为帧指针的代码。这种优化下，局部变量和参数的访问是相对<code>ESP</code>进行的，这时<code>EBP</code>可以作为一个通用寄存器，就像<code>EAX</code>、<code>EBX</code>、<code>EXC</code>等寄存器一样。第六行代码执行数字的加运算，并把结果放入<code>EAX</code>中。第 8 行代码把栈指针设为帧指针。第 9 行代码将之前第 1 行中保存的<code>EBP</code>数值出栈到<code>EBP</code>。这个二指令序列结束了当前的函数调用，并恢复了函数调用前的栈帧通常称为函数尾声（<code>function epilogue</code>）。这个时间点上，栈顶值为<code>CALL</code>指令保存的返回地址<code>0x4129F9</code>。第 10 行执行<code>RET</code>指令，这个指令将栈顶元素出栈并从<code>0x4129FE</code>开始继续执行。代码中的第 5 行把栈收缩了 8 字节大小，因为根据<code>CDECL</code>调用惯例的规定，栈清理的工作必须由调用者完成。</p><p>如果函数<code>addme</code>有局部变量，那么代码需要在第 2 行之后通过减小<code>ESP</code>值来增长栈大小。然后所有的局部变量都可以通过<code>EBP</code>加上一个负的偏移量来访问。</p><h4 id="控制流"><a class="markdownIt-Anchor" href="#控制流"></a> 控制流</h4><ul><li>ZF(Zero Flag， 零标志位)：指示之前算术运算的结果是否为 0</li><li>SF(Sifn Flag， 符号标志位)：设为当前结果的最高有效位</li><li>CF(Carry Flag， 借位标志位)： 指示当前结果是否需要借位。对无符号整数有效。</li><li>OF(Over Flag， 溢出标志位)： 只是当前结果是是否超过了最大值。对有符号整数有效。<br>算术运算指令会根据计算结果更新这些标志位。举例来说，<code>SUB EAX</code>,<code>EAX</code>指令会引起 ZF 标志的设置。<code>Jcc</code>指令会根据这些标志位改变控制流，其中<code>cc</code>是某个条件代码(<code>conditional code</code>)，该指令最多支持 16 中条件代码。</li></ul><table><thead><tr><th style="text-align:left">条件代码</th><th style="text-align:left">跳转条件</th><th style="text-align:left">机器描述</th></tr></thead><tbody><tr><td style="text-align:left">JZ/JE</td><td style="text-align:left">若为 0；若相等</td><td style="text-align:left">ZF = 1</td></tr><tr><td style="text-align:left">JNZ/JNE</td><td style="text-align:left">若不为 0；若不相等</td><td style="text-align:left">ZF = 0</td></tr><tr><td style="text-align:left">JS</td><td style="text-align:left">若为负</td><td style="text-align:left">SF = 1</td></tr><tr><td style="text-align:left">JNS</td><td style="text-align:left">若不为负</td><td style="text-align:left">SF = 0</td></tr><tr><td style="text-align:left">JP/JPE</td><td style="text-align:left">若 1 出现的次数为偶数</td><td style="text-align:left">PF = 1</td></tr><tr><td style="text-align:left">JNP/JPO</td><td style="text-align:left">若 1 出现的次数为奇数</td><td style="text-align:left">PF = 0</td></tr><tr><td style="text-align:left">JO</td><td style="text-align:left">若溢出</td><td style="text-align:left">OF = 1</td></tr><tr><td style="text-align:left">JNO</td><td style="text-align:left">若无溢出</td><td style="text-align:left">OF = 0</td></tr><tr><td style="text-align:left">JC/JB/JNAE</td><td style="text-align:left">若进位；若低于；若不高于等于</td><td style="text-align:left">CF = 1</td></tr><tr><td style="text-align:left">JNC/JNB/JAE</td><td style="text-align:left">若无进位；若不低于；若高于等于</td><td style="text-align:left">CF = 0</td></tr><tr><td style="text-align:left">JBE/JNA</td><td style="text-align:left">若低于等于；若不高于</td><td style="text-align:left">ZF = 1 或 CF = 1</td></tr><tr><td style="text-align:left">JNBE/JA</td><td style="text-align:left">若不低于等于；若高于</td><td style="text-align:left">ZF = 0 或 CF = 0</td></tr><tr><td style="text-align:left">JL/JNGE</td><td style="text-align:left">若小于；若不大于等于</td><td style="text-align:left">SF != OF</td></tr><tr><td style="text-align:left">JNL/JGE</td><td style="text-align:left">若不小于；若大于等于</td><td style="text-align:left">SF = OF</td></tr><tr><td style="text-align:left">JLE/JNG</td><td style="text-align:left">若小于等于；若不大于</td><td style="text-align:left">ZF != OF 或 ZF = 1</td></tr><tr><td style="text-align:left">JNLE/JG</td><td style="text-align:left">若不小于等于；若大于</td><td style="text-align:left">SF = 0 且 ZF = 0</td></tr></tbody></table><h3 id="系统机制"><a class="markdownIt-Anchor" href="#系统机制"></a> 系统机制</h3><p>两种基础系统机制：虚拟地址转换（<code>virtual address translation</code>）和异常/中断处理（<code>exception/interrupt handling</code>）</p><h4 id="地址转换"><a class="markdownIt-Anchor" href="#地址转换"></a> 地址转换</h4><p>计算机系统中的物理内存以<code>4KB</code>为单元作为一个页（<code>page</code>）。实际上页的大小也可以超过<code>4KB</code>，这里我们不讨论其他尺寸的页。内存地址分为两种：虚拟内存和物理内存。在分页启动的情况下，处理器执行的指令中使用的地址是虚拟地址。举例来说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A1 78 56 34 12 MOV EAX, [0x12345678]  ; 读入虚内地址为0x12345678的内存</span><br><span class="line">89 08 MOV [EAX], ECX  ; 把ECX写入虚拟地址为EAX处</span><br></pre></td></tr></table></figure><p>物理地址是处理器访问内存时使用的实际内存地址。处理器的<code>MMU</code>(<code>Memory Management Unit</code>， 内存管理单元)在访问内存之前透明地把虚拟地址转换为物理地址。在用户开来虚拟地址就是一个数字，而对于<code>MMU</code>来说这个地址则是结构化的。在支持<code>PAE</code>(<code>Physical Address Extension</code>， 物理地址扩展)的<code>x86</code>系统上，虚拟地址可以划分为几个部分，作为偏移量索引到三个表中，包括<code>PDPT</code>(<code>Page Directory Pointer Table</code>，页目录指针表)、<code>PD</code>(<code>Page Directory</code>，页目录)、<code>PT</code>(<code>Page Table</code>， 页表)以及<code>PTE</code>(<code>Page Table Entry</code>，页表项)。<code>PDPT</code>是<code>4个元素</code>的数组，每个元素<code>8字节</code>，指向一个<code>PD</code>。<code>PD</code>是一个有<code>512个元素</code>的数组，每个元素<code>8字节</code>，指向一个<code>PT</code>。<code>PT</code>也是一个有<code>512个元素</code>的数组，每个元素<code>8字节</code>，指向一个<code>PTE</code>。以虚拟地址<code>0xBF80EE6B</code>(转换成二进制：<code>10111111 10000000 11101110 01101011</code>)来理解，如下表：</p><table><thead><tr><th style="text-align:left">10(0x2)</th><th style="text-align:left">111111 100(0x1FC)</th><th style="text-align:left">00000 1110(0xE)</th><th style="text-align:left">1110 01101011(0xE6B)</th></tr></thead><tbody><tr><td style="text-align:left">2 位</td><td style="text-align:left">9 位</td><td style="text-align:left">9 位</td><td style="text-align:left">12 位</td></tr><tr><td style="text-align:left">索引到 PDPT</td><td style="text-align:left">索引到 PD</td><td style="text-align:left">索引到 PT</td><td style="text-align:left">页偏移量</td></tr></tbody></table><p>这些表中的 8 字节元素包含关于表、内存访问许可以及其他内存属性的数据。比如，其中有一些位用于标识这个页是只读还是可读写、是否可执行、用户是否可以访问等。</p><p>地址转换过程就围绕着这 3 个表和<code>CR3</code>寄存器。<code>CR3</code>寄存器保存着<code>PDPT</code>的物理基地址。</p><h4 id="中断与异常"><a class="markdownIt-Anchor" href="#中断与异常"></a> 中断与异常</h4><p>简单讲就是操作系统通过中断和异常机制实现系统调用，完整的实现细节参考 Windows 内核部分。</p><h3 id="x64"><a class="markdownIt-Anchor" href="#x64"></a> x64</h3><p><code>x64</code>是<code>x86</code>的扩展，所有两者的绝大多数体系结构特性都一样，只有略微不同，比如寄存器宽度，以及某些指令不可再用(比如<code>PUSHAD</code>)。</p><h4 id="寄存器组与数据类型补充"><a class="markdownIt-Anchor" href="#寄存器组与数据类型补充"></a> 寄存器组与数据类型补充</h4><p><code>x64</code>的寄存器组有<code>18个64位GPR</code>，下面画图解释这些寄存器的结构，注意前缀为<code>R</code>的是<code>64位</code>寄存器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">64      .       .       .       31      23      15      7       0</span><br><span class="line">|RAX |    |    |    |    |    |    |    |</span><br><span class="line">|       |       |       |       |EAX    |    |    |    |</span><br><span class="line">|    |    |    |    |    |    |   AX |    |</span><br><span class="line">|    |    |    |    |    |    |   AH |   AL |</span><br><span class="line"></span><br><span class="line">64      .       .       .       31      23      15      7       0</span><br><span class="line">|RBP |    |    |    |    |    |    |    |</span><br><span class="line">|       |       |       |       |EBP    |    |    |    |</span><br><span class="line">|    |    |    |    |    |    |   BP |    |</span><br><span class="line">|    |    |    |    |    |    |    |   BPL |</span><br></pre></td></tr></table></figure><p>虽然<code>RBP</code>任然可以用作帧基指针，但实际应用中编译器生成的代码很少这么用，多数<code>x64</code>编译器只是把<code>RBP</code>当作<code>GPR</code>来用，而用<code>RSP</code>作为基地址引用局部变量。</p><h4 id="数据移动补充"><a class="markdownIt-Anchor" href="#数据移动补充"></a> 数据移动补充</h4><p><code>x64</code>支持一种称为<code>RIP</code>相对寻址(<code>RIP-relative addressing</code>)的概念，其允许指令引用数据时使用相对<code>RIP</code>的地址。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0000000000000000 48 8B 05 00 00+    mov rax, qword ptr cs:loc_A</span><br><span class="line">                                    ; 最开始写作&quot;mov rax,[rip]&quot;</span><br><span class="line">0000000000000007                    loc_A:</span><br><span class="line">0000000000000007 48 31 C0           xor rax,rax</span><br><span class="line">000000000000000A 90                 nop</span><br></pre></td></tr></table></figure><p>第 1 行读入<code>loc_A</code>的地址（为<code>0x7</code>）然后保存到<code>RAX</code>中。<code>RIP</code>相对寻址主要用于产生位置无关代码。<br>多数算术运算指令都自动升级为<code>64位</code>，即使操作数只有<code>32位</code>。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">48 B8 88 77 66+     mov rax, 1122334455667788h</span><br><span class="line">31 C0               xor eax, eax ; 也会清除RAX的高32位，也就是说执行后RAX=0</span><br><span class="line">48 C7 C0 FF FF+     mov rax, 0FFFFFFFFFFFFFFFFh</span><br><span class="line">FF C0               inc eax  ; 执行后RAX=0</span><br></pre></td></tr></table></figure><h4 id="规范地址"><a class="markdownIt-Anchor" href="#规范地址"></a> 规范地址</h4><p><code>x64</code>中虚拟地址的宽度是<code>64位</code>，但多数处理器并不支持完整的<code>64位</code>虚拟地址空间。当前<code>Intel/AMD</code>处理器只使用<code>48位</code>地址空间。所有的虚拟地址必须为规范形式。如果一个虚拟地址从<code>第63位</code>到具体实现的最高有效位都是<code>1</code>或者都是<code>0</code>，那么这个虚拟地址就称为规范地址。具体来说，这意味着从<code>48到63位</code>都要和<code>47位</code>相同。如果代码引用一个非规范地址，就会触发系统异常。</p><h4 id="函数调用"><a class="markdownIt-Anchor" href="#函数调用"></a> 函数调用</h4><p><code>x86</code>上有一些调用惯例需要通过栈来传递一些参数。对于<code>x64</code>来说，多数调用惯例都是通过寄存器传递参数，比如在<code>windows x64</code>中，只有一种调用惯例用到栈，并且其中前四个参数还是通过<code>RCX</code>、<code>RDX</code>、<code>R8</code>和<code>R9</code>来传递的；其余的参数按照从左到右的顺序压栈。Linux 上，则是前 6 个参数通过<code>RDI</code>、<code>RSI</code>、<code>RDX</code>、<code>RCX</code>、<code>R8</code>和<code>R9</code>传递。<br>------------------------本次更新时间 2018-10-16 10:53</p><h2 id="arm"><a class="markdownIt-Anchor" href="#arm"></a> ARM</h2><p>这里介绍的是<code>ARM Architecture Reference Manual ARMv7-A and ARMv777-R Edition (ARM DDI 0406B)</code>中定义的<code>ARM</code>体系结构。</p><h3 id="基本特性"><a class="markdownIt-Anchor" href="#基本特性"></a> 基本特性</h3><p><code>ARM</code>是<code>RISC</code>体系结构，因此与<code>CISC</code>体系结构(<code>x86/x64</code>)有一些基本区别。(从实践的角度说，最新版本的<code>Intel</code>处理器也具有一些<code>RISC</code>的特征；也就是说，他们已经不再是纯粹的<code>CISC</code>。)首先，与<code>x86</code>相比，<code>ARM</code>的指令集是很小的，但是提供的通用寄存器更多。第二，指令的宽度是固定的（<code>16位</code>或<code>32位</code>，根据当前状态而定）。第三，<code>ARM</code>的内存访问模式是<code>加载-存储</code>模式。这意味着操作数据之前必须先要把它从内存加载到寄存器中。只有<code>加载/存储</code>指令能够访问内存，具体来说，在<code>ARM</code>中是<code>LDR</code>和<code>STR</code>指令。如果要递增某个内存地址上的<code>32位</code>数值，必须先把数值从这个地址加载到寄存器中，递增，然后再存储回去。<code>x86</code>则允许大多数指令直接操作内存中的数据，只需要简单的加载，操作，递增三步。</p><p><code>ARM</code>还提供了几种不同级别的特权模式来实现特权隔离。<code>x86</code>上的特权级别是通过 4 种<code>ring</code>级别定义的，其中<code>ring0</code>具有最高特权级别，<code>ring3</code>的特权级别最低。在<code>ARM</code>中，有 8 种不同级别的特权模式：</p><ul><li>USR(USER,用户模式)</li><li>FIQ(FAST INTERRUPT REQUEST,快速中断请求模式)</li><li>IRQ(INTERRUPT REQUEST,中断请求模式)</li><li>SVC(SUPERVISOR, 管理模式)</li><li>MON(MONITOR,监视模式)</li><li>ABT(ABORT,中止模式)</li><li>UND(UNDERFINED,未定义指令模式)</li><li>SYS(SYSTEM,系统模式)</li></ul><p>多数操作系统内核模式运行于<code>SVC</code>。在<code>Windows</code>或<code>Linux</code>上都是。</p><p><code>x64</code>处理器可以运行在<code>32位</code>或<code>64位</code>模式下，也可以交替运行于这两种模式下。<code>ARM</code>处理与之类似，他们也可以运行在两种状态下：<code>ARM</code>和<code>Thumb</code>状态。<code>ARM/Thumb</code>状态决定的只有指令集，而不是特权模式。比如运行子啊在<code>ARM</code>状态下，指令总是<code>32位宽</code>；而在<code>Thumb</code>下，指令可以是<code>16位宽</code>也可以是<code>32位宽</code>。决定处理器执行状态的是以下两个因素。</p><ul><li>通过 BX 和 BLX 指令进行分支跳转的时候，如果目标寄存器的最低有效位是 1，就切换到 Thumb 状态。（尽管指令是 2 字节对齐或 4 字节对齐的，但处理器会忽略最低有效位，因此不会有对齐的问题。）</li><li>如果当前程序状态寄存器（CPSR）中的 T 标志位被置起，就处于 Thumb 模式。CPSR 的语义会在之后详述，目前可以把它类比为 x86 中扩展的 EFLAGS 寄存器。</li></ul><p><code>ARM</code>核心启动的时候，多数情况下都是进入<code>ARM</code>状态并保持在这个状态，知道显式或隐式地切换到<code>Thumb</code>模式。具体实践中，多数较新的操作系统使用<code>Thumb</code>代码是为了获得更高的代码密度（混合使用<code>16/32位宽</code>度指令的代码大小小于全部使用<code>32位</code>指令），而且应用程序可以运行于任意模式下。因为多数<code>Thumb</code>和<code>ARM</code>指令助记符都是相同的，所以在<code>32位Thumb</code>指令后添加一个<code>.W</code>后缀标识。</p><p>注意，有一种很常见的误解，就是把<code>Thumb</code>模式看作<code>x86/x64</code>上的实模式，把<code>ARM</code>模式看作保护模式。<code>x86/x64</code>平台上的绝大多数操作系统运行于保护模式，很少会切换回实模式。位<code>ARM</code>平台上的操作系统和应用程序则可以交替运行于<code>ARM</code>状态和<code>Thumb</code>状态。还要注意，这两个状态与前面介绍的特权模式也是完全不同的概念。<br><code>Thumb</code>有两个版本：<code>Thumb-1</code>和<code>Thumb-2</code>。<code>Thumb-1</code>用于<code>ARMv6</code>和更早期的体系结构，指令集宽度都是<code>16位</code>。<code>Thumb-2</code>增加了更多的指令，并支持<code>16位</code>和<code>32位</code>的指令宽度。<code>ARMv7</code>只用<code>Thumb-2</code>，所以只要是讨论<code>Thumb</code>，都是<code>Thumb-2</code>、<br><code>ARM</code>状态与<code>Thumb</code>状态还有其他一些区别，这里我们没法全部介绍。比如，某些指令只在<code>ARM</code>状态下支持，而在<code>Thumb</code>状态下不可用，或者反之。要了解更多请参考<code>ARM</code>的官方文档。<br>------------------------更新时间 2018-10-17 16:34</p><h3 id="数据类型与寄存器"><a class="markdownIt-Anchor" href="#数据类型与寄存器"></a> 数据类型与寄存器</h3><p>与高级语言类似，<code>ARM</code>也支持多种数据类型的运算，包括：<code>8位</code>（字节），<code>16位</code>（半字）、<code>32位</code>（字）和<code>64位</code>（双字）。</p><p><code>ARM</code>的体系结构定义了<code>16个32位</code>通用寄存器，命名为<code>R0~R15</code>，实际开发中只用<code>前13个作为通用寄存器</code>（就像<code>x86</code>中的<code>EAX</code>、<code>EBX</code>等），最后三个有特殊的意义。</p><ul><li><p>R13 用作栈指针(Stack Point, SP)，等价于 x86/64 下的 ESP、RSP 寄存器，指向程序栈的顶端</p></li><li><p>R14 用作连接寄存器（Link Register, SP），通常用于在函数调用中保存返回地址。某些指令会隐式的使用这个寄存器。比如，BL 总是在分支跳转到目标地址之前把返回值保存在 LR 中。x86/64 中总是把返回地址放在栈上，所以没有相应的寄存器。在不使用 LR 存储返回地址的代码中，这个寄存器可以作为通用寄存器。</p></li><li><p>R15 用作程序计数器（Program Counter，PC）。在 ARM 状态下执行的时候，PC 是当前指令的地址加 8（两条 ARM 指令之后）；在 Thumb 状态下，他是当前指令的地址加 4（两条 16 位 Thumb 指令后）。这个寄存器类似与 x86/64 下的 EIP/RIP，但后者总是指向下一条执行指令的地址。另外一个主要的区别在于，ARM 下代码可以直接读写 PC 寄存器，向 PC 寄存器写入一个值会导致运行立即从那个地址开始（参考下面代码片段）。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x00008344 push &#123;lr&#125;</span><br><span class="line">0x00008346 mov r0,pc</span><br><span class="line">0x00008348 mov.w r2, r2, ls1 #31</span><br><span class="line">0x0000834C pop &#123;pc&#125;</span><br></pre></td></tr></table></figure><p>在第 2 行执行之后，<code>R0</code>的值为<code>0x0000834A</code>(=<code>0x00008346+4</code>)</p><p>与其他体系结构类似，<code>ARM</code>把当前执行状态信息保存在当前程序状态寄存器（<code>CPSR</code>）中。从应用程序开发者的角度来看，<code>CPSR</code>类似于<code>x86/x84</code>下的<code>EFLAGS/RFLAG</code>寄存器。某些文档中会提到应用程序状态寄存器（<code>APSR</code>），这是<code>CPSR</code>中某些字段的别名。<code>CPSR</code>中有很多标志位，下面列出其中的部分：</p><ul><li>E(大小端标志位，Endianness bit)：ARM 可以运行在大端或小端模式下。这一位设置为 0 表示小端，1 表示大端。多数情况下使用小端，即为 0。</li><li>T(Thumb 标志位)：在 Thumb 状态下，这一位会设为 1；否则就是 ARM 状态。从 Thumb 到 ARM 或反向的状态切换的方式之一，就是修改这一标志位。</li><li>M(模式标志位， Mode Bit)：这几位指定当前的特权模式（USR、SVC 等）。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">        31          26      15      10              9       5               4           0</span><br><span class="line">CPSR    |cond.flags |       |1T     |大小端标志位E    |       |Thumb标志位T    |模式标志位M  |</span><br></pre></td></tr></table></figure><p>------------------------更新时间 2018-10-18 09:30</p><h3 id="系统级控制与设置"><a class="markdownIt-Anchor" href="#系统级控制与设置"></a> 系统级控制与设置</h3><p><code>ARM</code>提供了协处理器的概念来支持额外的指令和系统级设置。举例来说，如果系统支持内存管理单元(<code>MMU, Memory Management Unit</code>)，那么内存管理单元的配置接口必须提供给启动代码或内核代码。在<code>x86/x64</code>上，这些设置接口是放在<code>CR0</code>和<code>CR4</code>中的；而在<code>ARM</code>上，则放在<code>CP15</code>中，<code>ARM</code>体系结构中有<code>16</code>个协处理器，编号为<code>CP0~CP15</code>.前 13 个协处理器时可选的或者是<code>ARM</code>保留的。制造商可以通过可选协处理器实现特定的指令或功能，每个协处理器提供了额外的“操作码”和寄存器，可以通过专门的<code>ARM</code>指令控制。举例来说，<code>CP10</code>和<code>CP11</code>常常用于调试和系统设置。而且<code>CP15</code>通常被称为系统控制协处理器，它保存着绝大多数系统设置（缓存、分页、异常等）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：NEON提供了单指令多数据（SIMD）指令集，通常用于多媒体应用程序。它与基于x86体系结构的SSE/MMX指令类似。</span><br></pre></td></tr></table></figure><p>每个协处理器有<code>16个寄存器</code>和<code>8个相应的操作码</code>。这些寄存器和操作码的语义是特定于协处理器的。协处理器只能通过<code>MRC</code>(读)和<code>MCR</code>(写)指令访问，这两个指令接受协处理器编号、寄存器编号和操作码作为参数。举例来说，要读出转换基址寄存器(类似于<code>x86/x64</code>中的<code>CR3</code>)并保存到<code>R0</code>中，可以使用如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MRC p15, 0, r0, c2, c0, 0 ; 保存到TTBR中</span><br></pre></td></tr></table></figure><p>这句代码表示：“使用操作码<code>0/0</code>读出<code>CP15</code>的<code>C2/C0</code>，并保存结果到通用寄存器<code>R0</code>。”因为每个协处理器有很多寄存器和操作码，需要阅读文档才能确定其中每一个的精确含义。有些寄存器（<code>C13/C0</code>）是操作系统保留的，用于保存特定于进程或线程的数据。</p><p><code>MRC</code>和<code>MCR</code>指令并不需要高特权级别才能运行（也就是说，可以在 USR 模式下执行），但有些协处理器寄存器和操作码只能在<code>SVC</code>模式下访问，如果没有足够的特权级别，该寄存器会导致异常。在实际的用户模式代码中很少看到这些指令，他们通常用在像<code>ROM</code>、<code>bootloader</code>、固件这样很底层的代码或内核模式代码中。<br>------------------------更新时间 2018-10-21 13:10</p><h3 id="指令集介绍"><a class="markdownIt-Anchor" href="#指令集介绍"></a> 指令集介绍</h3><p>相比起<code>x86</code>体系结构，除了条件执行和桶式移位器，ARM 的指令集还有几点独特之处。首先，有些指令可以一次操作一系列寄存器。比如要把 5 个寄存器<code>R6~R10</code>保存到<code>R1</code>指向的一段内存位置，可以使用指令<code>STM R1,&#123;R6-R10&#125;</code>。<code>R6</code>会保存到内存地址<code>R1</code>，<code>R7</code>保存到<code>R1+4</code>，<code>R8</code>保存到<code>R1+8</code>，以此类推。对于不连续的寄存器，可以用逗号分隔（比如<code>&#123;R1,R5,R8&#125;</code>）。<code>ARM</code>的汇编语法中，寄存器范围通常用花括号表示。其次，有些指令在读写操作之后可能会更新基址寄存器，这通常通过在寄存器名后添加感叹号<code>!</code>来表示。举例来说，如果把前面的指令改写为<code>STM R1!, &#123;R6-R10&#125;</code>并执行，那么<code>R1</code>将会被更新为保存<code>R10</code>的地址之后的下一个地址。<br>------------------------更新时间 2018-10-22 08:10</p><h3 id="数据加载与存储"><a class="markdownIt-Anchor" href="#数据加载与存储"></a> 数据加载与存储</h3><p><code>ARM</code>是一种<code>加载-存储式</code>的体系结构，这意味着数据一定要加载到寄存器中才能操作。只有加载和存储指令能够访问内存，所有其他指令都只能操作寄存器。加载是指从内存中读入数据并保存到寄存器中的过程，存储则是指把寄存器的内容写入内存中的过程。在<code>ARM</code>体系结构中，加载和存储指令包括<code>LDR/STR</code>、<code>LDM/STM</code>和<code>PUSH/POP</code>。</p><h4 id="ldr-与-str"><a class="markdownIt-Anchor" href="#ldr-与-str"></a> LDR 与 STR</h4><p><code>LDR/STR</code>指令比较基础的形式是，接受一个基址寄存器和一个偏移量作为参数。偏移量的表示有三种格式（立即数、寄存器、标量寄存器），每种格式有三种寻址形式。</p><p>第一种形式使用立即数作为偏移量。立即数就是一个整数。把这个数字与基址寄存器相加或相减，用于访问编译期偏移量可知的数据。立即数最常见的用途是访问结构或虚函数表中的某个特定字段。一般形式：</p><ul><li><code>STR Ra, [Rb, imm]</code></li><li><code>LDR Ra, [Rc, imm]</code><br><code>Rb</code>是基址寄存器，<code>imm</code>是要加到<code>Rb</code>的偏移量</li></ul><p>第二种偏移量格式用一个寄存器作为偏移量，通常用于访问数组中的元素，其索引值是运行时计算出的情况。其一般格式如下：</p><ul><li><code>STR Ra, [Rb, Rc]</code></li><li><code>LDR Ra, [Rb, Rc]</code><br>根据上下文的不同，<code>Rb</code>或<code>Rc</code>可以是基址或偏移量。</li></ul><p>第三种偏移量格式是使用标量寄存器作为偏移量。通常这种形式用在数组的迭代循环，而桶式移位器用于计算偏移量的步长。这种格式的一般形式如下：</p><ul><li><code>STR Ra, [Rb, Rc, &lt;shifter&gt;]</code></li><li><code>LDR Ra, [Rb, Rc, &lt;shifter&gt;]</code><br>Rb 是基址寄存器，Rc 是一个立即数，<code>&lt;shifter&gt;</code>是在立即数上执行的操作，他通常通过一个左移或右移操作对立即数进行成比例放大或缩小。</li></ul><p>------------------------更新时间 2018-10-23 07:30</p><h4 id="ldr-的其他用途"><a class="markdownIt-Anchor" href="#ldr-的其他用途"></a> LDR 的其他用途</h4><p><code>LDR</code>用于从内存向寄存器中加载数据，但有时候会看到这样的形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">01: DF F8 50 82 LDR.W R8, =0x2932E00 ; LDR R8, [PC, x]</span><br><span class="line">02: 80 4A LDR R2, =a04d ; &quot;%04d&quot; ; LDR R2, [PC, y]</span><br><span class="line">03: 0E 4B LDR R3, =__imp_realloc ; LDR R3, [PC, z]</span><br></pre></td></tr></table></figure><p>伪指令内部使用了立即数寻址形式的<code>LDR</code>指令，<code>PC</code>作为基址寄存器。有时这也成为<code>PC</code>相对寻址（或在<code>x64</code>上称为<code>RIP</code>相对寻址）。<code>ARM</code>二进制文件通常有一个文本池（<code>literal pool</code>），这是某个字段中的一块内存区域，用于保存常量、字符串和用于提供位置无关索引支持的偏移量。（文本池是代码的一部分，所以在同一段中。）在前面的代码片段里，代码引用了保存在文本池中的一个<code>32</code>位常量、一个字符串和一个导入函数的偏移量。利用这种伪指令，可以只通过一个指令就把 32 位常量移入寄存器，因此它是很有用的。为了更清晰一点，下面给出一段代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">01: .text:0100B134 35 4B LDR R3, =0x68DB8BAD</span><br><span class="line">; 实际上就是LDR R3, [PC, #0xD4]</span><br><span class="line">; 这时PC = 0x0100B138</span><br><span class="line">02: ...</span><br><span class="line">03: .text:0100B20C AD 8B DB 68  dword_100B20C DCD 0x68DB8BAD</span><br></pre></td></tr></table></figure><p>因为代码处于<code>Thumb</code>状态，<code>PC</code>值是当前指令加上<code>4</code>，也就是<code>0x0100B138</code>。这里使用了立即数寻址方式，所以要读出位于<code>0x0100B20C</code>（<code>=0x0100B138+0x4D</code>）的字，这就是我们想要加载的常量。<br>------------------------更新时间 2018-10-26 07:00</p><h4 id="ldm-与-stm"><a class="markdownIt-Anchor" href="#ldm-与-stm"></a> LDM 与 STM</h4><p><code>LDM</code>和<code>STM</code>与<code>LDR/STR</code>类似，区别是前者可以从给定的基址寄存器加载多个字。<code>LDM</code>和<code>STM</code>通常用于从内存读出或写入多个数据块，通常语法为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDM&lt;mode&gt; Rn[!], &#123;Rm&#125;</span><br><span class="line">STM&lt;mode&gt; Rn[!], &#123;Rm&#125;</span><br></pre></td></tr></table></figure><p><code>Rn</code>是基址寄存器，其中保存要加载/存储的内存地址。<code>！</code>是可选的，意思是基址寄存器会更新为新的地址（写回）。<code>Rm</code>是要加载或存储的范围。<code>LDM</code>和<code>STM</code>有四种模式。</p><ul><li>IA（后递增，Increment After）模式把数据存储到基址寄存器指定的内存位置。如果有写回的话，就写回最后一个地址加 4 字节的地址。如果没有指定的话，这是默认使用的模式。</li><li>IB（前递增，Increment Before）模式把数据存储在基址寄存器加 4 的地址上。如果有写会的话，就把最后地址写回。</li><li>DA（后递减，Decrement After）模式保存数据使得最后的地址是基地址。如果有写回的话，就把最低地址减 4 写回。</li><li>DB（前递减，Decrement Before）模式存储数据使得最后的地址是基地址减 4.如果有写回的话，就把最低地址写回。</li></ul><p>下面是调试器观察的实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">(gdb) br main</span><br><span class="line">Breakpoint 1 at 0x8344</span><br><span class="line">(gdb) disas main</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">0x00008344 &lt;+0&gt;: ldr r6, =mem ; 稍有修改</span><br><span class="line">0x00008348 &lt;+4&gt;: mov r0, #10</span><br><span class="line">0x0000834c &lt;+8&gt;: mov r1, #11</span><br><span class="line">0x00008350 &lt;+12&gt;: mov r2, #12</span><br><span class="line">0x00008354 &lt;+16&gt;: ldm r6, &#123;r3,r4,r5&#125; ; IA模式</span><br><span class="line">0x00008358 &lt;+20&gt;: stm r6, &#123;r0,r1,r2&#125; ; IA模式</span><br><span class="line">...</span><br><span class="line">(gdb) r</span><br><span class="line">Breakpoint 1, 0x00008344 in main ()</span><br><span class="line">(gdb) si</span><br><span class="line">0x00008348 in main ()</span><br><span class="line">(gdb) x/3x $r6</span><br><span class="line">0x105c &lt;mem&gt;: 0x00000001 0x00000002 0x00000003</span><br><span class="line">(gdb) si</span><br><span class="line">0x0000834c in main ()</span><br><span class="line">...</span><br><span class="line">(gdb)</span><br><span class="line">0x00008358 in main ()</span><br><span class="line">(gdb) info reg r3 r4 r5</span><br><span class="line">r3 0x1 1</span><br><span class="line">r4 0x2 2</span><br><span class="line">r5 0x3 3</span><br><span class="line">(gdb) si</span><br><span class="line">0x0000835c in main ()</span><br><span class="line">(gdb) x/3x $r6</span><br><span class="line">0x1050c &lt;mem&gt;: 0x0000000a 0x0000000b 0x0000000c</span><br></pre></td></tr></table></figure><p>第 5 行把一个内存地址写入<code>R6</code>，这个内存地址（<code>0x1050c</code>）的内容是一个 3 字数据（第 17 行）。6-8 行将<code>R2～R0</code>设置为某个常量。第 9 行加载从<code>R6</code>指向的内存地址开始的 3 个字到<code>R3～R5</code>。如第 24 ～ 26 行所示，<code>R3～R5</code>的内容正是期望值。第 10 行存储<code>R0~R2</code>到<code>R6</code>指向的内存地址开始的空间。第 29 行显示了期望的写入值。下图展示前面的操作结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> mem</span><br><span class="line">|---|</span><br><span class="line">| 0x1 |  |  | ldr r6, =mem |</span><br><span class="line">| --- ||| mov r0, #10</span><br><span class="line">| 0x2 |  |  | mov r1, #11 |</span><br><span class="line">| --- ||| mov r2, #12</span><br><span class="line">| 0x3 |  |  | ldm r6, &#123;r3,r4,r5&#125; |</span><br><span class="line">| --- |\/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">|---|</span><br><span class="line">| 0x1 | r6 |  | stm r6, &#123;r0,r1,r2&#125; |</span><br><span class="line">| --- |||</span><br><span class="line">| 0x2 | r6+4 |  |</span><br><span class="line">| --- |||</span><br><span class="line">| 0x3 | r6+8 |  |</span><br><span class="line">| --- |\/</span><br><span class="line">r0=a r1=b r2=c</span><br><span class="line">r3=1 r4=2 r5=3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">|---|</span><br><span class="line">| 0xA | r6   |</span><br><span class="line">| --- |</span><br><span class="line">| 0xB | r6+4 |</span><br><span class="line">| --- |</span><br><span class="line">| 0xC | r6+8 |</span><br><span class="line">| --- |</span><br><span class="line">r0=a r1=b r2=c</span><br><span class="line">r3=1 r4=2 r5=3</span><br></pre></td></tr></table></figure><p>下面用写回模式做同样的实验：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">(gdb) br main</span><br><span class="line">Breakpoint 1 at 0x8344</span><br><span class="line">(gdb) disaa main</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">0x00008344 &lt;+0&gt;: ldr r6, =mem ; 稍有修改</span><br><span class="line">0x00008348 &lt;+4&gt;: mov r0, #10</span><br><span class="line">0x0000834c &lt;+8&gt;: mov r1, #11</span><br><span class="line">0x00008350 &lt;+12&gt;:mov r2, #12</span><br><span class="line">0x00008354 &lt;+16&gt;:ldm r6!, &#123;r3, r4, r5&#125; ; IA带写回模式</span><br><span class="line">0x00008358 &lt;+20&gt;:stmia r6!, &#123;r0, r1, r2&#125; ; IA带写回模式</span><br><span class="line">...</span><br><span class="line">(gdb) r</span><br><span class="line">Breakpoint 1, 0x0008344 in main ()</span><br><span class="line">(gdb) si</span><br><span class="line">0x00008348 in main ()</span><br><span class="line">...</span><br><span class="line">(gdb)</span><br><span class="line">0x00008354 in main ()</span><br><span class="line">(gdb) x/3x $r6</span><br><span class="line">0x1050c &lt;mem&gt;： 0x000001 0x00000002 0x00000003</span><br><span class="line">(gdb) si</span><br><span class="line">0x00008358 in main ()</span><br><span class="line">(gdb) info reg r6</span><br><span class="line">r6 0x10518 66840</span><br><span class="line">(gdb) si</span><br><span class="line">0x0000835c in main ()</span><br><span class="line">(gdb) info reg $r6</span><br><span class="line">r6 0x10524 66852</span><br><span class="line">(gdb) x/4x $r6-12</span><br><span class="line">0x10518 : 0x0000000a 0x0000000b 0x0000000c</span><br></pre></td></tr></table></figure><p><code>0x00000000</code></p><p>第 9 行使用<code>IA</code>写回模式，所以<code>R6</code>更新为最后地址加 4 的值（第 23 行）。第 10 行、27 行和 30 行可以看到同样的模式。下图展示了实验代码片段执行的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> mem</span><br><span class="line">|---|</span><br><span class="line">| 0x1 | 0x1050c |  | ldr r6, =mem |</span><br><span class="line">| --- ||| mov r0, #10</span><br><span class="line">| 0x2 | 0x1050c+4 |  | mov r1, #11 |</span><br><span class="line">| --- ||| mov r2, #12</span><br><span class="line">| 0x3 | 0x1050c+8 |  | ldm r6!, &#123;r3,r4,r5&#125; |</span><br><span class="line">| --- |0x1050c+c \/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">|---|</span><br><span class="line">| 0x1 | 0x1050c |  | stm r6, &#123;r0,r1,r2&#125; |</span><br><span class="line">| --- |||</span><br><span class="line">| 0x2 | 0x1050c+4 |  |</span><br><span class="line">| --- |||</span><br><span class="line">| 0x3 | 0x1050c+8 |  |</span><br><span class="line">| --- |0x1050c+c r6 \/</span><br><span class="line">r0=a r1=b r2=c</span><br><span class="line">r3=1 r4=2 r5=3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">|---|</span><br><span class="line">| 0x1 | 0x1050c       |</span><br><span class="line">| --- |</span><br><span class="line">| 0x2 | 0x1050c+4     |</span><br><span class="line">| --- |</span><br><span class="line">| 0x3 | 0x1050c+8     |</span><br><span class="line">| --- |</span><br><span class="line">| 0xA | 0x1050c+c     |</span><br><span class="line">| --- |</span><br><span class="line">| 0xB | 0x1050c+10    |</span><br><span class="line">| --- |</span><br><span class="line">| 0xC | 0x1050c+14    |</span><br><span class="line">| --- | 0x1050c+18 r6 |</span><br></pre></td></tr></table></figure><p><code>LDM</code>和<code>STM</code>指令可以一次写入多个字，所以通常用于块复制和块移动操作。比如有时用这些指令来执行编译时复制长度已知的内联<code>memcpy</code>。这类似于<code>x86</code>中带有<code>REP</code>前缀的<code>movs</code>指令。</p><ul><li>注意<br><code>STM/LDM</code>后面经常会出现后缀<code>FD</code>、<code>FA</code>、<code>ED</code>或<code>EA</code>。它们就是不同模式下（<code>IA/IB</code>等）的<code>STM/LDM</code>指令的伪指令，分别对应于<code>STMFD/STMDB</code>、<code>STMFA/STMIB</code>、<code>STMED/STMDA</code>、<code>STMEA/STMIA</code>、<code>LDMFD/LDMIA</code>、<code>LDMFA/LDMDA</code>和<code>LDMEA/LDMDB</code>。因为这些对应关系太难记忆，建议为每个指令画一个图。</li></ul><p>------------------------更新时间 2018-11-4 08:00</p><h4 id="push-与-pop"><a class="markdownIt-Anchor" href="#push-与-pop"></a> PUSH 与 POP</h4><p>加载/存储指令的最后一组是<code>PUSH</code>和<code>POP</code>。他们类似于<code>LDM/STM</code>，但有两点不同：</p><ul><li>他们隐式地使用 SP 作为基地址；</li><li>SP 会自动更新。</li></ul><p>和<code>x86/x64</code>中的一样，栈是朝下向低地址方向增长的。通用的语法是<code>PUSH/POP &#123;Rn&#125;</code>,其中<code>Rn</code>可以是一个寄存器范围。</p><p><code>PUSH</code>指令把一个或多个寄存器保存在栈中，使得最后一个的位置位于当前栈指针向下 4 字节处，然后把<code>SP</code>更新为第一个位置的地址。<code>POP</code>从当前栈指针处开始向寄存器加载数据，然后更新<code>SP</code>为最后一个位置的地址的向上 4 字节处。<code>PUSH/POP</code>实际上就是以<code>SP</code>作为基地址指针的带写回的<code>STMDB/LDMIA</code>。</p><p>最常用到<code>PUSH/POP</code>的地方就是在函数的起始和结束处，在这里他们被用作函数序言和尾声（就像<code>ARM</code>状态下的<code>STMFD/LDMFD</code>一样）。举例来说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2D E9 F0 4F PUSH.W &#123;R4-R11, LR&#125; ; 保存寄存器和返回地址</span><br><span class="line">...</span><br><span class="line">BD E9 F0 8F POP.W &#123;R4-R11, PC&#125; ; 恢复寄存器值并返回</span><br></pre></td></tr></table></figure><p>------------------------更新时间 2018-11-5 07:00</p><h3 id="函数与函数调用"><a class="markdownIt-Anchor" href="#函数与函数调用"></a> 函数与函数调用</h3><p><code>x86/x64</code>只有一个用于函数调用的指令（<code>CALL</code>）和一个用于分支跳转的指令（<code>JMP</code>）。与之不同，根据目标地址的编码方式，ARM 则提供了多种指令。调用函数的时候，处理器需要知道函数返回后从哪里继续执行，这个位置通常被称为返回地址。在<code>x86</code>中，<code>CALL</code>指令在跳转到目标函数之前隐式地把返回地址压入栈顶，等到目标函数执行完毕，会把栈顶弹出到<code>EIP</code>，从而从返回地址恢复执行。</p><p><code>ARM</code>体系结构上的机制本质上也是如此，只有几点微小的区别。首先，返回地址可以保存在栈上，也可以保存在链接寄存器（<code>LR</code>）中；调用结束后要恢复执行，需要显式地把返回地址从栈上弹出到<code>PC</code>寄存器，否则会无条件跳转到<code>LR</code>。其次，根据目标地址的最低位（<code>LSB</code>）不同，一次分支跳转可以在<code>ARM</code>状态和<code>Thumb</code>状态之间切换。第三点，<code>ARM</code>定义了标准调用惯例：前 4 个 32 位参数通过寄存器（<code>R0-R3</code>）传递，其余的参数放在栈上。返回值保存在<code>R0</code>中。</p><p><code>ARM</code>中函数调用的指令是<code>B</code>、<code>BX</code>、<code>BL</code>和<code>BLX</code>。</p><p>尽管在函数调用的上下文中很少看到<code>B</code>指令，但这条指令确实可以用于控制传递。他就是一条简单的无条件跳转指令，于<code>x86</code>中的<code>JMP</code>指令相同，通常在循环和条件执行内部用于跳转到开头或跳出循环，还可以用于调用永不返回的函数。</p><p><code>B</code>指令只能使用标签偏移量作为其目标地址，而不能使用寄存器。在这种情况下，<code>B</code>指令的语法为<code>B imm</code>，其中<code>imm</code>是相对于当前指令的偏移量。（这里没有考虑条件执行标志位，将会在之后的笔记中详细介绍。）需要记住的是：因为<code>ARM</code>和<code>Thumb</code>指令是<code>2字节</code>或<code>4字节</code>对齐的，所以目标偏移量必须是一个偶数。</p><p><code>BX</code>是分支跳转并交换（<code>Branch and Exchange</code>）。与<code>B</code>指令的相似之处在于，两者都是把控制转移到某个目标地址处，但<code>BX</code>能够在<code>ARM</code>和<code>Thumb</code>状态间切换，并且目标地址是保存在寄存器中的。分支跳转指令以<code>X</code>结尾，表示这条指令能切换状态。如果目标地址最低位是 1，那么处理器会自动切换到<code>Thumb</code>状态，否则就执行在<code>ARM</code>状态。指令的格式是<code>BX&lt;寄存器&gt;</code>，其中寄存器中存有目标地址。这条指令有两种最常用的方式，一种是通过跳转到<code>LR</code>（也即 <code>BX LR</code>）从函数返回，还有一种是用于切换到不同状态的代码（也即从<code>ARM</code>切换到<code>Thumb</code>状态或反之）。在编译后的代码中，函数结尾处几乎总会出现<code>BX LR</code>，基本上于<code>x86</code>中的<code>RET</code>相同。</p><p><code>BL</code>是分支跳转并连接（<code>Branch with Link</code>），它类似于<code>B</code>指令，但他可以在把控制切换到目标偏移量之前把返回地址保存到<code>LR</code>。这也许是和<code>x86</code>中的<code>CALL</code>指令最为接近的一条指令，经常在函数调用中使用。<code>BL</code>指令格式与<code>B</code>指令相同（也就是说，只接受偏移量参数）。下面这段代码解释了函数调用和返回的过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">00014350 BL foo ; LR = 0x00014354</span><br><span class="line">00014354 MOVS R4, #0x15</span><br><span class="line">...</span><br><span class="line">0001B224 foo</span><br><span class="line">0001B224 PUSH &#123;R1-R3&#125;</span><br><span class="line">0001B226 MOV R3, 0x6124</span><br><span class="line">...</span><br><span class="line">0001B24C BX LR ; 返回到0x00014354</span><br></pre></td></tr></table></figure><p>上面代码的第 1 行使用<code>BL</code>调用函数<code>foo</code>。在转换控制到目标之前，<code>BL</code>在<code>LR</code>中保存了返回地址（<code>0x000014354</code>）。<code>foo</code>做了一些工作然后返回到调用者（<code>BX LR</code>）。</p><p><code>BLX</code>是指跳转加连接和交换（<code>Branch with Link and Exchange</code>）。于<code>BL</code>类似，<code>BLX</code>也可以支持状态切换。两者主要的区别在于，<code>BLX</code>可以接受偏移量或寄存器作为跳转目标，而且在<code>BLX</code>指令使用偏移量的情况下，处理器总是会切换状态（<code>ARM</code>到<code>Thumb</code>或反之）。因为这条指令于<code>BL</code>的特性相同，也可以把它当做<code>x86</code>中的<code>CALL</code>指令。实际使用中，<code>BL</code>和<code>BLX</code>都用于实现函数调用。如果函数在<code>32MB</code>范围之内，通常使用<code>BL</code>，而目标区域不确定（比如函数指针）的时候常用<code>BLX</code>。通常在<code>Thumb</code>状态下运行的时候，使用<code>BLX</code>指令调用库例程，而在<code>ARM</code>状态下使用<code>BL</code>。</p><p>------------------------更新时间 2018-11-9 07:00</p><h3 id="算术运算"><a class="markdownIt-Anchor" href="#算术运算"></a> 算术运算</h3><p>把数值从内存加载到寄存器之后，代码就可以上面执行各种操作了。最简单的操作就是通过<code>mov</code>指令把数据移动到另一个寄存器中。操作源可以是常量、寄存器或桶式移位器的运算结果。桶式移位器运算包括左移（<code>LSL</code>）、右移（<code>LSR</code>、<code>ASR</code>）和循环移位（<code>ROR</code>、<code>RRX</code>）。桶式移位器让指令可以操作无法以立即数形式编码的常量，因此很有用处。<code>ARM</code>和<code>Thumb</code>指令的宽度可能是<code>16</code>位或<code>32</code>位，所以无法直接使用<code>32</code>位常数作为参数。有了桶式移位器，立即数可以被转换为一个更大值然后移动到其他寄存器。另一种移动<code>32</code>位常量到寄存器的方法是把常量分割为两个<code>16位</code>数值，分两次移动；这通常通过<code>MOVW</code>和<code>MOVT</code>指令实现。<code>MOVT</code>设置寄存器的<code>高16位</code>，<code>MOVW</code>设置<code>低16位</code>。</p><p>基本算术和逻辑运算包括<code>ADD</code>、<code>SUB</code>、<code>MUL</code>、<code>AND</code>、<code>ORR</code>和<code>EOR</code>。</p><p>注意：<code>ARM</code>没有原生的除法指令。（<code>ARMv7-R</code>和<code>ARMv7-M</code>内核有<code>SDIV</code>和<code>UDIV</code>指令，但这里不讨论）实际应用中，运行时会使用软件实现来进行除法运算，代码只要按需调用。下面是<code>Windows C</code>运行时的一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">41 46 MOV R1， R8</span><br><span class="line">40 46 MOV R0,R6</span><br><span class="line">35 F0 9E 9F BL __rt_udiv ; udiv的软件实现</span><br></pre></td></tr></table></figure><p>------------------------更新时间 2018-11-11 07:00</p><h3 id="分支跳转与条件执行"><a class="markdownIt-Anchor" href="#分支跳转与条件执行"></a> 分支跳转与条件执行</h3><p>前面讨论的都是按照线性顺序执行的例子，而绝大多数程序都包含有条件与循环。在汇编代码层级，这些结构是通过存储在应用程序状态寄存器（<code>APSR</code>）中的条件标志位实现的。<code>APSR</code>是<code>CPSR</code>的别名，类似于<code>x86</code>中的<code>EFLAG</code>寄存器。</p><ul><li>N（Negative，负值标志位）：如果运算的结果是负数，这个标志就会被设置（结果的最高有效位为 1）</li><li>Z（Zero，零标志位）：运算结果为 0 时设置</li><li>C（Carry，借位标志位）：两个无符号值计算结果溢出时设置</li><li>V（Overflow，溢出标志位）：两个有符号值计算结果溢出时设置</li><li>IT（If-then 标志位）：这些标志位编码了 Thumb 指令 IT 使用的各种条件。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        31          26      15      10              9       5               4           0</span><br><span class="line">CPSR    |cond.flags |       |1T     |大小端标志位E    |       |Thumb标志位T    |模式标志位M  |</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">APSR |N|Z|C|V|Q  |       |保留|</span><br><span class="line"> 31 26 15 0</span><br></pre></td></tr></table></figure><p>N、Z、C 和 V 标志位与 x86 中的 EFLAG 寄存器的 SF、ZF、CF 和 OF 标志位相同。在更高级的语言中，使用这些标志位来实现条件和循环；在指令级代码中，也通过这些标志位支持条件执行。通过这些标志位来描述相等性。</p><table><thead><tr><th style="text-align:left">后缀/编码</th><th style="text-align:left">意义</th><th style="text-align:left">标志位</th></tr></thead><tbody><tr><td style="text-align:left">EQ</td><td style="text-align:left">等于</td><td style="text-align:left">Z==1</td></tr><tr><td style="text-align:left">NE</td><td style="text-align:left">不等于</td><td style="text-align:left">Z==0</td></tr><tr><td style="text-align:left">MI</td><td style="text-align:left">减、负</td><td style="text-align:left">N==1</td></tr><tr><td style="text-align:left">PL</td><td style="text-align:left">加、正或者为 0</td><td style="text-align:left">N==0</td></tr><tr><td style="text-align:left">HI</td><td style="text-align:left">无符号大于</td><td style="text-align:left">C<mark>1 且 Z</mark>0</td></tr><tr><td style="text-align:left">LS</td><td style="text-align:left">无符号小于</td><td style="text-align:left">C<mark>0 或 Z</mark>1</td></tr><tr><td style="text-align:left">GE</td><td style="text-align:left">有符号大于等于</td><td style="text-align:left">N==V</td></tr><tr><td style="text-align:left">LT</td><td style="text-align:left">有符号小于</td><td style="text-align:left">N！=V</td></tr><tr><td style="text-align:left">GT</td><td style="text-align:left">有符号大于</td><td style="text-align:left">Z<mark>0 且 N</mark>V</td></tr><tr><td style="text-align:left">LE</td><td style="text-align:left">有符号小于等于</td><td style="text-align:left">Z==1 或 N！=V</td></tr></tbody></table><p>默认情况下指令不会更新条件标志位，除非使用了 S 后缀。比较指令（CBZ、CMP、TST、CMN 和 TEO）会自动更新标志位，因为通常他们被用于分支指令之前。</p><p>最常用的比较指令可能就是 CMP。其语法为 CMP Rn, X，其中 Rn 是寄存器，X 可以是立即数、寄存器或桶式移位操作。其语义与 x86 中的同名指令相同：执行 Rn - X，设置相应的标志位，然后丢弃结果。通常这条指令后面会跟随一个条件分支跳转。下面是一个用法示例及其伪代码：<br>ARM</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">B3 EB E7 7F CMP.W  R3, R7, ASR #31</span><br><span class="line">05 DB BLT  loc_less</span><br><span class="line">01 DC  BGT  loc_greater</span><br><span class="line">BD 42 CMP  R5, R7</span><br><span class="line">02 D9  BLS  loc_less</span><br><span class="line"> loc_greater</span><br><span class="line">07 3D  SUBS  R5, #7</span><br><span class="line">6E F1 00 0E  SBC.W  LR, LR, #0</span><br><span class="line"> loc_less</span><br><span class="line">A5 FB 08 12  UMULL.W R1, R2, R5, R8</span><br><span class="line">87 FB 08 04  SMULL.W R0, R4, R7, R8</span><br><span class="line">0E FB 08 23  MLA.W  R3, LR, R8, R2</span><br></pre></td></tr></table></figure><p>C 伪代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (r3 &lt; r7) &#123;goto loc_less;&#125;</span><br><span class="line"> else if (r3 &gt; r7) &#123;goto loc_greater;&#125;</span><br><span class="line"> else if (r5 &lt; r7) &#123;goto loc_less;&#125;</span><br></pre></td></tr></table></figure><p>------------------------更新时间 2018-11-12 07:00</p><h4 id="thunb-状态"><a class="markdownIt-Anchor" href="#thunb-状态"></a> Thunb 状态</h4><h4 id="switch-case"><a class="markdownIt-Anchor" href="#switch-case"></a> switch-case</h4><h3 id="杂项"><a class="markdownIt-Anchor" href="#杂项"></a> 杂项</h3><h2 id="windows-内核"><a class="markdownIt-Anchor" href="#windows-内核"></a> Windows 内核</h2><h2 id="调试与自动化"><a class="markdownIt-Anchor" href="#调试与自动化"></a> 调试与自动化</h2><h2 id="代码混淆"><a class="markdownIt-Anchor" href="#代码混淆"></a> 代码混淆</h2><h2 id="代码研究"><a class="markdownIt-Anchor" href="#代码研究"></a> 代码研究</h2><h3 id="windows-内核代码"><a class="markdownIt-Anchor" href="#windows-内核代码"></a> windows 内核代码</h3><p>片段 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">; NTSTATUS __cdecl sub_4038f0(PFILE_OBJECT FileObject, HANDLE Handle, BOOLEAN flag)</span><br><span class="line">sub_4038F0 proc near</span><br><span class="line">push rbx ; rbx压栈</span><br><span class="line">push rbp ; rbp压栈</span><br><span class="line">push rsi ; rsi压栈</span><br><span class="line">push rdi ; rdi压栈</span><br><span class="line">push r12 ; r12压栈</span><br><span class="line">sub rsp, 60h ; rsp的值减去0x60</span><br><span class="line">mov bpl, r8b ; r8p的值入bpl</span><br><span class="line">mov r12, rdx ; 将rdx的值放进栈r12中</span><br><span class="line">mov rdi, rcx ; 将rcx的值放进栈rdi中</span><br><span class="line">mov cs:IoGetRelatedDeviceObject ; IoGetRelatedDeviceObject返回值指向相应设备对象的指针</span><br><span class="line">mov [rsp+88h+arg_18], 1 ; 把1赋给[rsp+88h+arg_18]</span><br><span class="line">xor edx, edx ; ChargeQuota 将edx初始化置0</span><br><span class="line">mov cl, [rax+4ch] ; StackSize 栈空间大小</span><br><span class="line">mov rsi, rax ; 将rax的值放进栈rsi中</span><br><span class="line">call cs:IoAllocateIrp ; IoAllocateIrp例程分配一个IRP（为每个驱动层下的调用者给定I/O堆栈数量和选项）</span><br><span class="line">test rax, rax ; 相当于and rax rax，根据结果设置标志位，不会保存结果。（影响标志位C,O,P,Z,S。其中C与O两个标志会被设为0）</span><br><span class="line">mov rbx, rax ; 将rax的值放进栈rbx中</span><br><span class="line">jnz short loc_403932 ; 如果Z标志位为0，就跳转到loc_403932中</span><br><span class="line">mov eax, 0C0000017h ; 把立即数0C0000017h放进eax（此处用来表示跳转失败）。立即数必须以数开头，以字母开头会被认为是寄存器或变量。</span><br><span class="line">jmp loc_403A0C ; 无条件跳转到 loc_403A0C方法（loc_403A0C方法的作用是清理栈空间）</span><br><span class="line">loc_403932:</span><br><span class="line">lea rax, [rsp+88h+arg_18] ; rax获取[rsp+88h+arg_18]的地址</span><br><span class="line">xor r8d, r8d ; State 状态值初始化为0</span><br><span class="line">lea rcx, [rsp+88h+Event] ; Event rcx获取[rsp+88h+Event]的地址</span><br><span class="line">mov [rbx+18h], rax ; IRP.AssociatedIrp.SystemBuffer 把rax所指向地址的值赋给[rbx+18h]，也就是把1赋给[rbx+18h]</span><br><span class="line">lea rax, [rsp+88h+Event] ; rax获取[rsp+88h+Event]的地址</span><br><span class="line">lea edx, [r8+1] ; Type 类型 edx获取[r8+1]的地址</span><br><span class="line">mov [rbx+50h], rax ; IRP.UserEvent 把rax所指向[rsp+88h+Event]地址的值赋给[rbx+50h]，作为用户事件</span><br><span class="line">lea rax, [rsp+88h+var_58] ; rax获取[rsp+88h+var_58]的地址</span><br><span class="line">mov [rbx+48h], rax ; IRP.UserIosb 把rax所指向[rsp+88h+var_58]地址的值赋给[rbx+48h]</span><br><span class="line">mov rax, gs:+188h ; KPCR.Prcb.CurrentThread gs寄存器基址+18h得到的地址处的值，赋给rax</span><br><span class="line">mov [rbx+0C0h], rdi ; IRP.Tail.OVerlay.OriginalFileObiect 把寄存器rdi的值（也就是前面rcx的值）放进内存[rbx+48h]中</span><br><span class="line">mov [rbx+98h], rax ; IRP.Tail.Overlay.Thread gs寄存器基址+18h处的值放进内存[rbx+98h]</span><br><span class="line">mov byte ptr [rbx+40h], 0 ; IRP.RequestorMode 把[rbx+40h]处的一个字节填为0</span><br><span class="line">call cs:KeInitializeEvent ; 调用 KeInitializeEvent方法将一个事件对象初始化为一个同步或通知类型的事件，并且设置为一个有信号或无信号的状态</span><br><span class="line">test bpl, bpl ; and bpl bpl，根据结果设置标志位，不会保存结果。C与O会被设置为0.</span><br><span class="line">mov rcx, [rbx+0B8h] ; 将内存[rbx+0B8h]处的值放进rcx中</span><br><span class="line">mov byte ptr [rbx+40h], 6 ; IRP_MJ_SET_INFORMATION 把[rbx+40h]处的一个字节填为6</span><br><span class="line">mov [rcx-20h], rsi ; IO_STACK_LOCATION.DeviceObject 将rsi处的值放进内存[rcx-20h]中</span><br><span class="line">mov [rcx-18h], rdi ; IO_STACK_LOCATION.FileObject 将rdi处的值放进内存[rcx-18h]中</span><br><span class="line">jz short loc_4039A6 ; 如果Z标志位为1，就跳转到loc_4039A6中</span><br><span class="line">mov rax, [rdi+28h] ; FILE_OBJECT.SectionObjectPointer 将内存[rdi+28h]中的值放进rax中</span><br><span class="line">test rax, rax ; and rax rax，根据结果设置标志位，不会保存结果。C与O会被设置为0.</span><br><span class="line">jz short loc_4039A6 ; 如果Z标志位为1，就跳转到loc_4039A6中</span><br><span class="line">mov [rax+10h], 0 ; SECTION_OBJECT_POINTERS.ImageSectionObject 将[rax+10h]置为0</span><br><span class="line">loc_4039A6:</span><br><span class="line">mov [rcx-28h], r12 ; IO_STACK_LOCATION.Parameters.SetFile.DeleteHandle   将寄存器r12中的值放进[rcx-28h]中</span><br><span class="line">mov [rcx-30h], rdi ; IO_STACK_LOCATION.Parameters.SetFile.Object  将寄存器rdi中的值放进[rcx-30h]中</span><br><span class="line">mov dword ptr [rcx-38h], 0Dh ; FileDispositionInformation IO_STACK_LOCATION.Parameters.SetFile.FileInfomationClass 将[rcx-38h]处的双字设置为0Dh</span><br><span class="line">mov dword ptr [rcx-40h],1 ; IO_STACK_LOCATION.Parameters.SetFile.Length  将[rcx-40h]处的双字设置为1</span><br><span class="line">mov rax, [rbx+0b8h] ; CurrentIrpStackLocation 将[rbx+0b8h]处的值放进rax中</span><br><span class="line">lea rcx, sub_4038B4 ; completionroutine rcx获取sub_4038B4的地址</span><br><span class="line">mov [rax-10h], rcx ; IO_STACK_LOCATION.ComplerionRoutine 将rcx指向sub_4038B4的地址处的值放进[rax-10h]中</span><br><span class="line">mov rcx, rsi ; DeviceObject 将rsi处的值放进rcx中</span><br><span class="line">mov rdx, rbx ; Irp 将rbx处的值放进rdx中</span><br><span class="line">mov qword ptr [rax-8], 0 ; 将内存[rax-8]处的双字设置为0</span><br><span class="line">mov byte ptr [rax-45h], 0E0h ; flag 将内存[rax-45h]处的一个字节设置为0</span><br><span class="line">call cs:IofCallDriver ; 调用IofCallDriver方法</span><br><span class="line">cmp eax, 103h ; STATUS_PENDING 比较eax和103h</span><br><span class="line">jnz short loc_403A09 ; 如果eax和103h不相等就跳转到loc_403A09</span><br><span class="line">lea rcx, [rsp+88h+Event] ; Object rcx获取[rsp+88h+Event]的地址</span><br><span class="line">mov r9b, 1 ; Alertable 将r9b赋值为1</span><br><span class="line">xor r8d, r8d ; WaitMode r8d置为0</span><br><span class="line">xor edx, edx ; WaitReason edx置为0</span><br><span class="line">mov [rsp+88h+var_68], 0 ; 将[rsp+88h+var_68]置为0</span><br><span class="line">call cs:KeWaitForSingleObject ; 调用该方法将当前线程(ethread里以Wait开头的字段WaitIrql,WaitMode,WaitStatus)置为等待状态,直到提供的分发机器对象被置为已处理状态或第五个参数给出的Timeout走完。</span><br><span class="line">loc_403A09:</span><br><span class="line">mov eax, [rbx+30h] ; IRP.IoStatus.Status 将内存[rbx+30h]处的值赋给eax</span><br><span class="line">loc_403A0C: ; 清理栈</span><br><span class="line">add rsp, 60h ; 栈指针rsp+60h进行复位</span><br><span class="line">pop r12 ; 出栈r12</span><br><span class="line">pop rdi ; 出栈rdi</span><br><span class="line">pop rsi ; 出栈rsi</span><br><span class="line">pop rbp ; 出栈rbp</span><br><span class="line">pop rbx ; 出栈rbx</span><br><span class="line">retn</span><br><span class="line">sub_4038F0 endp</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><div class="article-footer"><blockquote class="mt-2x"><ul class="post-copyright list-unstyled"><li class="post-copyright-link hidden-xs"><strong>本文链接：</strong> <a href="http://debug.cool/2018/10/10/noteReverseEnfineering/" title="逆向笔记梳理" target="_blank" rel="external">http://debug.cool/2018/10/10/noteReverseEnfineering/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！</li></ul></blockquote><div class="panel panel-default panel-badger"><div class="panel-body"><figure class="media"><div class="media-left"><a href="/" target="_blank" class="img-burn thumb-sm visible-lg"><img src="/avatar.png" class="img-rounded w-full" alt=""></a></div><div class="media-body"><h3 class="media-heading"><a href="/" target="_blank"><span class="text-dark">ClanceyHuang</span><small class="ml-1x">Low Level Researcher</small></a></h3><div>为人治学当有独立之精神，自由之思想。</div></div></figure></div></div></div></article><section id="comments"><div id="vcomments"></div></section></div><nav class="bar bar-footer clearfix" data-stick-bottom><div class="bar-inner"><ul class="pager pull-left"><li class="prev"><a href="/2019/01/25/tipsPythonMatplotlib/" title="Python可视化绘图"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;Newer</span></a></li><li class="next"><a href="/2018/09/04/noteKernelProgram/" title="如何编写一个简单内核"><span>Older&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a></li><li class="toggle-toc"><a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="Catalogue" role="button"><span>[&nbsp;</span><span>Catalogue</span> <i class="text-collapsed icon icon-anchor"></i> <i class="text-in icon icon-close"></i> <span>]</span></a></li></ul><div class="bar-right"><div class="share-component" data-sites="weibo,qq,qzone,wechat,douban,diandian,facebook,twitter,google,linkedin" data-mobile-sites="weibo,qq,qzone,wechat,douban,facebook,twitter,linkedin"></div></div></div></nav></main><footer class="footer" itemscope itemtype="http://schema.org/WPFooter"><ul class="social-links"><li><a href="https://github.com/ClanceyHuang" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul><div class="copyright">&copy; 2021 ClanceyHuang<div class="publishby">Theme by <a href="https://github.com/cofess" target="_blank">cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.</div></div></footer><script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script><script>window.jQuery||document.write('<script src="js/jquery.min.js"><\/script>')</script><script src="/js/plugin.min.js"></script><script src="/js/application.js"></script><script>!function(t){t(".search-form").on("submit",function(o){var n=t('.search-form-input[name="wd"]').val();return window.location="https://www.baidu.com/s?wd=site:debug.cool "+n,!1})}(jQuery)</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/npm/valine"></script><script type="text/javascript">var GUEST=["nick","mail","link"],meta=(meta="nick,mail,link").split(",").filter(function(e){return-1<GUEST.indexOf(e)});new Valine({el:"#vcomments",verify:!1,notify:!1,appId:"Qqm4Y42SKNlM4BvWNdr9qjwC-gzGzoHsz",appKey:"NeKHjEgYc95FxcuCX3dYtE30",placeholder:"Just go go",avatar:"mm",meta:meta,pageSize:"10",visitor:!1})</script><script defer type="text/javascript">!function(e,a,t,n,g,c){e.GoogleAnalyticsObject=n,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=+new Date,g=a.createElement(t),c=a.getElementsByTagName(t)[0],g.async=1,g.src="//www.google-analytics.com/analytics.js",c.parentNode.insertBefore(g,c)}(window,document,"script","ga"),ga("create","UA-104610957-2","auto"),ga("send","pageview")</script></body></html><script type="text/javascript" src="//cdn.jsdelivr.net/gh/ygbhf/clicklove/clicklove.js"></script>