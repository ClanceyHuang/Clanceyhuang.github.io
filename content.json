{"meta":{"title":"Kirk","subtitle":"debug.cool","description":"debug","author":"ClanceyHuang","url":"http://debug.cool","root":"/"},"pages":[{"title":"About","date":"2021-05-09T16:20:22.483Z","updated":"2021-05-09T16:20:22.483Z","comments":false,"path":"about/index.html","permalink":"http://debug.cool/about/index.html","excerpt":"","text":"Hi, I’m Kirk! 👋 偏向网络安全和数据开发。 🔭 普普通通的代码搬砖工一名，比开发人员多懂一点安全，比网络安全人员多懂一点开发，高不成低不就。 🌱 国内某“末端”邮电学校计算机专业，目前在某Low Tech公司“混日子”。 ⚡ 喜欢小动物，饮食口味偏辣味。 💬 空闲时间爱睡觉、看书等冬眠类型活动。 自研的比较好玩的项目： 🚗 一套支持php-fpm和swoole同时运行或随时切换的 Web开发框架 - Fine 🚕 一套基于有限状态机进行解析自定义表达式计算引擎-DiyExpress 🚙 一套通过训练模型破解验证码的Py脚本集 - AutoCraw（已破解极验4代小滑块） 欢迎一起玩耍、一起搞事~~~ 邮箱： ClanceyHuang#gmail.com ClanceyHuang#outlook.com"},{"title":"Links","date":"2021-05-07T07:30:39.996Z","updated":"2021-05-07T07:30:39.996Z","comments":true,"path":"links/index.html","permalink":"http://debug.cool/links/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2021-05-07T07:30:39.997Z","updated":"2021-05-07T07:30:39.996Z","comments":false,"path":"/404.html","permalink":"http://debug.cool/404.html","excerpt":"","text":""},{"title":"Categories","date":"2021-05-07T07:30:39.997Z","updated":"2021-05-07T07:30:39.997Z","comments":false,"path":"categories/index.html","permalink":"http://debug.cool/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2021-05-07T07:30:39.986Z","updated":"2021-05-07T07:30:39.986Z","comments":false,"path":"tags/index.html","permalink":"http://debug.cool/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-05-07T07:30:39.951Z","updated":"2021-05-07T07:30:39.951Z","comments":false,"path":"repository/index.html","permalink":"http://debug.cool/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"2021HVV漏洞公布","slug":"hvv2021","date":"2021-04-23T07:44:00.000Z","updated":"2021-05-14T12:41:13.577Z","comments":true,"path":"2021/04/23/hvv2021/","link":"","permalink":"http://debug.cool/2021/04/23/hvv2021/","excerpt":"2021护网15天，初步统计公布了47个漏洞，整理如下。","text":"2021护网15天，初步统计公布了47个漏洞，整理如下。 2021.04.08 启明星辰天清汉马 USG 防火墙存在逻辑缺陷漏洞（历史漏洞） | CNVD-2021-17391 启明星辰天清汉马 USG 防火墙存在逻辑缺陷漏洞（历史漏洞） | CNVD-2021-17391 [启明星辰 天清汉马 USG 防火墙 逻辑缺陷漏洞 CNVD-2021-12793 ] 禅道项目管理软件 11.6 | [禅道 11.6 sql注入漏洞] 金山WPS（历史漏洞 CVE-2020-25291） | 通过点击触发 WPS 内置浏览器RCE [金山 WPS 存在远程堆损坏漏洞] 金山 V8/V9 终端安全系统 | [金山 V8 -V9 终端安全系统漏洞合集] 金山 V8 终端安全系统 | [金山 V8 终端安全系统 pdf maker.php 命令执行漏洞] 天擎 | [天擎越权访问] 致远OA | [致远OA ajax.do 任意文件上传漏洞] 致远OA | [致远OA 前台 getshell 复现][致远OA任意文件上传] 齐治堡垒机 | 存在命令执行漏洞，POC疑似已流出 深信服EDR（历史漏洞） | [深信服EDR远程命令执行 CNVD-2020-46552] 深信服VPN（历史漏洞） | [深信服 SSL VPN 客户端远程文件下载] jackson | 存在反序列化漏洞，POC疑似已流出 tomcat | 存在反序列化命令执行漏洞，POC疑似已流出 泛微OA9 | [泛微OA9前台任意文件上传]) 泛微OA8 | [泛微OA8前台SQL注入] CoreMail | [Coremail文件上传漏洞POC - 钓鱼] 用友NC6.5 | [用友NC反序列化] [用友 NC 反序列化RCE漏洞] dubbo | 存在反序列化命令执行漏洞，POC疑似已流出 Weblogic | [某weblogic的T3反序列化0day分析] [Weblogic T3 反序列化远程代码执行漏洞] 和信创天云桌面全版本 | [和信创天云桌面命令执行][和信创天云桌面系统 远程命令执行 RCE漏洞] 红帆OA | 存在任意文件写入漏洞，POC疑似已流出 Exchange | [Microsoft Exchange Server远程执行代码漏洞] Shiro | 存在Nday漏洞，POC疑似已流出 金蝶云K3Cloud全版本 | 存在命令执行漏洞，，POC疑似已流出 用友U8Cloud版本 | 存在命令执行，POC疑似已流出 H3C计算机管理平台2016年版本 | [H3C SecPath运维审计系统任意用户登录漏洞] 18号获取详细信息 帆软V9 | [帆软 V9getshell FineReport V9] [帆软 V9 任意文件覆盖文件上传] 天眼 | 存在0day漏洞，POC疑似已流出 默安蜜罐管理平台 | [默安蜜罐管理平台未授权问] Jellyfin&lt;10.7.1版本（历史漏洞） | [Jellyfin未授权任意文件读取 用友ERP-NC | 存在目录遍历漏洞 快排CMS | [快排CMS 任意文件上传漏洞] 快排CMS | [快排CMS 信息泄露漏洞] 快排CMS | [快排CMS 后台XSS漏洞] 2021.04.09 Apache Solr | [apache Solr 存在任意文件读取] 亿邮电子邮件系统 | [亿邮电子邮件系统 远程命令执行漏洞] 天融信DLP | [天融信dlp-未授权+越权] 奇安信VPN | [奇安信VPN前台存在RCE] DzzOffice≤2.02 | [DzzOffice最新版RCE(随机数问题)] 蓝凌OA | [蓝凌oa任意文件写入] 蓝凌OA | [蓝凌OA EKP 后台SQL注入漏洞 CNVD-2021-01363][蓝凌OA EKP 后台SQL注入漏洞 CNVD-2021-01363] 致远OA | [致远OA远程代码执行漏洞] 浪潮云ClusterEngineV4.0 | [浪潮 ClusterEngineV4.0 任意命令执行] OneBlog≤V2.2.1 | [OneBolg远程命令执行][OneBlog 小于v2.2.1 远程命令执行漏洞] 2021.04.10 浪潮云ClusterEngineV4.0 | [浪潮ClusterEngineV4.0 sysShell 任意命令执行漏洞] 浪潮云ClusterEngineV4.0 | [浪潮ClusterEngineV4.0 任意用户登录漏洞] 齐治堡垒机 | [齐治堡垒机任意用户登录漏洞] 山终端安全系统 V8/V9 | [金山终端安全系统 V8/V9存在文件上传漏洞] 奇安信NS-NGFW 网康防火墙 | [奇安信 网康下一代防火墙 RCE 云尚在线客服系统 | 存在任意文件上传 泛微OA8 e-mobile | [泛微OA e-mobile4.0-6.6 SQL注入漏洞] 泛微OA8 e-mobile | [泛微e-mobile 0day] 2021.04.11 FOFA指纹 title=“流媒体管理服务器” | [HIKVISION 流媒体管理服务器 后台任意文件读取漏洞 CNVD-2021-14544] Fastjson 0day | 疑似0day，视频确认存在 Apache Solr | [Apache Solr 任意文件下载/SSRF POC] 2021.04.12 Google Chrome≤89.0.4389.114 | [Chrome 远程代码执行0Day漏洞] Nagios Network Analyzer | [Nagios Network Analyzer SQL 注入漏洞- CVE-2021-28925] 蓝凌OA | [蓝凌OA密码重置漏洞] 瑞捷 | [锐捷RG-UAC统一上网行为管理审计系统存在账号密码信息泄露][锐捷 RG-UAC 统一上网行为管理审计系统 账户硬编码漏洞] 2021.04.13 IBOS数据库模块 | [IBOS 数据库模块 任意文件上传漏洞] PHP zerodium | [PHP zerodium后门漏洞] 迅雷 | [迅雷11存在二进制漏洞 - CNVD-2021-18274] Apache Solr | [Apache Solr服务器端请求伪造漏洞 - CVE-2021-27905] Apache Solr | [Apache Solr数据集读写漏洞 - CVE-2021-29943] Apache Solr | [Apache Solr敏感信息泄漏漏洞 - CVE-2021-29262] 2021.04.14 Apache OFBiz反序列化漏洞 | [Apache OFBiz RMI反序列化漏洞 CVE-2021-26295] EMP平台 | [EMP平台任意文件上传漏洞] JD-FreeFuck后台命令执行 | [JD-FreeFuck 后台命令执行漏洞] Microsoft Exchange | [Microsoft Exchange Server远程执行代码漏洞] 天融信（历史漏洞） | [天融信接入网关系统存在弱口令 - CNVD-2021-08407 奇安信天擎终端安全管理系统 | 存在任意文件上传 Google Chrome V8引擎 | [Google ChromeV8引擎远程代码执行0day漏洞] 2021.04.15 通达OA | [通达OA存在命令执行漏洞 - CNVD-2021-21890] Joomla | [Joomla XSS漏洞] TongWeb | [tongweb文件上传漏洞] 2021.04.16 Weblogic | [ Weblogic T3 反序列化远程代码执行漏洞] 微信 | [青藤捕获在野微信 0day 漏洞（ chrome 0day 利用）][利用微信内置浏览器 Chrome 漏洞实现远控] 浪潮 ERP | [浪潮 ERP 系统远程代码执行漏洞] 2021.04.17 深信服 | [深信服安全感知平台存在存储型跨站脚本漏洞 泛微 | [泛微某系统疑似存在文件上传漏洞] TP-COUPON | [ TP-COUPON 存在 SQL 注入漏洞 - CNVD-2021-21889 ] 2021.04.18 小鱼易连视频会议系统 | [小鱼易连视频会议系统存在 0day ] H3C SecPath 运维审计系统 | [ H3C SecPath 运维审计系统任意用户登录漏洞] Coremail | [历史漏洞 oremail 邮箱系统路径穿越漏洞] 2021.04.20 微信 | [微信最新版本 3.2.11.151 Google 内核 poc 利用上线 cs 方式]","categories":[{"name":"dev","slug":"dev","permalink":"http://debug.cool/categories/dev/"}],"tags":[]},{"title":"Python3的一个沙箱逃逸技巧","slug":"sandboxEscapePy3","date":"2021-03-31T16:10:00.000Z","updated":"2021-05-13T08:25:37.113Z","comments":true,"path":"2021/04/01/sandboxEscapePy3/","link":"","permalink":"http://debug.cool/2021/04/01/sandboxEscapePy3/","excerpt":"Emil Lerner(twitter @emil_lerner) 上个月发了个推，当时看到了没想到很好的解决方法。","text":"Emil Lerner(twitter @emil_lerner) 上个月发了个推，当时看到了没想到很好的解决方法。 他提出了这样一个问题: 1234code = input()for c in &#x27;hui&quot;\\&#x27;(&#x27;: assert c not in codeexec(code, &#123;&#x27;__builtins__&#x27;: &#123;&#125;&#125;) 3月15号的时候 Arthur Khashaev (twitter @Invizory)给了个解法，惊为天人，来和大家分享一下。 123456789101112b=[].__class__.__base__d=[].__doc__n=d.__doc__[31]__bu\u001dlt\u001dns__[n+n+d[13]+d[1:4]+d[139]+n+d[23]+d[3]+d[12]+d[17]*2+n+n]=lambda*_:b@b.__class__.__subclasses__class s:_@s[84].load_module@lambda _:d[32]+d[17]class o:_@o.system@lambda _:d[2]+d[139]class _:_ identifier 过滤绕过 这段代码的第一个神奇之处就在于 python3 的 interpreter 竟然会做 unicode normalize，这个特性总 感觉以前从来没看过，经过一定的考证找到了实据，文档中写到: Python 3.0 introduces additional characters from outside the ASCII range (see PEP 3131). For these characters, the classification uses the version of the Unicode Character Database as included in the unicodedata module. 从 python 3.0 引入的对 name 的处理，从 PEP 3131 中可知: The following changes will need to be made to the parser: If a non-ASCII character is found in the UTF-8 representation of the source code, a forward scan is made to find the first ASCII non-identifier character (e.g. a space or punctuation character) The entire UTF-8 string is passed to a function to normalize the string to NFKC, and then verify that it follows the identifier syntax. No such callout is made for pure-ASCII identifiers, which continue to be parsed the way they are today. The Unicode database must start including the Other_ID_{Start|Continue} property. If this specification is implemented for 2.x, reflective libraries (such as pydoc) must be verified to continue to work when Unicode strings appear in dict slots as keys. 具体来说就是如果 id 名称使用了非 ASCII 字符，则会将整个 name 传给 unicodedb 去做 NFKC normalize，也就是说这些字符会被自动的替换，从而正常解析。 因此 Python 3 起针对 identifier 的过滤都可以使用该方法绕过。 函数调用绕过 本题第二个难点在于，不允许使用左括号，因此无法做直接的函数调用。有同学就要说了，可以通过修 改 add 等默认行为来做间接的函数调用，不过我没有找到内置的可以直接修改 add 属性的 对象，若有发现望告知。 Arthur 使用的方法比较巧妙，通过修改 build_class 从而修改了声明 class 时的默认行为， 1__bu\u001dlt\u001dns__[n+n+d[13]+d[1:4]+d[139]+n+d[23]+d[3]+d[12]+d[17]*2+n+n]=lambda*_:b 这一行将修改创建 class 时的默认行为，使得每个 class 声明都会返回 object type: 1__builtins__[&#x27;__build_class__&#x27;] = lambda*_:b 而这里: 12@b.__class__.__subclasses__ class s:_ 在创建 class 的时候相当于让 12s = b(func, name, /, *bases, [metaclass], **kwds) # 即 s = objects = b.__class__.__subclasses__(s) # 即 s = b.__class__.__subclasses__(object) 从而通过 class s 获得了object的子类列表 后续原理类似不再赘述。这个形势有些类似于 PHP 中的回调型后⻔，对于 function 其实也有类似的形 势可以达到一样的效果: 123@b.__class__.__subclasses__ @cdef d(): pass 因此值得讨论的问题转化为了: python 中的类似回调的行为都有哪些?","categories":[{"name":"sec","slug":"sec","permalink":"http://debug.cool/categories/sec/"}],"tags":[]},{"title":"Windows10下WSL开发环境搭建","slug":"tipsWSL","date":"2021-01-20T14:44:00.000Z","updated":"2021-05-07T14:38:46.500Z","comments":true,"path":"2021/01/20/tipsWSL/","link":"","permalink":"http://debug.cool/2021/01/20/tipsWSL/","excerpt":"工作环境的一架台式机是Windows10系统，Windows系统对开发者来说并不是很友好（.net及Windows内核开发者除外，比如一些扩展包，例如PHP的swoole，在Windows上现在没有直接安装的解决方案）。","text":"工作环境的一架台式机是Windows10系统，Windows系统对开发者来说并不是很友好（.net及Windows内核开发者除外，比如一些扩展包，例如PHP的swoole，在Windows上现在没有直接安装的解决方案）。 刚开始一段时间(WSL没有出来那会，也不想用虚拟机和Docker)把台式机改成Linux系统，但是呢，各种办公软件在Linux平台就很糟心了，比如微信、QQ 这些软件，在Linux没有官方版本，通过黑科技进行移植的版本会出现各种故障，比如发送文档都得做磁盘空间共享，简直让人崩溃。 如果是纯粹只负责写代码的工作场景倒无所谓了，但是需要和客户、同事进行沟通，涉及到视频、音频、文件传输，简直炸毛。。。 背景 某天装备升级强化了下，内存有16G，试着安装了Windows的WSL，这是微软自研的架构，为了兼容Linux内核。简单来讲就是Windows系统内置了一套Linux内核，直接做了系统间的映射。 准备 材料 Windows10 wsl Ubuntu18.appx WSL 环境初始化 打开Windows自带的power shell终端，执行Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux命令，就在Windows上安装好了wsl环境。 接着下载一份Ubuntu18.04镜像，同样是在power shell终端执行命令Invoke-WebRequest -Uri https://aka.ms/wsl-ubuntu-1804 -OutFile Ubuntu.appx -UseBasicParsing，当前目录路径下就会出现一个Ubuntu的appx软件，点击安装即可。 Ubuntu 配置 点击安装Ubuntu.appx后，系统会弹出一个黑色窗口，提示你输入unix系统的用户名及密码，正常配置即可。 修改镜像源 我们需要把Linux系统的软件镜像地址改成国内的镜像地址，否则安装软件包会卡到你怀疑人生，我们先到网上搜索一下Ubuntu18国内镜像源（这里选用了阿里的镜像源），源链接如下： 1234567891011# alibaba source listdeb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse 得到需要的源链接后，再到Ubuntu系统里更改源文件即可，命令操作如下： 1234567# 先备份原文件sudo cp /etc/apt/source.list /etc/apt/source.list-back# 再更改原文件sudo vim /etc/apt/source.list# 将上面的源链接拷贝进来，再保存退出# 更新系统的源包管理sudo apt-get update &amp;&amp; sudo apt-get upgrade -y 这样，我们就配置好了国内镜像源。 部署 nginx web开发，一般web代理服务器选择apache或者nginx，这里讲nginx的部署，相应的操作命令如下： 123456# 安装nginx，等待一段时间即可。sudo apt-get install nginx# 创建我们的vhost文件夹mkdir ~/vhost# 更改nginx配置sudo vim /etc/nginx/nginx.conf 在 include /etc/nginx/site-avaliable 下引入我们的 vhost 文件夹： 1include /home/kirk/vhost/*.conf; 本地 hosts 配置下开发域名 123sudo vim /etc/hosts# 增加一条指向记录127.0.0.1 api.kirk.com 编写 vhost 文件,如 vim ~/vhost/Kirk.conf 12345678910111213141516171819202122232425262728# API 解析server &#123; listen 80; server_name api.kirk.com; # 这里的项目地址是宿主机的项目地址，因为在Windows内置的Linux系统中，读取宿主机Windows文件的方式是使用挂载的模式， # 把Windows系统盘当成挂在盘进行处理，例如/mnt/d表示Windows的D盘，我们在D盘github/kirk文件夹下写了一个php文件，里面打印一个phpinfo(); root &quot;/mnt/d/github/kirk&quot;; location / &#123; index index.php index.html error/index.html; if (!-e $request_filename) &#123; rewrite ^(.*)$ /index.php?s=/$1 last; break; &#125; autoindex off; &#125; location ~ \\.php(.*)$ &#123; # 记住这里fastcgi监听的是9004端口，后面配置php-fpm的时候会用到，因为fastcgi要和php-fpm端口保持统一 fastcgi_pass 127.0.0.1:9004; fastcgi_index index.php; fastcgi_split_path_info ^((?U).+\\.php)(/?.+)$; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param PATH_INFO $fastcgi_path_info; fastcgi_param PATH_TRANSLATED $document_root$fastcgi_path_info; include fastcgi_params; &#125;&#125; 保存完conf文件后，再执行sudo service nginx reload进行重载nginx的配置。 安装 php 这里选用了php74版本，具体命令如下： 12345678# 先安装一个软件中心组件sudo apt-get install software-properties-common# 再添加一个php的第三方源（因为官方源的php版本不大适用，一个是版本少，另一个是扩展包比较少）sudo add-apt-repository ppa:ondrej/php# 再刷新一下包管理器sudo apt-get update# 安装对应版本的php及扩展包，扩展包自行按需添加sudo apt-get install php7.4 php7.4-fpm php7.4-mysql php7.4-gd php7.4-mbstring php7.4-redis 处理php-fpm，操作如下： 123456# 修改php-fpm监听的端口，与nginx的fastcgi保持一致sudo vim /etc/php/74/fpm/pool.d/www.conf# 找到listen = /run/php/php7.4-fpm.sock ,并改成下面的监听配置listen = 127.0.0.1:9004# 修改保存成功后，重启php-fpm即可sudo service php7.4-fpm restart 这样打开Windows的浏览器，访问我们刚刚配置的站点http://api.kirk.com，出现php版本信息即表示配置成功。 然后，看了下性能损耗，Windows基本的应用加上wsl共消耗3G内存，还是比集成软件PHPstudy节省了一丢丢内存，最主要的是以前Windows不能安装的扩展现在可以随意安装了~ 再试着打开微信、企业微信、开发软件 IDE，好家伙，直接达到8G内存，平时半天没有回复你们信息不是故意不回，是电脑卡死了在等待。 安装 python 环境 单单只有一个php怎么玩数据呢，需要部署下python，Ubuntu自带了python3，但是我们需要按照不同项目做环境隔离，所以需要特殊处理下隔离软件的配置： 1234567891011121314151617181920212223242526# 先看看Ubuntu有没有自带python3，执行如下命令python3# 如果进入了python3操作界面，表示系统已安装，反之需要我们自己安装.# 安装命令sudo apt-get install python3# 验证是否安装pip 包管理器pip3 -V# 如果没有出现pip3的版本信息，代表系统没有安装，需要我们手动安装sudo apt-get install pip3# 安装好了之后，开始安装python虚拟环境sudo pip3 install virtualenvsudo pip3 install virtualenvwrapper# 配置包引导sudo vim ~/.bashrc# 在最后加上这几条命令，分别表示1.虚拟环境的工作目录。2.虚拟包用python3进行驱动。3.加载虚拟包执行脚本。export WORKON_HOME=$HOME/.virtualenvsexport VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3source ~/.local/bin/virtualenvwrapper.sh# 保存退出后source ~/.bashrc# 这样python虚拟环境管理包就配置好了，我们可以用如下命令创建对应的虚拟环境mkvirtualenv -p python3 Kirk# 退出python虚拟环境deactive# 删除对应虚拟环境rmvirtualenv Kirk 这样通过virtualenvwrapper进行管理python的虚拟环境，从而实现不同的项目使用不同的python包管理。 其他的环境配置会陆续更新，to be continue…","categories":[{"name":"tips","slug":"tips","permalink":"http://debug.cool/categories/tips/"}],"tags":[]},{"title":"DiyExpress - 自定义表达式计算引擎","slug":"devDiyExpress","date":"2020-12-08T16:00:00.000Z","updated":"2021-05-07T14:39:55.196Z","comments":true,"path":"2020/12/09/devDiyExpress/","link":"","permalink":"http://debug.cool/2020/12/09/devDiyExpress/","excerpt":"我们在数据分析的业务上，经常会有一些比较脑洞大开却又很实用的需求。 比如有个场景，当我们将数据分析的”自主权“交给用户。","text":"我们在数据分析的业务上，经常会有一些比较脑洞大开却又很实用的需求。 比如有个场景，当我们将数据分析的”自主权“交给用户。 由用户来决定自己需要计算分析什么维度的数据，这个需求确实是一个痛点，能解决这个需求，不就是为用户创造了价值么。 因此，花了点时间写了一套自定义表达式计算引擎。 已知用户是有一定Excel公式基础的，需要提供一个交互界面让他输入他定义的类似Excel公式的一段简单公式，其中的各个参数是自定义表单中各个字段所填充的数据。如下： 1&#123;&#123;销售返现&#125;&#125;=if ( &#123;&#123;数量&#125;&#125; &gt;= 100 AND (&#123;&#123;产品类型&#125;&#125; == &#x27;产品A&#x27; OR &#123;&#123;产品类型&#125;&#125; == &#x27;产品B&#x27;), &#123;&#123;成单金额&#125;&#125; * 0.7, &#123;&#123;成单金额&#125;&#125;*0.5) + 100 双花括号里面的是指定的字段（用来代表该字段的取值 data），单引号或者双引号是指定的取值。 我们的目标是程序根据用户定义的公式计算对应的数据，那么核心点在于如何识别用户定义的公式。 依旧是被“自定义”给坑了，需要识别用户定义的公式只能上一个词法分析器了，根据大三学的编译原理，徒手撸个状态机。。 考虑到能用脚本语言就用脚本语言，技术选型用的PHP,源码放在 github 上，DiyExpress。 贮备知识点 AST 节点树 AST (Abstract Syntax Tree(抽象语法树)) 是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构。它由一堆节点（Node）组成，每个节点都表示源代码中的一种结构。不同结构用类型来区分，常见的类型有： Identifier(标识符)，BinaryExpression(二元表达式)，VariableDeclaration(变量定义)，FunctionDeclaration(函数定义)等。 AST 是编译器看的。编译器会将源码转化成 AST。如下源码: 123456var a = 42;var b = 5;function addA(d) &#123; return a + d;&#125;var c = addA(2) + b; 会换转化成这样的 AST: AST 的使用场景？ TypeScript、babel、webpack、vue-cli等都是依赖AST进行开发的。 通过AST，可以将代码转化后，再输出。比如： 代码压缩。删除没用的空格，未使用的语句，变量名替换等。 代码高亮。 将 ES6 代码转换成 ES5 代码。 给 CSS 中的某些属性加浏览器前缀-webkit-。 将 CSS 中的px转化成rem。 生成代码。最近用了ANT DESIGN PRO。 ANT DESIGN PRO 中的 umi 可以在生成页面的代码和路由时，修改路由配置的js。umi 这种方式，用户体验很好。因此，我准备用这种方式来改造我之前做的代码生成工具。修改路由配置需要通过 AST 来转换代码。 需要学习 AST 的哪些知识？ 了解 AST 常见节点的结构 了解 AST 常见节点的结构推荐通读下AST node 规范。 源码解析 将源码转化为AST。该步骤分为词法分析（Lexical Analysis）和 语法分析（Syntactic Analysis）。 解析 JavaScript 可以用@babel/parser(以前叫 Babylon)。 转换 在遍历AST时，对指定的AST节点做新增，修改或删除操作。 转换可以用@babel/traverse。 创建和验证节点可以用@babel/types。创建AST节点代码示例见这里。 生成目标代码 将上一步转换过的AST，转化为目标代码，并生成源码映射（source maps）。 生成目标代码可以用@babel/generator To be continue…","categories":[{"name":"dev","slug":"dev","permalink":"http://debug.cool/categories/dev/"}],"tags":[]},{"title":"Window10下双系统grub修复","slug":"tipsDoubleSystem","date":"2020-03-15T15:10:00.000Z","updated":"2021-05-07T07:30:39.985Z","comments":true,"path":"2020/03/15/tipsDoubleSystem/","link":"","permalink":"http://debug.cool/2020/03/15/tipsDoubleSystem/","excerpt":"起因是我的笔记本window10在某次更新升级时，将之前设置好的双系统引导破坏了，导致进入Linux系统时提示Unknown filesystem。","text":"起因是我的笔记本window10在某次更新升级时，将之前设置好的双系统引导破坏了，导致进入Linux系统时提示Unknown filesystem。 首先能确定的是Linux的引导读取出了问题，才进入到了grub rescue模式。如果记得自己的Linux引导安装在哪个区块可以直接重新读取引导（这个得看你安装双系统的时候，把Linux的引导装在哪个分区），如果不记得，就执行下面的命令输出gpt分区 1ls 这样会显示出你所有的分区，再一个一个试试下面的命令（我的引导安装在gpt7区块上） 1ls (hd0,gpt7)\\boot\\grub 其他不是引导所在的分区都是提示error: unknown filesystem。找到了所在的分区会提示该目录下的文件目录。 假定你们也是(hd0,gpt7)分区，依次执行下面的命令： 1234set root=(hd0,gpt7),set prefix=(hd0,gpt7)/boot/grubinsmod normal,normal 执行完毕会进入Linux启动的图形界面。 进入Linux系统后，打开终端执行以下命令重新安装grub引导： 12sudo update-grubsudo grub-install /dev/sda 再重启，就能恢复到正常Linux的启动引导了。","categories":[{"name":"tips","slug":"tips","permalink":"http://debug.cool/categories/tips/"}],"tags":[]},{"title":"自定义表单设计及实现方案","slug":"devDiyForm","date":"2020-02-03T06:30:00.000Z","updated":"2021-05-07T14:41:01.612Z","comments":true,"path":"2020/02/03/devDiyForm/","link":"","permalink":"http://debug.cool/2020/02/03/devDiyForm/","excerpt":"如何设计一款高度自定义的表单系统？ 自定义意味着表单数量不确定，每个表单字段数量不确定，每个字段类型不确定，存储量不确定，等等一切都是未知的。","text":"如何设计一款高度自定义的表单系统？ 自定义意味着表单数量不确定，每个表单字段数量不确定，每个字段类型不确定，存储量不确定，等等一切都是未知的。 以及之后如何建立索引，如何搜索定位指定的数据？这些问题都将在下面的方案中进行解答。 背景 为了实现某个比较脑洞大开的需求，建立自定义表单，而且，还限定了前置条件—技术选型不许复杂，数据存储只能基于mysql, So… 所谓的“自定义”（表设计） 我们会定义这么几张表，用来实现自定义模板的大致框架。 12345diy_field_pool 字段池（我们定义好的字段类型）diy_form 表单表（记录用户自定义的表单）diy_form_field 表单字段表（记录某张表单中有哪些字段）diy_form_entity 表单实例表（记录某张表单中的某条数据实例）diy_form_data 表单数据表（记录某张表单在某条实例下，哪些字段对应的数据） 系统初始化字段池 我们提供一批预定义的字段类型，初始化数据到diy_field_pool表中，用户也能自己定义自己的字段池。 用户创建自定义表单 用户通过选用字段池（diy_field_pool表）中提供的字段，创建一张自定义表单，表单的属性信息记录在diy_form表中，表单包含的字段（从字段池中选好的字段）记录在diy_form_field表中。这样用户就创建了一张自定义表单。 用户填写表单 用户使用创建好的表单填写数据，每新增一条数据，在diy_form_entity表就会新增一条记录，该表单中有几个field，就会同时在diy_form_data表中新增几条 data 数据。数据结构关系如下图所示： 123456789101112131415diy_form ------ diy_enity| ||---diy_field |---diy_data| ||---diy_field |---diy_data| ||---diy_field |---diy_data| ||---diy_field |---diy_data| ||---diy_field |---diy_data| ||---diy_field |---diy_data| ||... 如何进行数据搜索 数据存储结构中，最终保存数据的地方其实是data表，但是，data表的辅助字段有form表id，field表id，entity表id，只有一个content字段是记录真实信息的，那么，如何搭建索引体系呢？ 采用 Sphinx 构建Sphinx的sql语句时，将data表的id作为文档id。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172# 公共的自定义模板的数据源source diyCommonSource&#123; type = mysql sql_db = diy sql_host = 127.0.0.1 sql_port = 3306 sql_user = root sql_pass = root sql_query_pre = SET NAMES utf8 sql_query = \\ select \\ dfd.id, \\ dfd.entity_id,dfd.content,dfd.createat,dfd.updateat, \\ dff.id as field_id,dff.sys_id,dff.field, \\ df.id as form_id \\ from diy_form_data as dfd \\ inner join diy_form_field as dff on dff.form_id=dfd.form_id and dff.is_delete=0 \\ inner join diy_form as df on df.id=dff.form_id and df.is_delete=0 \\ where dfd.is_delete=0&#125;# 公共的自定义模板的索引index diyCommonIndex&#123; source = diyCommonSource path = /var/local/diy/sphinx/data/diyCommonIndex docinfo = extern #charset_type = zh_cn.utf-8 charset_type = utf-8 min_word_len = 1 ngram_len = 1 ngram_chars = U+3000..U+2FA1F&#125;# 范围：新闻模板（假定form_type为1）source news:diyCommonSource&#123; sql_query = \\ select \\ dfd.id, \\ dfd.entity_id,dfd.content,dfd.createat,dfd.updateat, \\ dff.id as field_id,dff.sys_id,dff.field, \\ df.id as form_id \\ from pre_diy_form_data as dfd \\ inner join pre_diy_form_field as dff \\ and dff.form_id=dfd.form_id \\ and dff.sys_id&gt;0 and dff.is_delete=0 \\ inner join pre_diy_form as df \\ and df.id=dff.form_id \\ and df.is_delete=0 \\ and df.form_type=1 \\ where dfd.is_delete=0 # 使用sql_attr设置的字段(搜索条件)，只能作为属性，使用SphinxClient::SetFilter()进行过滤； # 未被设置的字段，自动作为全文检索的字段，使用SphinxClient::Query(&quot;搜索字符串&quot;)进行全文搜索 # sql_query第一列id需为整数，且被系统使用，无需再设置sql_attr_uint sql_attr_uint = form_id sql_attr_uint = field_id sql_attr_uint = field sql_attr_uint = entity_id sql_attr_timestamp = createat sql_attr_timestamp = updateat&#125;# 构造商品模板的数据索引index news:diyCommonIndex&#123; source = news path = /var/local/diy/sphinx/data/news&#125; 其中，如果需要指定查找某些字段的数据，那么，以上面的数据源再重新定义数据源，sql 语句进一步指定 field 表的某个标志字段即可。","categories":[{"name":"dev","slug":"dev","permalink":"http://debug.cool/categories/dev/"}],"tags":[]},{"title":"验证码识别","slug":"devCrack","date":"2019-05-10T07:44:00.000Z","updated":"2021-05-07T07:30:39.982Z","comments":true,"path":"2019/05/10/devCrack/","link":"","permalink":"http://debug.cool/2019/05/10/devCrack/","excerpt":"通过训练卷积模型，让程序自动识别验证码。","text":"通过训练卷积模型，让程序自动识别验证码。 背景 运营人员审核某些用户提交的资质证书的时候，需要到规定的公示网站上去查询证书，大致操作是这些： 到公示网站填写对应信息（证书编号等） 填写验证码（每次查询都会有校验码或者短信验证等等） 查看查询结果并比对证书 这一套流程下来，无疑是加大了审核员的工作量，而且每天审核的不止一张证书。一个比较迫切的需求就诞生了，根据不同证书种类，分别去自动获取公示网站上该证书的信息。 假定以教师资质证书为例，该公示站点查询信息时，需要输入证书编号，图片验证码，即可返回该证书所对应的信息，运营人员比对用户上传的证书和站点公示的证书即可。 方案一 现在方案一是在我们自己的审核后台，将所有的数据（查询时需要的证书编号、姓名等等）都提取出来，封装成一个 post 请求数据，并将公示网站的验证码获取过来，在审核后台只留一个验证码的输入框给审核人员，输入正确的验证码，追加到 post 请求中，即可进行查询（该过程中会话交互验证的破解思路请自行摸索），将返回的数据结果进行切割处理，以比较好的交互方式呈现给运营人员。运营人员剩下的工作只要 check 一下信息即可。 ps：方案一的背后其实还进行了另一步操作，只要查询成功，就将这张验证码图片保存到本地服务器，运营人员输入的验证码作为图片名（这一步是关键，因为需要大量的训练样本进行模型训练，为方案二做铺垫）。 方案二 等一段时间后，将方案一保存下来的这批图片数据作为训练样本，去训练模型，也就是方案二，当模型的准确率达到了 0.9 以上，就可以实际拿过来使用了。（可能会说为什么不自动生成相似的验证码来进行训练，这也是一个思路，但准确率没有拿目标样本作为训练样本来的高，因为我们是不知道对方验证码的生成规则的，只能仿出一个大概相似的验证码。） 方案二部署上线的时候，只要用户提交了相关的证书信息，我们的系统就自动去公示网站上查询数据并将结果保存到数据库，这样运营人员只要在审核后台核对查询结果即可，也不用再输入验证码了。 为了更好的兼容，之前方案一预留的手动填写验证码功能也不会删减掉，防止出现系统无法自动识别验证码、获取不到查询数据的情况。这样如果系统自动查询到了数据运营人员就能直接审核，没有查询到数据，运营人员还能手动查一遍进行确认，同时还收集了验证码的训练样本。 总结 方案二是在方案一使用一段时间后才能进行的，因为我们需要大量的训练样本，如果特意通过人工去获取数据（验证码图片）并打标签（每张图片所代表的验证码），无疑是会浪费很大的人力资源。 这样在方案一阶段，审核人员还是进行常规的审核操作，就顺便收集了对应的训练数据。等到执行案案二，就将审核员彻底解放出来，在需求（审核功能、上线时间）、成本（时间、人力）、技术实现（样本获取）上目前应该是最优解了。 补充 其实同时还是做了高仿目标站点的验证码，争取做到大致相同。然后tensorflow训练后的识别率达到0.9左右估计就差不多了。 源码","categories":[{"name":"dev","slug":"dev","permalink":"http://debug.cool/categories/dev/"}],"tags":[]},{"title":"Python封装Kafka客户端","slug":"devKafka","date":"2019-04-20T12:44:00.000Z","updated":"2021-05-07T07:30:39.984Z","comments":true,"path":"2019/04/20/devKafka/","link":"","permalink":"http://debug.cool/2019/04/20/devKafka/","excerpt":"业务上处理Kafka主要就扣着“生产者”和“消费者”这个点就行，下面讲的是在Python中封装一个比较好用的Kafka客户端。","text":"业务上处理Kafka主要就扣着“生产者”和“消费者”这个点就行，下面讲的是在Python中封装一个比较好用的Kafka客户端。 no bb, show code.直接上代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#!/usr/bin/env python# encoding: utf-8import sysfrom pykafka import KafkaClientreload(sys)sys.setdefaultencoding(&#x27;utf8&#x27;)class KafkaTaskException(Exception): &quot;&quot;&quot; 在这里自定义KafkaTask类的异常 &quot;&quot;&quot; passclass ParameterError(KafkaTaskException): &quot;&quot;&quot; 参数异常错误 _ParameterError_Key: 当 key 类型错误的时的抛错. _ParameterError_Topic: 当 topic 类型错误的时的抛错. _ParameterError_Consumer: 当初始化init_consumer 使用了错误的参数时抛错. &quot;&quot;&quot; _ParameterError_Key = &quot;ParameterError- type(s) for &#x27;Key&#x27;: must be bytes&quot; _ParameterError_Topic = &quot;ParameterError- type(s) for &#x27;topic&#x27;: must be bytes&quot; _ParameterError_pykafka_Consumer = &quot;ParameterError- type(s) for &#x27;topic&#x27;: must be bytes; &quot; \\ &quot;type(s) for &#x27;group_id&#x27;: must be str; &#x27;offset_type&#x27; &quot; \\ &quot;must be &#x27;LATEST&#x27; or &#x27;EARLIEST&#x27;&quot; _ParameterError_kafka_Consumer = &quot;ParameterError- type(s) for &#x27;topic&#x27;: must be str; &quot; \\ &quot;type(s) for &#x27;group_id&#x27;: must be str; &#x27;offset_type&#x27; &quot; \\ &quot;must be &#x27;LATEST&#x27; or &#x27;EARLIEST&#x27;&quot; passclass KafkaTask(object): &quot;&quot;&quot; 封装一个pykafka的客户端方法 &quot;&quot;&quot; def __init__(self, server): &quot;&quot;&quot; :param server: str类型 &quot;&quot;&quot; self.server = server self.client = KafkaClient(hosts=server) def init_producer(self, topic): &quot;&quot;&quot; 初始化Kafka生产者 :param topic:Type --&gt; bytes `Produce msg what topic You want`. :raises ParameterError: 当topic不是bytes类型时抛错. :return: &quot;&quot;&quot; if not isinstance(topic, bytes): raise ParameterError(ParameterError._ParameterError_Topic) topic = self.client.topics[topic] self.producer = topic.get_producer(sync=True) def init_consumer_pykafka(self, topic, group_id, offset_type): &quot;&quot;&quot; Init Kafka Consumer by pykafka :param topic:Type --&gt; bytes `Consumer msg what topic You want`. :param group_id: Type --&gt; str `Consumer msg what group_id You want,You can receive duplicate data using different group_id in same topic`. :param offset_type:Type --&gt; str `LATEST can receive the latest data,EARLIEST can receive earliest data in topic` :raises ParameterError: When use error Parameter to init init_consumer. :return: &quot;&quot;&quot; if not isinstance(topic, bytes) or not isinstance(group_id, str) or not isinstance(offset_type, str) or offset_type not in [&quot;LATEST&quot;, &quot;EARLIEST&quot;]: raise ParameterError(ParameterError._ParameterError_pykafka_Consumer) from pykafka.simpleconsumer import OffsetType _OffsetType = &#123;&quot;LATEST&quot;: OffsetType.LATEST, &quot;EARLIEST&quot;: OffsetType.EARLIEST&#125; topic = self.client.topics[topic] self.consumer = topic.get_simple_consumer(auto_commit_enable=True, auto_commit_interval_ms=1, consumer_id=group_id, auto_offset_reset=_OffsetType[offset_type], reset_offset_on_start=True) def init_consumer_kafka(self, topic, group_id, offset_type): &quot;&quot;&quot; Init Kafka Consumer by kafka-python :param topic: Type --&gt; str `Consumer msg what topic You want`. :param group_id: Type --&gt; str `Consumer msg what group_id You want,You can receive duplicate data using different group_id in same topic`. :param offset_type: Type --&gt; str `LATEST can receive the latest data,EARLIEST can receive earliest data in topic` :raises ParameterError: When use error Parameter to init init_consumer. :return: &quot;&quot;&quot; from kafka import KafkaConsumer if not isinstance(topic, str) or not isinstance(group_id, str) \\ or not isinstance(offset_type, str) or offset_type not in [&quot;LATEST&quot;, &quot;EARLIEST&quot;]: raise ParameterError(ParameterError._ParameterError_kafka_Consumer) self.consumer = KafkaConsumer(bootstrap_servers=self.server, auto_offset_reset=offset_type, group_id=group_id, ) self.consumer.subscribe(topics=topic.split(&#x27;,&#x27;)) def pull(self): &quot;&quot;&quot; Get info from Kafka Consumer by kafka-python Poll Parameters: timeout_ms: Type --&gt; int `Interval between each piece of data`. max_records: Type --&gt; int `The amount of data per batch of data` :return: &quot;&quot;&quot; return self.consumer.poll(timeout_ms=0, max_records=1) def send_message(self, msg, key): &quot;&quot;&quot; Send MSG by this func :param msg: Type --&gt; bytes or str `Message to broker`. :param key: Type --&gt; bytes `Producer msg what key You want,You can see the key when you receiving data`. :raises ParameterError: when error type for key. :return: &quot;&quot;&quot; if not isinstance(key, bytes): raise ParameterError(ParameterError._ParameterError_Key) produce_msg = msg.encode() if isinstance(msg, str) else msg self.producer.produce(produce_msg, partition_key=key)","categories":[{"name":"dev","slug":"dev","permalink":"http://debug.cool/categories/dev/"}],"tags":[{"name":"Kafka","slug":"Kafka","permalink":"http://debug.cool/tags/Kafka/"}]},{"title":"任务分配算法","slug":"devTaskAssign","date":"2019-01-26T16:00:00.000Z","updated":"2021-05-07T07:30:39.981Z","comments":true,"path":"2019/01/27/devTaskAssign/","link":"","permalink":"http://debug.cool/2019/01/27/devTaskAssign/","excerpt":"在开发一套内部的审核平台的时候，有这么一个需求，所有的任务需要平均的前提下随机分配给审核员。然后有存在一个问题，有的审核员效率慢，有的审核员效率高，这样分配任务的时候就需要考虑审核员当前手上剩余的审核任务(也有运营部的绩效考核原因)。","text":"在开发一套内部的审核平台的时候，有这么一个需求，所有的任务需要平均的前提下随机分配给审核员。然后有存在一个问题，有的审核员效率慢，有的审核员效率高，这样分配任务的时候就需要考虑审核员当前手上剩余的审核任务(也有运营部的绩效考核原因)。 ps：需求变了，所有的都平均分了，因为运营人员不需要根据审核量进行绩效考核了，多劳多得变成大锅饭了。也白设计了这套算法，无所谓了，就当周末刷了会数独游戏吧，反正闲着也是闲着。 假设现在有 n 个任务需要分配给 m 个审核员去完成，但是每个审核员手头上还有未完成的任务，且未完成的任务数不同。那么如何均匀的把这些任务分配给各个审核员？这里我想出了一种基于平均思想的任务分配算法。 该算法的主要思想是：首先找出所有的审核员中手头未完成任务数量最大的审核员，然后其他审核员以该审核员的未完成任务数为参考数，计算自己可容纳的任务数，最后所有审核员可容纳的任务数之和即为总的可容纳任务数。 这里存在两种情况，第一种是：总的可容纳任务数小于或等于 n 个待分配的任务数，此时所有的审核员以最大未完成任务数 max_task 为参考数，接收待分配的任务。如果刚好分配完，那么算法结束；如果还有剩余任务未分配，那么将剩下的任务抽取 m 个任务分配给每一位审核员，以此类推，直到剩下的未分配任务数小于 m 位置，然后将这小于 m 的任务随机分配相应数量的审核员。 第二种情况是：总的可容纳任务数大于 n 个待分配的任务数，此时降低一个单位的参考数(max_task-1)，然后循环计算可容纳的任务数，知道退出循环（循环终止条件为：ava_task - task_num &lt;= lower_List.size(),lower_List.size()表示的是低于当前参考数的审核员数）。 接下来，我们将通过一个简单的例子来说明算法的流程，由于第一种情况比较简单，因此，该例子是基于第二种情况的，如图 1 所示. 假设有 20 个任务需要分配给 8 个审核员(对应 8 个条形图，蓝色条形图对应的数字代表该审核员手头未完成的任务数)。 首先找出者八个审核员收中未完成任务书的最大值 max_task=7，然后个审核员已 max_task 为参考数计算各自可容纳的任务数(绿色条形图对应的数字)，总的可容纳任务数为所有审核员可容纳的任务数之和，及 ava_task=6+3+4+2+5+0+5+6,有图 1 可知，lower_List.size()=7,由 31-20&gt;7，因此，可降低一个单位的参数数，即 max_task=max_task-1=6，如图 2 所示。 那么，ava_task=5+2+3+1+4+0+4+5=24，lower_List.size()=7，由于 24-20&lt;7，因此循环终止。 由于可容纳的任务数仍然大于待分配的任务数，因此需要再降低一个单位的参考数(一定要考虑这种情况)，max_task=max_task-1=5，此时 ava_task=4+1+2+0+3+0+3+4=17，lower_List.size()=6，剩余待分配任务数为 20-17=3，然后将这 3 个任务随机分配给低于当前参考数的 6 个审核员中的 3 个，每个审核员分配一个。 当然算法中还考虑了很多种情况，具体请参见如下代码。由于任务一般按审核员 ID 来分配，且 ID 一般为字符串。为了存储方便，我定义了一个二维字符串类型的数组 rev_task[i][j]来存储数据，i 表示第 i 个审核员，rev_task[i][0]存放的是第 i 个审核员的 ID，rev_task[i][1]存放的是第 i 个审核员当前未完成的任务数，rev_task[i][2]存放的是第 i 个审核员应当被分配的任务数。 算法工具类-AlgorithmUtils.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119package com.audit.allocationAlgorithm;import java.util.ArrayList;import java.util.Date;import java.util.List;import java.util.Random;public class AlgorithmUtils &#123; public static void taskAllocation(int task_num, int rev_num, String[][] rev_task) &#123; Random rd = new Random(); List&lt;Integer&gt; rdList = new ArrayList&lt;&gt;(); int temp; //获得审核人员中的最大未完成任务数 int max_task = Integer.parseInt(rev_task[0][1]); for(int i = 1; i &lt; rev_num; i++)&#123; if(max_task &lt; Integer.parseInt(rev_task[i][1])) max_task = Integer.parseInt(rev_task[i][1]); &#125; //以最大待审核任务数为参考数，判断第一轮可容纳的任务数 int ava_task = 0; List&lt;Integer&gt; lower_List = new ArrayList&lt;&gt;(); for(int i=0;i&lt;rev_num;i++)&#123; if((max_task-Integer.parseInt(rev_task[i][1])) &gt; 0)&#123; ava_task += (max_task-Integer.parseInt(rev_task[i][1])); lower_List.add(i); &#125; &#125; int task_rest; int task_avg; //第一种情况：第一轮可容纳的任务数小于待分配的任务数 if(ava_task - task_num &lt;= 0) &#123; for(int i = 0; i &lt; rev_num; i++) &#123; rev_task[i][2] = String.valueOf(max_task-Integer.parseInt(rev_task[i][1])); &#125; task_rest = task_num-ava_task; task_avg = task_rest/rev_num; if(task_rest != 0) &#123; while(task_avg &gt; 0) &#123; for(int i = 0; i &lt; rev_num; i++) &#123; rev_task[i][2] = String.valueOf(Integer.parseInt(rev_task[i][2])+task_avg); &#125; task_rest -= rev_num*task_avg; task_avg = task_rest/rev_num; &#125; rdList.removeAll(rdList); while(rdList.size() &lt; (task_rest+1))&#123; temp = rd.nextInt(rev_num); if(!rdList.contains(temp))&#123; rdList.add(temp); &#125; &#125; for(int i = 0; i &lt; task_rest; i++) &#123; rev_task[rdList.get(i)][2] = String.valueOf(Integer.parseInt(rev_task[rdList.get(i)][2])+1); &#125; &#125; &#125;else &#123;//第二种情况：第一轮可容纳的任务数大于待分配的任务数，此时降低一个单位的参考数(max_task-1)，然后循环计算可容纳的任务数，直到退出循环 while(ava_task - task_num &gt; lower_List.size()) &#123; max_task--; ava_task = 0; lower_List.removeAll(lower_List); for(int i=0;i&lt;rev_num;i++)&#123; rev_task[i][2] = &quot;0&quot;; if((max_task-Integer.parseInt(rev_task[i][1])) &gt; 0)&#123; rev_task[i][2] = String.valueOf(max_task-Integer.parseInt(rev_task[i][1])); ava_task += Integer.parseInt(rev_task[i][2]); lower_List.add(i); &#125; &#125; &#125; if(ava_task - task_num &gt; 0) &#123;//如果可容纳的任务数大于待分配的任务数，那么需要再再降低一个单位的参考数 max_task--; ava_task = 0; lower_List.removeAll(lower_List); for(int i=0;i&lt;rev_num;i++)&#123; if((max_task-Integer.parseInt(rev_task[i][1])) &gt;= 0)&#123; rev_task[i][2] = String.valueOf(max_task-Integer.parseInt(rev_task[i][1])); ava_task += Integer.parseInt(rev_task[i][2]); lower_List.add(i); &#125; &#125; task_rest = task_num - ava_task; rdList.removeAll(rdList); while(rdList.size() &lt; (task_rest+1))&#123; temp = rd.nextInt(rev_num); if((!rdList.contains(temp))&amp;&amp;(lower_List.contains(temp)))&#123; rdList.add(temp); &#125; &#125; for(int i = 0; i &lt; task_rest; i++) &#123; rev_task[rdList.get(i)][2] = String.valueOf(Integer.parseInt(rev_task[rdList.get(i)][2])+1); &#125; &#125;else &#123; task_rest = task_num-ava_task; if(task_rest != 0) &#123; rdList.removeAll(rdList); while(rdList.size() &lt; (task_rest+1))&#123; temp = rd.nextInt(rev_num); if((!rdList.contains(temp))&amp;&amp;(lower_List.contains(temp)))&#123; rdList.add(temp); &#125; &#125; for(int i = 0; i &lt; task_rest; i++) &#123; rev_task[rdList.get(i)][2] = String.valueOf(Integer.parseInt(rev_task[rdList.get(i)][2])+1); &#125; &#125; &#125; &#125; //记录被分配的任务数 for(int i=0;i&lt;rev_num;i++)&#123; rev_task[i][1] = String.valueOf(Integer.parseInt(rev_task[i][1])+Integer.parseInt(rev_task[i][2])); &#125; &#125;&#125; 算法测试类-TestAlgorithm.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.audit.allocationAlgorithm;import java.util.ArrayList;import java.util.List;import java.util.Random;import java.util.Scanner;public class TestAlgorithm &#123; public static void main(String[] args) &#123; Scanner sc=new Scanner(System.in); System.out.println(&quot;请输入任务数：&quot;); int task_num = sc.nextInt(); System.out.println(&quot;请输入审核人员的当前未完成任务数组，整数数字输入时用英文逗号隔开：&quot;); String inputString=sc.next().toString(); String stringArray[]=inputString.split(&quot;,&quot;); int rev_num = stringArray.length;//审核人员总数 String[][] rev_task =new String[rev_num][3]; Random rd = new Random(); List&lt;Integer&gt; rdList = new ArrayList&lt;&gt;(); rdList.removeAll(rdList); int temp; while(rdList.size() &lt; (rev_num+1))&#123; temp = rd.nextInt(100); if(!rdList.contains(temp))&#123; rdList.add(temp); &#125; &#125; System.out.println(&quot;算法前的任务分配：&quot;); for(int i=0;i&lt;rev_num;i++)&#123; rev_task[i][0] = String.valueOf(rdList.get(i) + 1); rev_task[i][1]= stringArray[i]; rev_task[i][2] = &quot;0&quot;; System.out.print(rev_task[i][0]+&quot;,&quot;+rev_task[i][1]+&quot; &quot;); &#125; System.out.println(); AlgorithmUtils.taskAllocation(task_num, rev_num, rev_task);//调用算法工具类 System.out.println(&quot;算法后的任务分配：&quot;); for(int i=0;i&lt;rev_num;i++)&#123; System.out.print(rev_task[i][0]+&quot;,&quot;+rev_task[i][1]+&quot; &quot;); &#125; &#125;&#125; 运行结果： 请输入任务数： 20 请输入审核人员的当前未完成任务数组，整数数字输入时用英文逗号隔开： 1,4,3,5,2,7,2,1 算法前的任务分配： 72,1 63,4 73,3 49,5 74,2 43,7 100,2 20,1 算法后的任务分配： 72,5 63,5 73,5 49,6 74,5 43,7 100,6 20,6 由运行结果可知，20 个任务均衡的分配给了每个审核人员，达到了平均分配的目的！","categories":[{"name":"dev","slug":"dev","permalink":"http://debug.cool/categories/dev/"}],"tags":[]},{"title":"Python可视化绘图","slug":"tipsPythonMatplotlib","date":"2019-01-24T16:00:00.000Z","updated":"2021-05-07T07:30:39.981Z","comments":true,"path":"2019/01/25/tipsPythonMatplotlib/","link":"","permalink":"http://debug.cool/2019/01/25/tipsPythonMatplotlib/","excerpt":"Matplotlib是一个Python的绘图库，粗略理解为py集成MATLAB的功能包。以前学数学建模的时候很讨厌MATLAB，情愿用C来写算法都不想学MATLAB，现在没得法，工作需要分析一些数据，还好Python有这些相关的库，要不然真的要去研究下MATLAB了。","text":"Matplotlib是一个Python的绘图库，粗略理解为py集成MATLAB的功能包。以前学数学建模的时候很讨厌MATLAB，情愿用C来写算法都不想学MATLAB，现在没得法，工作需要分析一些数据，还好Python有这些相关的库，要不然真的要去研究下MATLAB了。 简单图形绘制 根据坐标点绘制： 1234567891011import numpy as npimport matplotlib.pyplot as pltx = np.array([1,2,3,4,5,6,7,8])y = np.array([3,5,7,6,2,6,10,15])plt.plot(x,y,&#x27;r&#x27;)# 折线 1 x 2 y 3 colorplt.plot(x,y,&#x27;g&#x27;,lw=10)# 4 line w# 折线 饼状 柱状x = np.array([1,2,3,4,5,6,7,8])y = np.array([13,25,17,36,21,16,10,15])plt.bar(x,y,0.2,alpha=1,color=&#x27;b&#x27;)# 5 color 4 透明度 3 0.9plt.show() 传入参数是 numpy 数组时的效果： 12345678910111213import numpy as npimport matplotlib.pyplot as pltfor i in range(0,15): # 1 柱状图 dateOne = np.zeros([2]) dateOne[0] = i; dateOne[1] = i; y = np.zeros([2]) y[0] = 10 y[1] = 20 plt.plot(dateOne,y,&#x27;r&#x27;,lw=8)plt.show() 根据函数图像绘制： 12345678910111213141516import matplotlib.pyplot as pltimport numpy as np# 从-1-----1之间等间隔采66个数.也就是说所画出来的图形是66个点连接得来的# 注意：如果点数过小的话会导致画出来二次函数图像不平滑x = np.linspace(-1, 1,66)# 绘制y=2x+1函数的图像y = 2 * x + 1plt.plot(x, y)plt.show()# 绘制x^2函数的图像y = x**2plt.plot(x, y)plt.show() figure 的简单使用 12345678910111213141516171819202122232425import matplotlib.pyplot as pltimport numpy as npx = np.linspace(-1, 1, 50)# figure 1y1 = 2 * x + 1plt.figure()plt.plot(x, y1)# figure 2y2 = x**2plt.figure()plt.plot(x, y2)# figure 3，指定figure的编号并指定figure的大小, 指定线的颜色, 宽度和类型#一个坐标轴上画了两个图形y2 = x**2plt.figure(num = 5, figsize = (4, 4))plt.plot(x, y1)plt.plot(x, y2, color = &#x27;red&#x27;, linewidth = 1.0, linestyle = &#x27;--&#x27;)plt.show() 一共会画出三张图，前两张和上面的简单案例画出来的两张一样。 设置坐标轴 12345678910111213141516171819202122232425import matplotlib.pyplot as pltimport numpy as np# 绘制普通图像x = np.linspace(-1, 1, 50)y1 = 2 * x + 1y2 = x**2plt.figure()plt.plot(x, y1)plt.plot(x, y2, color = &#x27;red&#x27;, linewidth = 1.0, linestyle = &#x27;--&#x27;)# 设置坐标轴的取值范围plt.xlim((-1, 1))plt.ylim((0, 3))# 设置坐标轴的lable#标签里面必须添加字体变量：fontproperties=&#x27;SimHei&#x27;,fontsize=14。不然可能会乱码plt.xlabel(u&#x27;这是x轴&#x27;,fontproperties=&#x27;SimHei&#x27;,fontsize=14)plt.ylabel(u&#x27;这是y轴&#x27;,fontproperties=&#x27;SimHei&#x27;,fontsize=14)# 设置x坐标轴刻度, 之前为0.25, 修改后为0.5#也就是在坐标轴上取5个点，x轴的范围为-1到1所以取5个点之后刻度就变为0.5了plt.xticks(np.linspace(-1, 1, 5))plt.show() 上面代码的基础上加上下面代码（直接加载最后一句代码前面即可）： 123456789101112# 获取当前的坐标轴, gca = get current axisax = plt.gca()# 设置右边框和上边框ax.spines[&#x27;right&#x27;].set_color(&#x27;none&#x27;)ax.spines[&#x27;top&#x27;].set_color(&#x27;none&#x27;)# 设置x坐标轴为下边框ax.xaxis.set_ticks_position(&#x27;bottom&#x27;)# 设置y坐标轴为左边框ax.yaxis.set_ticks_position(&#x27;left&#x27;)# 设置x轴, y周在(0, 0)的位置ax.spines[&#x27;bottom&#x27;].set_position((&#x27;data&#x27;, 0))ax.spines[&#x27;left&#x27;].set_position((&#x27;data&#x27;, 0)) 如果在上面代码的最后一句之前加上下面的代码： 1234# 设置坐标轴label的大小，背景色等信息for label in ax.get_xticklabels() + ax.get_yticklabels(): label.set_fontsize(12) label.set_bbox(dict(facecolor = &#x27;green&#x27;, edgecolor = &#x27;None&#x27;, alpha = 0.7)) 设置 legend 图例 123456789101112131415161718192021222324252627282930313233343536373839404142&quot;&quot;&quot;设置坐标轴&quot;&quot;&quot;import matplotlib.pyplot as pltimport numpy as np# 绘制普通图像x = np.linspace(-1, 1, 50)y1 = 2 * x + 1y2 = x**2plt.figure()plt.plot(x, y1)plt.plot(x, y2, color = &#x27;red&#x27;, linewidth = 1.0, linestyle = &#x27;--&#x27;)# 设置坐标轴的取值范围plt.xlim((-1, 1))plt.ylim((0, 3))# 设置坐标轴的lable#标签里面必须添加字体变量：fontproperties=&#x27;SimHei&#x27;,fontsize=14。不然可能会乱码plt.xlabel(u&#x27;这是x轴&#x27;,fontproperties=&#x27;SimHei&#x27;,fontsize=14)plt.ylabel(u&#x27;这是y轴&#x27;,fontproperties=&#x27;SimHei&#x27;,fontsize=14)# 设置x坐标轴刻度, 之前为0.25, 修改后为0.5#也就是在坐标轴上取5个点，x轴的范围为-1到1所以取5个点之后刻度就变为0.5了plt.xticks(np.linspace(-1, 1, 5))# 获取当前的坐标轴, gca = get current axisax = plt.gca()# 设置右边框和上边框ax.spines[&#x27;right&#x27;].set_color(&#x27;none&#x27;)ax.spines[&#x27;top&#x27;].set_color(&#x27;none&#x27;)# 设置x坐标轴为下边框ax.xaxis.set_ticks_position(&#x27;bottom&#x27;)# 设置y坐标轴为左边框ax.yaxis.set_ticks_position(&#x27;left&#x27;)# 设置x轴, y周在(0, 0)的位置ax.spines[&#x27;bottom&#x27;].set_position((&#x27;data&#x27;, 0))ax.spines[&#x27;left&#x27;].set_position((&#x27;data&#x27;, 0))plt.show() 添加注解和绘制点以及在图形上绘制线或点 1234567891011121314151617181920212223242526272829303132333435363738394041&quot;&quot;&quot;添加注解和绘制点以及在图形上绘制线或点&quot;&quot;&quot;import matplotlib.pyplot as pltimport numpy as np# 绘制普通图像x = np.linspace(-3, 3, 50)y = 2 * x + 1plt.figure()plt.plot(x, y)# 将上、右边框去掉ax = plt.gca()ax.spines[&#x27;right&#x27;].set_color(&#x27;none&#x27;)ax.spines[&#x27;top&#x27;].set_color(&#x27;none&#x27;)# 设置x轴的位置及数据在坐标轴上的位置ax.xaxis.set_ticks_position(&#x27;bottom&#x27;)ax.spines[&#x27;bottom&#x27;].set_position((&#x27;data&#x27;, 0))# 设置y轴的位置及数据在坐标轴上的位置ax.yaxis.set_ticks_position(&#x27;left&#x27;)ax.spines[&#x27;left&#x27;].set_position((&#x27;data&#x27;, 0))# 定义(x0, y0)点x0 = 1y0 = 2 * x0 + 1# 绘制(x0, y0)点plt.scatter(x0, y0, s = 50, color = &#x27;blue&#x27;)# 绘制虚线plt.plot([x0, x0], [y0, 0], &#x27;k--&#x27;, lw = 2.5)# 绘制注解一plt.annotate(r&#x27;$2 * x + 1 = %s$&#x27; % y0, xy = (x0, y0), xycoords = &#x27;data&#x27;, xytext = (+30, -30), \\ textcoords = &#x27;offset points&#x27;, fontsize = 16, arrowprops = dict(arrowstyle = &#x27;-&gt;&#x27;, connectionstyle = &#x27;arc3, rad = .2&#x27;))# 绘制注解二plt.text(-3, 3, r&#x27;$Test\\ text. \\mu \\sigma_i, \\alpha_i$&#x27;, fontdict = &#123;&#x27;size&#x27;: 16, &#x27;color&#x27;: &#x27;red&#x27;&#125;)plt.show() 绘制散点图 1234567891011121314151617181920212223242526&quot;&quot;&quot;绘制散点图&quot;&quot;&quot;import numpy as npimport matplotlib.pyplot as plt# 数据个数n = 1024# 均值为0, 方差为1的随机数x = np.random.normal(0, 1, n)y = np.random.normal(0, 1, n)# 计算颜色值color = np.arctan2(y, x)# 绘制散点图plt.scatter(x, y, s = 75, c = color, alpha = 0.5)# 设置坐标轴范围plt.xlim((-1.5, 1.5))plt.ylim((-1.5, 1.5))# 不显示坐标轴的值plt.xticks(())plt.yticks(())plt.show() 绘制柱状图 1234567891011121314151617181920212223242526272829303132333435&quot;&quot;&quot;绘制柱状图&quot;&quot;&quot;import matplotlib.pyplot as pltimport numpy as np# 数据数目n = 10x = np.arange(n)# 生成数据, 均匀分布(0.5, 1.0)之间y1 = (1 - x / float(n)) * np.random.uniform(0.5, 1.0, n)y2 = (1 - x / float(n)) * np.random.uniform(0.5, 1.0, n)# 绘制柱状图, 向上plt.bar(x, y1, facecolor = &#x27;blue&#x27;, edgecolor = &#x27;white&#x27;)# 绘制柱状图, 向下plt.bar(x, -y2, facecolor = &#x27;green&#x27;, edgecolor = &#x27;white&#x27;)temp = zip(x, y2)# 在柱状图上显示具体数值, ha水平对齐, va垂直对齐for x, y in zip(x, y1): plt.text(x + 0.05, y + 0.1, &#x27;%.2f&#x27; % y, ha = &#x27;center&#x27;, va = &#x27;bottom&#x27;)for x, y in temp: plt.text(x + 0.05, -y - 0.1, &#x27;%.2f&#x27; % y, ha = &#x27;center&#x27;, va = &#x27;bottom&#x27;)# 设置坐标轴范围plt.xlim(-1, n)plt.ylim(-1.5, 1.5)# 去除坐标轴plt.xticks(())plt.yticks(())plt.show() 绘制登高线图 12345678910111213141516171819202122232425262728293031&quot;&quot;&quot;绘制登高线图&quot;&quot;&quot;import matplotlib.pyplot as pltimport numpy as np# 定义等高线高度函数def f(x, y): return (1 - x / 2 + x ** 5 + y ** 3) * np.exp(- x ** 2 - y ** 2)# 数据数目n = 256# 定义x, yx = np.linspace(-3, 3, n)y = np.linspace(-3, 3, n)# 生成网格数据X, Y = np.meshgrid(x, y)# 填充等高线的颜色, 8是等高线分为几部分plt.contourf(X, Y, f(X, Y), 8, alpha = 0.75, cmap = plt.cm.hot)# 绘制等高线C = plt.contour(X, Y, f(X, Y), 8, colors = &#x27;black&#x27;, linewidth = 0.5)# 绘制等高线数据plt.clabel(C, inline = True, fontsize = 10)# 去除坐标轴plt.xticks(())plt.yticks(())plt.show() 绘制 Image 12345678910111213141516&quot;&quot;&quot;绘制Image&quot;&quot;&quot;import matplotlib.pyplot as pltimport numpy as np# 定义图像数据a = np.linspace(0, 1, 9).reshape(3, 3)# 显示图像数据plt.imshow(a, interpolation = &#x27;nearest&#x27;, cmap = &#x27;bone&#x27;, origin = &#x27;lower&#x27;)# 添加颜色条plt.colorbar()# 去掉坐标轴plt.xticks(())plt.yticks(())plt.show() 绘制 3D 图形 1234567891011121314151617181920212223242526272829303132333435&quot;&quot;&quot;绘制3d图形&quot;&quot;&quot;import matplotlib.pyplot as pltimport numpy as npfrom mpl_toolkits.mplot3d import Axes3D# 定义figurefig = plt.figure()# 将figure变为3dax = Axes3D(fig)# 数据数目n = 256# 定义x, yx = np.arange(-4, 4, 0.25)y = np.arange(-4, 4, 0.25)# 生成网格数据X, Y = np.meshgrid(x, y)# 计算每个点对的长度R = np.sqrt(X ** 2 + Y ** 2)# 计算Z轴的高度Z = np.sin(R)# 绘制3D曲面ax.plot_surface(X, Y, Z, rstride = 1, cstride = 1, cmap = plt.get_cmap(&#x27;rainbow&#x27;))# 绘制从3D曲面到底部的投影ax.contour(X, Y, Z, zdim = &#x27;z&#x27;, offset = -2, cmap = &#x27;rainbow&#x27;)# 设置z轴的维度ax.set_zlim(-2, 2)plt.show() subplot 绘制多图 123456789101112131415161718192021&quot;&quot;&quot;subplot绘制多图&quot;&quot;&quot;import matplotlib.pyplot as pltplt.figure()# 绘制第一个图plt.subplot(2, 2, 1)plt.plot([0, 1], [0, 1])# 绘制第二个图plt.subplot(2, 2, 2)plt.plot([0, 1], [0, 1])# 绘制第三个图plt.subplot(2, 2, 3)plt.plot([0, 1], [0, 1])# 绘制第四个图plt.subplot(2, 2, 4)plt.plot([0, 1], [0, 1])plt.show() 123456789101112131415161718192021&quot;&quot;&quot;subplot绘制多图&quot;&quot;&quot;import matplotlib.pyplot as pltplt.figure()# 绘制第一个图plt.subplot(2, 1, 1)plt.plot([0, 1], [0, 1])# 绘制第二个图plt.subplot(2, 3, 4)plt.plot([0, 1], [0, 1])# 绘制第三个图plt.subplot(2, 3, 5)plt.plot([0, 1], [0, 1])# 绘制第四个图plt.subplot(2, 3, 6)plt.plot([0, 1], [0, 1])plt.show() figure 绘制多图 12345678910111213141516171819202122232425&quot;&quot;&quot;figure绘制多图&quot;&quot;&quot;import matplotlib.pyplot as plt# 定义figureplt.figure()# figure分成3行3列, 取得第一个子图的句柄, 第一个子图跨度为1行3列, 起点是表格(0, 0)ax1 = plt.subplot2grid((3, 3), (0, 0), colspan = 3, rowspan = 1)ax1.plot([0, 1], [0, 1])ax1.set_title(&#x27;Test&#x27;)# figure分成3行3列, 取得第二个子图的句柄, 第二个子图跨度为1行3列, 起点是表格(1, 0)ax2 = plt.subplot2grid((3, 3), (1, 0), colspan = 2, rowspan = 1)ax2.plot([0, 1], [0, 1])# figure分成3行3列, 取得第三个子图的句柄, 第三个子图跨度为1行1列, 起点是表格(1, 2)ax3 = plt.subplot2grid((3, 3), (1, 2), colspan = 1, rowspan = 1)ax3.plot([0, 1], [0, 1])# figure分成3行3列, 取得第四个子图的句柄, 第四个子图跨度为1行3列, 起点是表格(2, 0)ax4 = plt.subplot2grid((3, 3), (2, 0), colspan = 3, rowspan = 1)ax4.plot([0, 1], [0, 1])plt.show() 或 123456789101112131415161718192021222324252627&quot;&quot;&quot;figure绘制多图&quot;&quot;&quot;import matplotlib.pyplot as pltimport matplotlib.gridspec as gridspec# 定义figureplt.figure()# 分隔figuregs = gridspec.GridSpec(3, 3)ax1 = plt.subplot(gs[0, :])ax2 = plt.subplot(gs[1, 0:2])ax3 = plt.subplot(gs[1, 2])ax4 = plt.subplot(gs[2, :])# 绘制图像ax1.plot([0, 1], [0, 1])ax1.set_title(&#x27;Test&#x27;)ax2.plot([0, 1], [0, 1])ax3.plot([0, 1], [0, 1])ax4.plot([0, 1], [0, 1])plt.show() figure 图的嵌套 1234567891011121314151617181920212223242526272829303132333435363738394041424344&quot;&quot;&quot;figure图的嵌套&quot;&quot;&quot;import matplotlib.pyplot as plt# 定义figurefig = plt.figure()# 定义数据x = [1, 2, 3, 4, 5, 6, 7]y = [1, 3, 4, 2, 5, 8, 6]# figure的百分比, 从figure 10%的位置开始绘制, 宽高是figure的80%left, bottom, width, height = 0.1, 0.1, 0.8, 0.8# 获得绘制的句柄ax1 = fig.add_axes([left, bottom, width, height])# 绘制点(x,y)ax1.plot(x, y, &#x27;r&#x27;)ax1.set_xlabel(&#x27;x&#x27;)ax1.set_ylabel(&#x27;y&#x27;)ax1.set_title(&#x27;test&#x27;)# 嵌套方法一# figure的百分比, 从figure 10%的位置开始绘制, 宽高是figure的80%left, bottom, width, height = 0.2, 0.6, 0.25, 0.25# 获得绘制的句柄ax2 = fig.add_axes([left, bottom, width, height])# 绘制点(x,y)ax2.plot(x, y, &#x27;r&#x27;)ax2.set_xlabel(&#x27;x&#x27;)ax2.set_ylabel(&#x27;y&#x27;)ax2.set_title(&#x27;part1&#x27;)# 嵌套方法二plt.axes([bottom, left, width, height])plt.plot(x, y, &#x27;r&#x27;)plt.xlabel(&#x27;x&#x27;)plt.ylabel(&#x27;y&#x27;)plt.title(&#x27;part2&#x27;)plt.show() 主次坐标轴 12345678910111213141516171819202122232425&quot;&quot;&quot;主次坐标轴&quot;&quot;&quot;import numpy as npimport matplotlib.pyplot as plt# 定义数据x = np.arange(0, 10, 0.1)y1 = 0.05 * x ** 2y2 = -1 * y1# 定义figurefig, ax1 = plt.subplots()# 得到ax1的对称轴ax2ax2 = ax1.twinx()# 绘制图像ax1.plot(x, y1, &#x27;g-&#x27;)ax2.plot(x, y2, &#x27;b--&#x27;)# 设置labelax1.set_xlabel(&#x27;X data&#x27;)ax1.set_xlabel(&#x27;Y1&#x27;, color = &#x27;g&#x27;)ax2.set_xlabel(&#x27;Y2&#x27;, color = &#x27;b&#x27;)plt.show() 创建动画 1234567891011121314151617181920212223242526272829303132333435&quot;&quot;&quot;动画&quot;&quot;&quot;import numpy as npimport matplotlib.pyplot as pltfrom matplotlib import animation# 定义figurefig, ax = plt.subplots()# 定义数据x = np.arange(0, 2 * np.pi, 0.01)# line, 表示只取返回值中的第一个元素line, = ax.plot(x, np.sin(x))# 定义动画的更新def update(i): line.set_ydata(np.sin(x + i/10)) return line,# 定义动画的初始值def init(): line.set_ydata(np.sin(x)) return line,# 创建动画ani = animation.FuncAnimation(fig = fig, func = update, init_func = init, interval = 10, blit = False, frames = 200)# 展示动画plt.show()# 动画保存#我这里是保存为html文件了，打开即可完美运行ani.save(&#x27;sin.html&#x27;, writer = &#x27;imagemagick&#x27;, fps = 30, dpi = 100)","categories":[{"name":"tips","slug":"tips","permalink":"http://debug.cool/categories/tips/"}],"tags":[{"name":"Matplotlib","slug":"Matplotlib","permalink":"http://debug.cool/tags/Matplotlib/"}]},{"title":"逆向笔记梳理","slug":"noteReverseEnfineering","date":"2018-10-09T23:33:25.000Z","updated":"2021-05-07T07:30:39.984Z","comments":true,"path":"2018/10/10/noteReverseEnfineering/","link":"","permalink":"http://debug.cool/2018/10/10/noteReverseEnfineering/","excerpt":"先把大纲列出来，有空就慢慢更新完善。","text":"先把大纲列出来，有空就慢慢更新完善。 x86 与 x64 x86是基于intel 8086处理器的小端（little-endian）体系结构（IA-32的32位实现），他在两种操作模式下执行 实模式：处理机刚刚上电后只支持 16 位指令集的状态。 保护模式：处理机支持虚拟内存、分页及其他功能的状态。 该体系的64位扩展称为x64或x86-64，x86通过一种称为环级别(ring level)的抽象来支持特权隔离(privilege separation)。 寄存器组与数据类型 运行于保护模式下的x86体系结构有 8 个32位通用寄存器(General Purpose Registers, GPR):EAX、EBX、ECX、EDX、EDI、ESI、EBP、ESP。这些寄存器还能进一步分化成8位和16位寄存器。指令指针存储在EIP寄存器中。 12345678910111213141531 23 15 7 0| EAX || | | AX || | |AH |AL |31 23 15 7 0 31 23 15 7 0| EBP | | ESP || | BP | | | SP |31 23 15 7 0 31 23 15 7 0| ESI | | EDI || | SI | | | DI |31 23 15 7 0 31 23 15 7 0| EIP | | EFLAGS | 寄存器 用途 ECX 循环计数 ESI 字符串/内存操作的源 EDI 字符串/内存操作中的目标 EBP 帧基指针 ESP 栈指针 常用的数据类型有以下几种： 字节(Byte): 8 位，比如 AL、BL、CL。 字(Word): 16 位，比如 AX、BX、CX。 双字(Double Word): 32 位，比如 EAX、EBX、ECX。 四字(Quad Word): 64 位，虽然 x86 并不支持 64 位 GPR，但是在某些场景下可以把两个寄存器(通常是 EDA:EAX)的内容合并起来当作 64 位的值。比如 RDTSC 指令会把一个 64 位值写入 EDX:EAX 寄存器。 32位寄存器EFLAGS用于存储运算状态以及其他运行状态（比如陷阱标志位）。 除了通用寄存器、EIP和EFLAGS，还有一些寄存器用于控制重要的底层系统机制，比如虚拟内存、终端和调试等。例如：CR0寄存器控制分页机制的开关，CR2寄存器中保存着导致缺页异常发生的线性地址，CR3是分页数据结构的基地址，CR4控制硬件虚拟化设置。DR0～DR7寄存器用于设置内存断点。（注意，虽然调试寄存器有 8 个，但系统只支持 4 个内存断点DR0～DR3，其余寄存器用于保存状态） 指令集 x86指令集为寄存器和内存之间的数据移动提供了很大的灵活性。数据移动可以分为 5 种方式： 立即数到寄存器 寄存器到寄存器 立即数到内存 寄存器到内存，或反向 内存到内存 前四种是所有现代体系结构都支持的，而最后一种是x86独有的。像 ARM 这样的经典RISC体系结构只支持通过加载/存储指令（LDR/STR）从内存读出或反向内存写入数据。比如递增内存中数据值需要执行 3 条指令： 把数据从内存读入到寄存器中（LDR） 寄存器加 1（ADD） 把寄存器值写回内存（STR） 而对已x86来说，因为可以直接访问内存，这样的操作只需要一条指令（INC或ADD）。MOVS指令可以同时读写内存。 ARM： 1234561B 68 LDR R3, [R3]; 读入地址R3处的值并保存在R2中5A 1C ADDS R2, R3, #1; 加11A 60 STR R2, [R3]; 把更新后的值写回地址R3处 x86： 12FF 00 inc dword ptr [eax]; 直接递增地址EAX处的值 x86的另一个重要特性是使用了变长指令——指令的长度从1到15字节不等。而在ARM上，指令长度只能是2字节或4字节。 语法 根据汇编器/反汇编器的不同，x86 汇编代码有两种记法：Intel和AT&amp;T。 Intel(Windows 上的记法)： 123mov ecx, AABBCCDDhmov ecx, [eax]mov ecx, eax AT&amp;T(unix 上的 GCC 记法): 123movl $0xAABBCCDD, %ecxmovl (%eax), %ecxmovl %eax, %ecx AT&amp;T 记法在寄存器前加前缀%，立即数前加$。Intel 记法不加前缀。 AT&amp;T 记法加入了指示指令宽度的后缀，比如 MOVL(长整型)、MOVB(字节)等。Intel 记法没有这种标记。 AT&amp;T 记法把源操作数放在目标操作数之前。Intel 记法与之相反。 数据移动 指令用于操作来自寄存器或主内存中的数据。 栈操作与函数调用 C 语言的局部变量就存储在函数的栈空间中。操作系统从ring3切换到ring0时，要把状态信息保存在栈上。具体来讲，x86上的栈是ESP指向的一段连续内存区域，他向下增长。压栈（push指令）递减ESP的值，然后把数据写入 ESP 指向的位置；出栈（pop指令）读出ESP指向位置的数据并递增ESP。默认的自动递增/递减值为 4，但是通过前缀这个值也可以替换为 1 或 2。实际上，这个值几乎总是 4，因为 OS 要求栈双字对齐。 假定ESP最初指向0xb20000，然后执行下面的代码： 12345678910111213; 起始值ESP=0xb20000B8 AA AA AA AA MOV EAX,0AAAAAAAAhBB BB BB BB BB MOV EBX,0BBBBBBBBhB9 CC CC CC CC MOV ECX,0CCCCCCCChBA DD DD DD DD MOV EDX,0DDDDDDDDh50 PUSH EAX; 地址0xb1fffc值将会是0xAAAAAAAA，ESP将会是0xb1fffc （=0xb20000-4）53 PUSH EBX; 地址0xb1fff8的值将会是0xBBBBBBBB，ESP将会是0xb1fff8 （=0xb1fffc-4）5E POP ESI; ESI值将会是0xBBBBBBBB，ESP将会是0xb1fffc （=0xb1fff8+4）5F POP EDI; EDI值将会是0xAAAAAAAA，ESP将会是0xb20000 （=0xb1fffc+4） 其他一些指令也可以直接修改ESP，比如ADD和SUB 高级语言中有函数的概念，函数可以被调用也可以返回，而处理器本身并没有提供这样的抽象。在最底层，处理器只操作具体对象，比如寄存器或内存中的数据。在机器语言这一层级通过栈数据结构来实现函数。 C 代码： 12345int__cdecl addme(short a, short b)&#123; rerurn a+b;&#125; 汇编代码： 12345678910004113A0 55 push ebp004113A1 8B EC mov ebp, esp...004113BE 0F BF 45 08 movsx eax, word ptr [ebp+8]004113C2 0F BF 4D 0C movsx ecx, word ptr [ebp+0ch]...004113CB 8B E5 mov esp, ebp004113CD 5D pop ebp004113CE C3 retn; retn 指令就是把存储在栈顶的地址出栈到EIP，然后把控制传递给他（完全与POP EIP类似，但是x86上并没有这样的指令序列） 通过下面的代码调用函数： C 代码 1sum = addme(x,y); 汇编代码 12345004129F3 50 push eax...004129F8 51 push ecx004129F9 E8 F1 E7 FF FF call addme004129FE 83 C4 08 add esp, 8 先了解一下调用惯例，调用惯例规定了在机器层面如何进行函数调用。对于特定的系统来说他是由应用程序二进制接口(Application Binary Interface, ABI)所定义的。 调用惯例 CDECL STDCALL FASTCALL 参数 从右向左压栈。调用方负责在调用后清理栈 与 CDECL 相同，除了被调用方负责清理栈 前两个参数通过 ECX 和 EDX 传递。其余压栈 返回值 保存在 EAX 中 保存在 EAX 中 保存在 EAX 中 非易失寄存器 EBP、ESP、EBX、ESI、EDI EBP、ESP、EBX、ESI、EDI EBP、ESP、EBX、ESI、EDI 现在我们回到前面的代码片段来讨论函数addme是如何被调用的。 在第 1 行和第 3 行代码中把两个参数压入栈顶，EXC和EAX分别是第一个和第二个参数。第四行代码通过CALL指令调用了addme函数。这立即导致返回地址0x4120FE被压栈，然后0x4113A0处开始执行。 第 4 行代码执行后，就进入了addme函数的函数体。第 1 行代码把EBP压栈。第 2 行代码把EBP设置为指向当前栈顶。这个二指令序列建立了一个新的函数帧，因此通常称为函数序言（function prologue）第 4 行代码读入地址EBP+8的值，他是栈的第一个参数。第 5 行代码读入第二个参数。注意参数访问是以EBP作为基地址的。在这个上下文环境中，EBP被称为帧基指针，因为他指向了当前函数的栈帧，参数和局部变量都可以通过相对他的地址来访问。也可以通过一种称为帧指针省略（frame pointer omission）的优化方法指定编译器生成不使用EBP作为帧指针的代码。这种优化下，局部变量和参数的访问是相对ESP进行的，这时EBP可以作为一个通用寄存器，就像EAX、EBX、EXC等寄存器一样。第六行代码执行数字的加运算，并把结果放入EAX中。第 8 行代码把栈指针设为帧指针。第 9 行代码将之前第 1 行中保存的EBP数值出栈到EBP。这个二指令序列结束了当前的函数调用，并恢复了函数调用前的栈帧通常称为函数尾声（function epilogue）。这个时间点上，栈顶值为CALL指令保存的返回地址0x4129F9。第 10 行执行RET指令，这个指令将栈顶元素出栈并从0x4129FE开始继续执行。代码中的第 5 行把栈收缩了 8 字节大小，因为根据CDECL调用惯例的规定，栈清理的工作必须由调用者完成。 如果函数addme有局部变量，那么代码需要在第 2 行之后通过减小ESP值来增长栈大小。然后所有的局部变量都可以通过EBP加上一个负的偏移量来访问。 控制流 ZF(Zero Flag， 零标志位)：指示之前算术运算的结果是否为 0 SF(Sifn Flag， 符号标志位)：设为当前结果的最高有效位 CF(Carry Flag， 借位标志位)： 指示当前结果是否需要借位。对无符号整数有效。 OF(Over Flag， 溢出标志位)： 只是当前结果是是否超过了最大值。对有符号整数有效。 算术运算指令会根据计算结果更新这些标志位。举例来说，SUB EAX,EAX指令会引起 ZF 标志的设置。Jcc指令会根据这些标志位改变控制流，其中cc是某个条件代码(conditional code)，该指令最多支持 16 中条件代码。 条件代码 跳转条件 机器描述 JZ/JE 若为 0；若相等 ZF = 1 JNZ/JNE 若不为 0；若不相等 ZF = 0 JS 若为负 SF = 1 JNS 若不为负 SF = 0 JP/JPE 若 1 出现的次数为偶数 PF = 1 JNP/JPO 若 1 出现的次数为奇数 PF = 0 JO 若溢出 OF = 1 JNO 若无溢出 OF = 0 JC/JB/JNAE 若进位；若低于；若不高于等于 CF = 1 JNC/JNB/JAE 若无进位；若不低于；若高于等于 CF = 0 JBE/JNA 若低于等于；若不高于 ZF = 1 或 CF = 1 JNBE/JA 若不低于等于；若高于 ZF = 0 或 CF = 0 JL/JNGE 若小于；若不大于等于 SF != OF JNL/JGE 若不小于；若大于等于 SF = OF JLE/JNG 若小于等于；若不大于 ZF != OF 或 ZF = 1 JNLE/JG 若不小于等于；若大于 SF = 0 且 ZF = 0 系统机制 两种基础系统机制：虚拟地址转换（virtual address translation）和异常/中断处理（exception/interrupt handling） 地址转换 计算机系统中的物理内存以4KB为单元作为一个页（page）。实际上页的大小也可以超过4KB，这里我们不讨论其他尺寸的页。内存地址分为两种：虚拟内存和物理内存。在分页启动的情况下，处理器执行的指令中使用的地址是虚拟地址。举例来说： 12A1 78 56 34 12 MOV EAX, [0x12345678] ; 读入虚内地址为0x12345678的内存89 08 MOV [EAX], ECX ; 把ECX写入虚拟地址为EAX处 物理地址是处理器访问内存时使用的实际内存地址。处理器的MMU(Memory Management Unit， 内存管理单元)在访问内存之前透明地把虚拟地址转换为物理地址。在用户开来虚拟地址就是一个数字，而对于MMU来说这个地址则是结构化的。在支持PAE(Physical Address Extension， 物理地址扩展)的x86系统上，虚拟地址可以划分为几个部分，作为偏移量索引到三个表中，包括PDPT(Page Directory Pointer Table，页目录指针表)、PD(Page Directory，页目录)、PT(Page Table， 页表)以及PTE(Page Table Entry，页表项)。PDPT是4个元素的数组，每个元素8字节，指向一个PD。PD是一个有512个元素的数组，每个元素8字节，指向一个PT。PT也是一个有512个元素的数组，每个元素8字节，指向一个PTE。以虚拟地址0xBF80EE6B(转换成二进制：10111111 10000000 11101110 01101011)来理解，如下表： 10(0x2) 111111 100(0x1FC) 00000 1110(0xE) 1110 01101011(0xE6B) 2 位 9 位 9 位 12 位 索引到 PDPT 索引到 PD 索引到 PT 页偏移量 这些表中的 8 字节元素包含关于表、内存访问许可以及其他内存属性的数据。比如，其中有一些位用于标识这个页是只读还是可读写、是否可执行、用户是否可以访问等。 地址转换过程就围绕着这 3 个表和CR3寄存器。CR3寄存器保存着PDPT的物理基地址。 中断与异常 简单讲就是操作系统通过中断和异常机制实现系统调用，完整的实现细节参考 Windows 内核部分。 x64 x64是x86的扩展，所有两者的绝大多数体系结构特性都一样，只有略微不同，比如寄存器宽度，以及某些指令不可再用(比如PUSHAD)。 寄存器组与数据类型补充 x64的寄存器组有18个64位GPR，下面画图解释这些寄存器的结构，注意前缀为R的是64位寄存器。 123456789101164 . . . 31 23 15 7 0|RAX | | | | | | | || | | | |EAX | | | || | | | | | | AX | || | | | | | | AH | AL |64 . . . 31 23 15 7 0|RBP | | | | | | | || | | | |EBP | | | || | | | | | | BP | || | | | | | | | BPL | 虽然RBP任然可以用作帧基指针，但实际应用中编译器生成的代码很少这么用，多数x64编译器只是把RBP当作GPR来用，而用RSP作为基地址引用局部变量。 数据移动补充 x64支持一种称为RIP相对寻址(RIP-relative addressing)的概念，其允许指令引用数据时使用相对RIP的地址。例如： 123450000000000000000 48 8B 05 00 00+ mov rax, qword ptr cs:loc_A ; 最开始写作&quot;mov rax,[rip]&quot;0000000000000007 loc_A:0000000000000007 48 31 C0 xor rax,rax000000000000000A 90 nop 第 1 行读入loc_A的地址（为0x7）然后保存到RAX中。RIP相对寻址主要用于产生位置无关代码。 多数算术运算指令都自动升级为64位，即使操作数只有32位。例如： 123448 B8 88 77 66+ mov rax, 1122334455667788h31 C0 xor eax, eax ; 也会清除RAX的高32位，也就是说执行后RAX=048 C7 C0 FF FF+ mov rax, 0FFFFFFFFFFFFFFFFhFF C0 inc eax ; 执行后RAX=0 规范地址 x64中虚拟地址的宽度是64位，但多数处理器并不支持完整的64位虚拟地址空间。当前Intel/AMD处理器只使用48位地址空间。所有的虚拟地址必须为规范形式。如果一个虚拟地址从第63位到具体实现的最高有效位都是1或者都是0，那么这个虚拟地址就称为规范地址。具体来说，这意味着从48到63位都要和47位相同。如果代码引用一个非规范地址，就会触发系统异常。 函数调用 x86上有一些调用惯例需要通过栈来传递一些参数。对于x64来说，多数调用惯例都是通过寄存器传递参数，比如在windows x64中，只有一种调用惯例用到栈，并且其中前四个参数还是通过RCX、RDX、R8和R9来传递的；其余的参数按照从左到右的顺序压栈。Linux 上，则是前 6 个参数通过RDI、RSI、RDX、RCX、R8和R9传递。 ------------------------本次更新时间 2018-10-16 10:53 ARM 这里介绍的是ARM Architecture Reference Manual ARMv7-A and ARMv777-R Edition (ARM DDI 0406B)中定义的ARM体系结构。 基本特性 ARM是RISC体系结构，因此与CISC体系结构(x86/x64)有一些基本区别。(从实践的角度说，最新版本的Intel处理器也具有一些RISC的特征；也就是说，他们已经不再是纯粹的CISC。)首先，与x86相比，ARM的指令集是很小的，但是提供的通用寄存器更多。第二，指令的宽度是固定的（16位或32位，根据当前状态而定）。第三，ARM的内存访问模式是加载-存储模式。这意味着操作数据之前必须先要把它从内存加载到寄存器中。只有加载/存储指令能够访问内存，具体来说，在ARM中是LDR和STR指令。如果要递增某个内存地址上的32位数值，必须先把数值从这个地址加载到寄存器中，递增，然后再存储回去。x86则允许大多数指令直接操作内存中的数据，只需要简单的加载，操作，递增三步。 ARM还提供了几种不同级别的特权模式来实现特权隔离。x86上的特权级别是通过 4 种ring级别定义的，其中ring0具有最高特权级别，ring3的特权级别最低。在ARM中，有 8 种不同级别的特权模式： USR(USER,用户模式) FIQ(FAST INTERRUPT REQUEST,快速中断请求模式) IRQ(INTERRUPT REQUEST,中断请求模式) SVC(SUPERVISOR, 管理模式) MON(MONITOR,监视模式) ABT(ABORT,中止模式) UND(UNDERFINED,未定义指令模式) SYS(SYSTEM,系统模式) 多数操作系统内核模式运行于SVC。在Windows或Linux上都是。 x64处理器可以运行在32位或64位模式下，也可以交替运行于这两种模式下。ARM处理与之类似，他们也可以运行在两种状态下：ARM和Thumb状态。ARM/Thumb状态决定的只有指令集，而不是特权模式。比如运行子啊在ARM状态下，指令总是32位宽；而在Thumb下，指令可以是16位宽也可以是32位宽。决定处理器执行状态的是以下两个因素。 通过 BX 和 BLX 指令进行分支跳转的时候，如果目标寄存器的最低有效位是 1，就切换到 Thumb 状态。（尽管指令是 2 字节对齐或 4 字节对齐的，但处理器会忽略最低有效位，因此不会有对齐的问题。） 如果当前程序状态寄存器（CPSR）中的 T 标志位被置起，就处于 Thumb 模式。CPSR 的语义会在之后详述，目前可以把它类比为 x86 中扩展的 EFLAGS 寄存器。 ARM核心启动的时候，多数情况下都是进入ARM状态并保持在这个状态，知道显式或隐式地切换到Thumb模式。具体实践中，多数较新的操作系统使用Thumb代码是为了获得更高的代码密度（混合使用16/32位宽度指令的代码大小小于全部使用32位指令），而且应用程序可以运行于任意模式下。因为多数Thumb和ARM指令助记符都是相同的，所以在32位Thumb指令后添加一个.W后缀标识。 注意，有一种很常见的误解，就是把Thumb模式看作x86/x64上的实模式，把ARM模式看作保护模式。x86/x64平台上的绝大多数操作系统运行于保护模式，很少会切换回实模式。位ARM平台上的操作系统和应用程序则可以交替运行于ARM状态和Thumb状态。还要注意，这两个状态与前面介绍的特权模式也是完全不同的概念。 Thumb有两个版本：Thumb-1和Thumb-2。Thumb-1用于ARMv6和更早期的体系结构，指令集宽度都是16位。Thumb-2增加了更多的指令，并支持16位和32位的指令宽度。ARMv7只用Thumb-2，所以只要是讨论Thumb，都是Thumb-2、 ARM状态与Thumb状态还有其他一些区别，这里我们没法全部介绍。比如，某些指令只在ARM状态下支持，而在Thumb状态下不可用，或者反之。要了解更多请参考ARM的官方文档。 ------------------------更新时间 2018-10-17 16:34 数据类型与寄存器 与高级语言类似，ARM也支持多种数据类型的运算，包括：8位（字节），16位（半字）、32位（字）和64位（双字）。 ARM的体系结构定义了16个32位通用寄存器，命名为R0~R15，实际开发中只用前13个作为通用寄存器（就像x86中的EAX、EBX等），最后三个有特殊的意义。 R13 用作栈指针(Stack Point, SP)，等价于 x86/64 下的 ESP、RSP 寄存器，指向程序栈的顶端 R14 用作连接寄存器（Link Register, SP），通常用于在函数调用中保存返回地址。某些指令会隐式的使用这个寄存器。比如，BL 总是在分支跳转到目标地址之前把返回值保存在 LR 中。x86/64 中总是把返回地址放在栈上，所以没有相应的寄存器。在不使用 LR 存储返回地址的代码中，这个寄存器可以作为通用寄存器。 R15 用作程序计数器（Program Counter，PC）。在 ARM 状态下执行的时候，PC 是当前指令的地址加 8（两条 ARM 指令之后）；在 Thumb 状态下，他是当前指令的地址加 4（两条 16 位 Thumb 指令后）。这个寄存器类似与 x86/64 下的 EIP/RIP，但后者总是指向下一条执行指令的地址。另外一个主要的区别在于，ARM 下代码可以直接读写 PC 寄存器，向 PC 寄存器写入一个值会导致运行立即从那个地址开始（参考下面代码片段）。 12340x00008344 push &#123;lr&#125;0x00008346 mov r0,pc0x00008348 mov.w r2, r2, ls1 #310x0000834C pop &#123;pc&#125; 在第 2 行执行之后，R0的值为0x0000834A(=0x00008346+4) 与其他体系结构类似，ARM把当前执行状态信息保存在当前程序状态寄存器（CPSR）中。从应用程序开发者的角度来看，CPSR类似于x86/x84下的EFLAGS/RFLAG寄存器。某些文档中会提到应用程序状态寄存器（APSR），这是CPSR中某些字段的别名。CPSR中有很多标志位，下面列出其中的部分： E(大小端标志位，Endianness bit)：ARM 可以运行在大端或小端模式下。这一位设置为 0 表示小端，1 表示大端。多数情况下使用小端，即为 0。 T(Thumb 标志位)：在 Thumb 状态下，这一位会设为 1；否则就是 ARM 状态。从 Thumb 到 ARM 或反向的状态切换的方式之一，就是修改这一标志位。 M(模式标志位， Mode Bit)：这几位指定当前的特权模式（USR、SVC 等）。 12 31 26 15 10 9 5 4 0CPSR |cond.flags | |1T |大小端标志位E | |Thumb标志位T |模式标志位M | ------------------------更新时间 2018-10-18 09:30 系统级控制与设置 ARM提供了协处理器的概念来支持额外的指令和系统级设置。举例来说，如果系统支持内存管理单元(MMU, Memory Management Unit)，那么内存管理单元的配置接口必须提供给启动代码或内核代码。在x86/x64上，这些设置接口是放在CR0和CR4中的；而在ARM上，则放在CP15中，ARM体系结构中有16个协处理器，编号为CP0~CP15.前 13 个协处理器时可选的或者是ARM保留的。制造商可以通过可选协处理器实现特定的指令或功能，每个协处理器提供了额外的“操作码”和寄存器，可以通过专门的ARM指令控制。举例来说，CP10和CP11常常用于调试和系统设置。而且CP15通常被称为系统控制协处理器，它保存着绝大多数系统设置（缓存、分页、异常等）。 1注意：NEON提供了单指令多数据（SIMD）指令集，通常用于多媒体应用程序。它与基于x86体系结构的SSE/MMX指令类似。 每个协处理器有16个寄存器和8个相应的操作码。这些寄存器和操作码的语义是特定于协处理器的。协处理器只能通过MRC(读)和MCR(写)指令访问，这两个指令接受协处理器编号、寄存器编号和操作码作为参数。举例来说，要读出转换基址寄存器(类似于x86/x64中的CR3)并保存到R0中，可以使用如下代码： 1MRC p15, 0, r0, c2, c0, 0 ; 保存到TTBR中 这句代码表示：“使用操作码0/0读出CP15的C2/C0，并保存结果到通用寄存器R0。”因为每个协处理器有很多寄存器和操作码，需要阅读文档才能确定其中每一个的精确含义。有些寄存器（C13/C0）是操作系统保留的，用于保存特定于进程或线程的数据。 MRC和MCR指令并不需要高特权级别才能运行（也就是说，可以在 USR 模式下执行），但有些协处理器寄存器和操作码只能在SVC模式下访问，如果没有足够的特权级别，该寄存器会导致异常。在实际的用户模式代码中很少看到这些指令，他们通常用在像ROM、bootloader、固件这样很底层的代码或内核模式代码中。 ------------------------更新时间 2018-10-21 13:10 指令集介绍 相比起x86体系结构，除了条件执行和桶式移位器，ARM 的指令集还有几点独特之处。首先，有些指令可以一次操作一系列寄存器。比如要把 5 个寄存器R6~R10保存到R1指向的一段内存位置，可以使用指令STM R1,&#123;R6-R10&#125;。R6会保存到内存地址R1，R7保存到R1+4，R8保存到R1+8，以此类推。对于不连续的寄存器，可以用逗号分隔（比如&#123;R1,R5,R8&#125;）。ARM的汇编语法中，寄存器范围通常用花括号表示。其次，有些指令在读写操作之后可能会更新基址寄存器，这通常通过在寄存器名后添加感叹号!来表示。举例来说，如果把前面的指令改写为STM R1!, &#123;R6-R10&#125;并执行，那么R1将会被更新为保存R10的地址之后的下一个地址。 ------------------------更新时间 2018-10-22 08:10 数据加载与存储 ARM是一种加载-存储式的体系结构，这意味着数据一定要加载到寄存器中才能操作。只有加载和存储指令能够访问内存，所有其他指令都只能操作寄存器。加载是指从内存中读入数据并保存到寄存器中的过程，存储则是指把寄存器的内容写入内存中的过程。在ARM体系结构中，加载和存储指令包括LDR/STR、LDM/STM和PUSH/POP。 LDR 与 STR LDR/STR指令比较基础的形式是，接受一个基址寄存器和一个偏移量作为参数。偏移量的表示有三种格式（立即数、寄存器、标量寄存器），每种格式有三种寻址形式。 第一种形式使用立即数作为偏移量。立即数就是一个整数。把这个数字与基址寄存器相加或相减，用于访问编译期偏移量可知的数据。立即数最常见的用途是访问结构或虚函数表中的某个特定字段。一般形式： STR Ra, [Rb, imm] LDR Ra, [Rc, imm] Rb是基址寄存器，imm是要加到Rb的偏移量 第二种偏移量格式用一个寄存器作为偏移量，通常用于访问数组中的元素，其索引值是运行时计算出的情况。其一般格式如下： STR Ra, [Rb, Rc] LDR Ra, [Rb, Rc] 根据上下文的不同，Rb或Rc可以是基址或偏移量。 第三种偏移量格式是使用标量寄存器作为偏移量。通常这种形式用在数组的迭代循环，而桶式移位器用于计算偏移量的步长。这种格式的一般形式如下： STR Ra, [Rb, Rc, &lt;shifter&gt;] LDR Ra, [Rb, Rc, &lt;shifter&gt;] Rb 是基址寄存器，Rc 是一个立即数，&lt;shifter&gt;是在立即数上执行的操作，他通常通过一个左移或右移操作对立即数进行成比例放大或缩小。 ------------------------更新时间 2018-10-23 07:30 LDR 的其他用途 LDR用于从内存向寄存器中加载数据，但有时候会看到这样的形式： 12301: DF F8 50 82 LDR.W R8, =0x2932E00 ; LDR R8, [PC, x]02: 80 4A LDR R2, =a04d ; &quot;%04d&quot; ; LDR R2, [PC, y]03: 0E 4B LDR R3, =__imp_realloc ; LDR R3, [PC, z] 伪指令内部使用了立即数寻址形式的LDR指令，PC作为基址寄存器。有时这也成为PC相对寻址（或在x64上称为RIP相对寻址）。ARM二进制文件通常有一个文本池（literal pool），这是某个字段中的一块内存区域，用于保存常量、字符串和用于提供位置无关索引支持的偏移量。（文本池是代码的一部分，所以在同一段中。）在前面的代码片段里，代码引用了保存在文本池中的一个32位常量、一个字符串和一个导入函数的偏移量。利用这种伪指令，可以只通过一个指令就把 32 位常量移入寄存器，因此它是很有用的。为了更清晰一点，下面给出一段代码示例： 1234501: .text:0100B134 35 4B LDR R3, =0x68DB8BAD; 实际上就是LDR R3, [PC, #0xD4]; 这时PC = 0x0100B13802: ...03: .text:0100B20C AD 8B DB 68 dword_100B20C DCD 0x68DB8BAD 因为代码处于Thumb状态，PC值是当前指令加上4，也就是0x0100B138。这里使用了立即数寻址方式，所以要读出位于0x0100B20C（=0x0100B138+0x4D）的字，这就是我们想要加载的常量。 ------------------------更新时间 2018-10-26 07:00 LDM 与 STM LDM和STM与LDR/STR类似，区别是前者可以从给定的基址寄存器加载多个字。LDM和STM通常用于从内存读出或写入多个数据块，通常语法为： 12LDM&lt;mode&gt; Rn[!], &#123;Rm&#125;STM&lt;mode&gt; Rn[!], &#123;Rm&#125; Rn是基址寄存器，其中保存要加载/存储的内存地址。！是可选的，意思是基址寄存器会更新为新的地址（写回）。Rm是要加载或存储的范围。LDM和STM有四种模式。 IA（后递增，Increment After）模式把数据存储到基址寄存器指定的内存位置。如果有写回的话，就写回最后一个地址加 4 字节的地址。如果没有指定的话，这是默认使用的模式。 IB（前递增，Increment Before）模式把数据存储在基址寄存器加 4 的地址上。如果有写会的话，就把最后地址写回。 DA（后递减，Decrement After）模式保存数据使得最后的地址是基地址。如果有写回的话，就把最低地址减 4 写回。 DB（前递减，Decrement Before）模式存储数据使得最后的地址是基地址减 4.如果有写回的话，就把最低地址写回。 下面是调试器观察的实例： 123456789101112131415161718192021222324252627282930(gdb) br mainBreakpoint 1 at 0x8344(gdb) disas mainDump of assembler code for function main:0x00008344 &lt;+0&gt;: ldr r6, =mem ; 稍有修改0x00008348 &lt;+4&gt;: mov r0, #100x0000834c &lt;+8&gt;: mov r1, #110x00008350 &lt;+12&gt;: mov r2, #120x00008354 &lt;+16&gt;: ldm r6, &#123;r3,r4,r5&#125; ; IA模式0x00008358 &lt;+20&gt;: stm r6, &#123;r0,r1,r2&#125; ; IA模式...(gdb) rBreakpoint 1, 0x00008344 in main ()(gdb) si0x00008348 in main ()(gdb) x/3x $r60x105c &lt;mem&gt;: 0x00000001 0x00000002 0x00000003(gdb) si0x0000834c in main ()...(gdb)0x00008358 in main ()(gdb) info reg r3 r4 r5r3 0x1 1r4 0x2 2r5 0x3 3(gdb) si0x0000835c in main ()(gdb) x/3x $r60x1050c &lt;mem&gt;: 0x0000000a 0x0000000b 0x0000000c 第 5 行把一个内存地址写入R6，这个内存地址（0x1050c）的内容是一个 3 字数据（第 17 行）。6-8 行将R2～R0设置为某个常量。第 9 行加载从R6指向的内存地址开始的 3 个字到R3～R5。如第 24 ～ 26 行所示，R3～R5的内容正是期望值。第 10 行存储R0~R2到R6指向的内存地址开始的空间。第 29 行显示了期望的写入值。下图展示前面的操作结果。 123456789101112131415161718192021222324252627282930 mem|---|| 0x1 | | | ldr r6, =mem || --- ||| mov r0, #10| 0x2 | | | mov r1, #11 || --- ||| mov r2, #12| 0x3 | | | ldm r6, &#123;r3,r4,r5&#125; || --- |\\/|---|| 0x1 | r6 | | stm r6, &#123;r0,r1,r2&#125; || --- |||| 0x2 | r6+4 | || --- |||| 0x3 | r6+8 | || --- |\\/r0=a r1=b r2=cr3=1 r4=2 r5=3|---|| 0xA | r6 || --- || 0xB | r6+4 || --- || 0xC | r6+8 || --- |r0=a r1=b r2=cr3=1 r4=2 r5=3 下面用写回模式做同样的实验： 123456789101112131415161718192021222324252627282930(gdb) br mainBreakpoint 1 at 0x8344(gdb) disaa mainDump of assembler code for function main:0x00008344 &lt;+0&gt;: ldr r6, =mem ; 稍有修改0x00008348 &lt;+4&gt;: mov r0, #100x0000834c &lt;+8&gt;: mov r1, #110x00008350 &lt;+12&gt;:mov r2, #120x00008354 &lt;+16&gt;:ldm r6!, &#123;r3, r4, r5&#125; ; IA带写回模式0x00008358 &lt;+20&gt;:stmia r6!, &#123;r0, r1, r2&#125; ; IA带写回模式...(gdb) rBreakpoint 1, 0x0008344 in main ()(gdb) si0x00008348 in main ()...(gdb)0x00008354 in main ()(gdb) x/3x $r60x1050c &lt;mem&gt;： 0x000001 0x00000002 0x00000003(gdb) si0x00008358 in main ()(gdb) info reg r6r6 0x10518 66840(gdb) si0x0000835c in main ()(gdb) info reg $r6r6 0x10524 66852(gdb) x/4x $r6-120x10518 : 0x0000000a 0x0000000b 0x0000000c 0x00000000 第 9 行使用IA写回模式，所以R6更新为最后地址加 4 的值（第 23 行）。第 10 行、27 行和 30 行可以看到同样的模式。下图展示了实验代码片段执行的结果： 12345678910111213141516171819202122232425262728293031323334 mem|---|| 0x1 | 0x1050c | | ldr r6, =mem || --- ||| mov r0, #10| 0x2 | 0x1050c+4 | | mov r1, #11 || --- ||| mov r2, #12| 0x3 | 0x1050c+8 | | ldm r6!, &#123;r3,r4,r5&#125; || --- |0x1050c+c \\/|---|| 0x1 | 0x1050c | | stm r6, &#123;r0,r1,r2&#125; || --- |||| 0x2 | 0x1050c+4 | || --- |||| 0x3 | 0x1050c+8 | || --- |0x1050c+c r6 \\/r0=a r1=b r2=cr3=1 r4=2 r5=3|---|| 0x1 | 0x1050c || --- || 0x2 | 0x1050c+4 || --- || 0x3 | 0x1050c+8 || --- || 0xA | 0x1050c+c || --- || 0xB | 0x1050c+10 || --- || 0xC | 0x1050c+14 || --- | 0x1050c+18 r6 | LDM和STM指令可以一次写入多个字，所以通常用于块复制和块移动操作。比如有时用这些指令来执行编译时复制长度已知的内联memcpy。这类似于x86中带有REP前缀的movs指令。 注意 STM/LDM后面经常会出现后缀FD、FA、ED或EA。它们就是不同模式下（IA/IB等）的STM/LDM指令的伪指令，分别对应于STMFD/STMDB、STMFA/STMIB、STMED/STMDA、STMEA/STMIA、LDMFD/LDMIA、LDMFA/LDMDA和LDMEA/LDMDB。因为这些对应关系太难记忆，建议为每个指令画一个图。 ------------------------更新时间 2018-11-4 08:00 PUSH 与 POP 加载/存储指令的最后一组是PUSH和POP。他们类似于LDM/STM，但有两点不同： 他们隐式地使用 SP 作为基地址； SP 会自动更新。 和x86/x64中的一样，栈是朝下向低地址方向增长的。通用的语法是PUSH/POP &#123;Rn&#125;,其中Rn可以是一个寄存器范围。 PUSH指令把一个或多个寄存器保存在栈中，使得最后一个的位置位于当前栈指针向下 4 字节处，然后把SP更新为第一个位置的地址。POP从当前栈指针处开始向寄存器加载数据，然后更新SP为最后一个位置的地址的向上 4 字节处。PUSH/POP实际上就是以SP作为基地址指针的带写回的STMDB/LDMIA。 最常用到PUSH/POP的地方就是在函数的起始和结束处，在这里他们被用作函数序言和尾声（就像ARM状态下的STMFD/LDMFD一样）。举例来说： 1232D E9 F0 4F PUSH.W &#123;R4-R11, LR&#125; ; 保存寄存器和返回地址...BD E9 F0 8F POP.W &#123;R4-R11, PC&#125; ; 恢复寄存器值并返回 ------------------------更新时间 2018-11-5 07:00 函数与函数调用 x86/x64只有一个用于函数调用的指令（CALL）和一个用于分支跳转的指令（JMP）。与之不同，根据目标地址的编码方式，ARM 则提供了多种指令。调用函数的时候，处理器需要知道函数返回后从哪里继续执行，这个位置通常被称为返回地址。在x86中，CALL指令在跳转到目标函数之前隐式地把返回地址压入栈顶，等到目标函数执行完毕，会把栈顶弹出到EIP，从而从返回地址恢复执行。 ARM体系结构上的机制本质上也是如此，只有几点微小的区别。首先，返回地址可以保存在栈上，也可以保存在链接寄存器（LR）中；调用结束后要恢复执行，需要显式地把返回地址从栈上弹出到PC寄存器，否则会无条件跳转到LR。其次，根据目标地址的最低位（LSB）不同，一次分支跳转可以在ARM状态和Thumb状态之间切换。第三点，ARM定义了标准调用惯例：前 4 个 32 位参数通过寄存器（R0-R3）传递，其余的参数放在栈上。返回值保存在R0中。 ARM中函数调用的指令是B、BX、BL和BLX。 尽管在函数调用的上下文中很少看到B指令，但这条指令确实可以用于控制传递。他就是一条简单的无条件跳转指令，于x86中的JMP指令相同，通常在循环和条件执行内部用于跳转到开头或跳出循环，还可以用于调用永不返回的函数。 B指令只能使用标签偏移量作为其目标地址，而不能使用寄存器。在这种情况下，B指令的语法为B imm，其中imm是相对于当前指令的偏移量。（这里没有考虑条件执行标志位，将会在之后的笔记中详细介绍。）需要记住的是：因为ARM和Thumb指令是2字节或4字节对齐的，所以目标偏移量必须是一个偶数。 BX是分支跳转并交换（Branch and Exchange）。与B指令的相似之处在于，两者都是把控制转移到某个目标地址处，但BX能够在ARM和Thumb状态间切换，并且目标地址是保存在寄存器中的。分支跳转指令以X结尾，表示这条指令能切换状态。如果目标地址最低位是 1，那么处理器会自动切换到Thumb状态，否则就执行在ARM状态。指令的格式是BX&lt;寄存器&gt;，其中寄存器中存有目标地址。这条指令有两种最常用的方式，一种是通过跳转到LR（也即 BX LR）从函数返回，还有一种是用于切换到不同状态的代码（也即从ARM切换到Thumb状态或反之）。在编译后的代码中，函数结尾处几乎总会出现BX LR，基本上于x86中的RET相同。 BL是分支跳转并连接（Branch with Link），它类似于B指令，但他可以在把控制切换到目标偏移量之前把返回地址保存到LR。这也许是和x86中的CALL指令最为接近的一条指令，经常在函数调用中使用。BL指令格式与B指令相同（也就是说，只接受偏移量参数）。下面这段代码解释了函数调用和返回的过程： 1234567800014350 BL foo ; LR = 0x0001435400014354 MOVS R4, #0x15...0001B224 foo0001B224 PUSH &#123;R1-R3&#125;0001B226 MOV R3, 0x6124...0001B24C BX LR ; 返回到0x00014354 上面代码的第 1 行使用BL调用函数foo。在转换控制到目标之前，BL在LR中保存了返回地址（0x000014354）。foo做了一些工作然后返回到调用者（BX LR）。 BLX是指跳转加连接和交换（Branch with Link and Exchange）。于BL类似，BLX也可以支持状态切换。两者主要的区别在于，BLX可以接受偏移量或寄存器作为跳转目标，而且在BLX指令使用偏移量的情况下，处理器总是会切换状态（ARM到Thumb或反之）。因为这条指令于BL的特性相同，也可以把它当做x86中的CALL指令。实际使用中，BL和BLX都用于实现函数调用。如果函数在32MB范围之内，通常使用BL，而目标区域不确定（比如函数指针）的时候常用BLX。通常在Thumb状态下运行的时候，使用BLX指令调用库例程，而在ARM状态下使用BL。 ------------------------更新时间 2018-11-9 07:00 算术运算 把数值从内存加载到寄存器之后，代码就可以上面执行各种操作了。最简单的操作就是通过mov指令把数据移动到另一个寄存器中。操作源可以是常量、寄存器或桶式移位器的运算结果。桶式移位器运算包括左移（LSL）、右移（LSR、ASR）和循环移位（ROR、RRX）。桶式移位器让指令可以操作无法以立即数形式编码的常量，因此很有用处。ARM和Thumb指令的宽度可能是16位或32位，所以无法直接使用32位常数作为参数。有了桶式移位器，立即数可以被转换为一个更大值然后移动到其他寄存器。另一种移动32位常量到寄存器的方法是把常量分割为两个16位数值，分两次移动；这通常通过MOVW和MOVT指令实现。MOVT设置寄存器的高16位，MOVW设置低16位。 基本算术和逻辑运算包括ADD、SUB、MUL、AND、ORR和EOR。 注意：ARM没有原生的除法指令。（ARMv7-R和ARMv7-M内核有SDIV和UDIV指令，但这里不讨论）实际应用中，运行时会使用软件实现来进行除法运算，代码只要按需调用。下面是Windows C运行时的一个例子： 12341 46 MOV R1， R840 46 MOV R0,R635 F0 9E 9F BL __rt_udiv ; udiv的软件实现 ------------------------更新时间 2018-11-11 07:00 分支跳转与条件执行 前面讨论的都是按照线性顺序执行的例子，而绝大多数程序都包含有条件与循环。在汇编代码层级，这些结构是通过存储在应用程序状态寄存器（APSR）中的条件标志位实现的。APSR是CPSR的别名，类似于x86中的EFLAG寄存器。 N（Negative，负值标志位）：如果运算的结果是负数，这个标志就会被设置（结果的最高有效位为 1） Z（Zero，零标志位）：运算结果为 0 时设置 C（Carry，借位标志位）：两个无符号值计算结果溢出时设置 V（Overflow，溢出标志位）：两个有符号值计算结果溢出时设置 IT（If-then 标志位）：这些标志位编码了 Thumb 指令 IT 使用的各种条件。 1234567 31 26 15 10 9 5 4 0CPSR |cond.flags | |1T |大小端标志位E | |Thumb标志位T |模式标志位M |...APSR |N|Z|C|V|Q | |保留| 31 26 15 0 N、Z、C 和 V 标志位与 x86 中的 EFLAG 寄存器的 SF、ZF、CF 和 OF 标志位相同。在更高级的语言中，使用这些标志位来实现条件和循环；在指令级代码中，也通过这些标志位支持条件执行。通过这些标志位来描述相等性。 后缀/编码 意义 标志位 EQ 等于 Z==1 NE 不等于 Z==0 MI 减、负 N==1 PL 加、正或者为 0 N==0 HI 无符号大于 C1 且 Z0 LS 无符号小于 C0 或 Z1 GE 有符号大于等于 N==V LT 有符号小于 N！=V GT 有符号大于 Z0 且 NV LE 有符号小于等于 Z==1 或 N！=V 默认情况下指令不会更新条件标志位，除非使用了 S 后缀。比较指令（CBZ、CMP、TST、CMN 和 TEO）会自动更新标志位，因为通常他们被用于分支指令之前。 最常用的比较指令可能就是 CMP。其语法为 CMP Rn, X，其中 Rn 是寄存器，X 可以是立即数、寄存器或桶式移位操作。其语义与 x86 中的同名指令相同：执行 Rn - X，设置相应的标志位，然后丢弃结果。通常这条指令后面会跟随一个条件分支跳转。下面是一个用法示例及其伪代码： ARM 123456789101112B3 EB E7 7F CMP.W R3, R7, ASR #3105 DB BLT loc_less01 DC BGT loc_greaterBD 42 CMP R5, R702 D9 BLS loc_less loc_greater07 3D SUBS R5, #76E F1 00 0E SBC.W LR, LR, #0 loc_lessA5 FB 08 12 UMULL.W R1, R2, R5, R887 FB 08 04 SMULL.W R0, R4, R7, R80E FB 08 23 MLA.W R3, LR, R8, R2 C 伪代码 123if (r3 &lt; r7) &#123;goto loc_less;&#125; else if (r3 &gt; r7) &#123;goto loc_greater;&#125; else if (r5 &lt; r7) &#123;goto loc_less;&#125; ------------------------更新时间 2018-11-12 07:00 Thunb 状态 switch-case 杂项 Windows 内核 调试与自动化 代码混淆 代码研究 windows 内核代码 片段 1： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980; NTSTATUS __cdecl sub_4038f0(PFILE_OBJECT FileObject, HANDLE Handle, BOOLEAN flag)sub_4038F0 proc nearpush rbx ; rbx压栈push rbp ; rbp压栈push rsi ; rsi压栈push rdi ; rdi压栈push r12 ; r12压栈sub rsp, 60h ; rsp的值减去0x60mov bpl, r8b ; r8p的值入bplmov r12, rdx ; 将rdx的值放进栈r12中mov rdi, rcx ; 将rcx的值放进栈rdi中mov cs:IoGetRelatedDeviceObject ; IoGetRelatedDeviceObject返回值指向相应设备对象的指针mov [rsp+88h+arg_18], 1 ; 把1赋给[rsp+88h+arg_18]xor edx, edx ; ChargeQuota 将edx初始化置0mov cl, [rax+4ch] ; StackSize 栈空间大小mov rsi, rax ; 将rax的值放进栈rsi中call cs:IoAllocateIrp ; IoAllocateIrp例程分配一个IRP（为每个驱动层下的调用者给定I/O堆栈数量和选项）test rax, rax ; 相当于and rax rax，根据结果设置标志位，不会保存结果。（影响标志位C,O,P,Z,S。其中C与O两个标志会被设为0）mov rbx, rax ; 将rax的值放进栈rbx中jnz short loc_403932 ; 如果Z标志位为0，就跳转到loc_403932中mov eax, 0C0000017h ; 把立即数0C0000017h放进eax（此处用来表示跳转失败）。立即数必须以数开头，以字母开头会被认为是寄存器或变量。jmp loc_403A0C ; 无条件跳转到 loc_403A0C方法（loc_403A0C方法的作用是清理栈空间）loc_403932:lea rax, [rsp+88h+arg_18] ; rax获取[rsp+88h+arg_18]的地址xor r8d, r8d ; State 状态值初始化为0lea rcx, [rsp+88h+Event] ; Event rcx获取[rsp+88h+Event]的地址mov [rbx+18h], rax ; IRP.AssociatedIrp.SystemBuffer 把rax所指向地址的值赋给[rbx+18h]，也就是把1赋给[rbx+18h]lea rax, [rsp+88h+Event] ; rax获取[rsp+88h+Event]的地址lea edx, [r8+1] ; Type 类型 edx获取[r8+1]的地址mov [rbx+50h], rax ; IRP.UserEvent 把rax所指向[rsp+88h+Event]地址的值赋给[rbx+50h]，作为用户事件lea rax, [rsp+88h+var_58] ; rax获取[rsp+88h+var_58]的地址mov [rbx+48h], rax ; IRP.UserIosb 把rax所指向[rsp+88h+var_58]地址的值赋给[rbx+48h]mov rax, gs:+188h ; KPCR.Prcb.CurrentThread gs寄存器基址+18h得到的地址处的值，赋给raxmov [rbx+0C0h], rdi ; IRP.Tail.OVerlay.OriginalFileObiect 把寄存器rdi的值（也就是前面rcx的值）放进内存[rbx+48h]中mov [rbx+98h], rax ; IRP.Tail.Overlay.Thread gs寄存器基址+18h处的值放进内存[rbx+98h]mov byte ptr [rbx+40h], 0 ; IRP.RequestorMode 把[rbx+40h]处的一个字节填为0call cs:KeInitializeEvent ; 调用 KeInitializeEvent方法将一个事件对象初始化为一个同步或通知类型的事件，并且设置为一个有信号或无信号的状态test bpl, bpl ; and bpl bpl，根据结果设置标志位，不会保存结果。C与O会被设置为0.mov rcx, [rbx+0B8h] ; 将内存[rbx+0B8h]处的值放进rcx中mov byte ptr [rbx+40h], 6 ; IRP_MJ_SET_INFORMATION 把[rbx+40h]处的一个字节填为6mov [rcx-20h], rsi ; IO_STACK_LOCATION.DeviceObject 将rsi处的值放进内存[rcx-20h]中mov [rcx-18h], rdi ; IO_STACK_LOCATION.FileObject 将rdi处的值放进内存[rcx-18h]中jz short loc_4039A6 ; 如果Z标志位为1，就跳转到loc_4039A6中mov rax, [rdi+28h] ; FILE_OBJECT.SectionObjectPointer 将内存[rdi+28h]中的值放进rax中test rax, rax ; and rax rax，根据结果设置标志位，不会保存结果。C与O会被设置为0.jz short loc_4039A6 ; 如果Z标志位为1，就跳转到loc_4039A6中mov [rax+10h], 0 ; SECTION_OBJECT_POINTERS.ImageSectionObject 将[rax+10h]置为0loc_4039A6:mov [rcx-28h], r12 ; IO_STACK_LOCATION.Parameters.SetFile.DeleteHandle 将寄存器r12中的值放进[rcx-28h]中mov [rcx-30h], rdi ; IO_STACK_LOCATION.Parameters.SetFile.Object 将寄存器rdi中的值放进[rcx-30h]中mov dword ptr [rcx-38h], 0Dh ; FileDispositionInformation IO_STACK_LOCATION.Parameters.SetFile.FileInfomationClass 将[rcx-38h]处的双字设置为0Dhmov dword ptr [rcx-40h],1 ; IO_STACK_LOCATION.Parameters.SetFile.Length 将[rcx-40h]处的双字设置为1mov rax, [rbx+0b8h] ; CurrentIrpStackLocation 将[rbx+0b8h]处的值放进rax中lea rcx, sub_4038B4 ; completionroutine rcx获取sub_4038B4的地址mov [rax-10h], rcx ; IO_STACK_LOCATION.ComplerionRoutine 将rcx指向sub_4038B4的地址处的值放进[rax-10h]中mov rcx, rsi ; DeviceObject 将rsi处的值放进rcx中mov rdx, rbx ; Irp 将rbx处的值放进rdx中mov qword ptr [rax-8], 0 ; 将内存[rax-8]处的双字设置为0mov byte ptr [rax-45h], 0E0h ; flag 将内存[rax-45h]处的一个字节设置为0call cs:IofCallDriver ; 调用IofCallDriver方法cmp eax, 103h ; STATUS_PENDING 比较eax和103hjnz short loc_403A09 ; 如果eax和103h不相等就跳转到loc_403A09lea rcx, [rsp+88h+Event] ; Object rcx获取[rsp+88h+Event]的地址mov r9b, 1 ; Alertable 将r9b赋值为1xor r8d, r8d ; WaitMode r8d置为0xor edx, edx ; WaitReason edx置为0mov [rsp+88h+var_68], 0 ; 将[rsp+88h+var_68]置为0call cs:KeWaitForSingleObject ; 调用该方法将当前线程(ethread里以Wait开头的字段WaitIrql,WaitMode,WaitStatus)置为等待状态,直到提供的分发机器对象被置为已处理状态或第五个参数给出的Timeout走完。loc_403A09:mov eax, [rbx+30h] ; IRP.IoStatus.Status 将内存[rbx+30h]处的值赋给eaxloc_403A0C: ; 清理栈add rsp, 60h ; 栈指针rsp+60h进行复位pop r12 ; 出栈r12pop rdi ; 出栈rdipop rsi ; 出栈rsipop rbp ; 出栈rbppop rbx ; 出栈rbxretnsub_4038F0 endp","categories":[{"name":"notes","slug":"notes","permalink":"http://debug.cool/categories/notes/"}],"tags":[]},{"title":"如何编写一个简单内核","slug":"noteKernelProgram","date":"2018-09-04T06:04:00.000Z","updated":"2021-05-07T07:30:39.981Z","comments":true,"path":"2018/09/04/noteKernelProgram/","link":"","permalink":"http://debug.cool/2018/09/04/noteKernelProgram/","excerpt":"编写一个简单的内核，可以再 x86 系统上加载 GRUB 引导加载程序。此内核将在屏幕上显示一条信息，然后挂起。","text":"编写一个简单的内核，可以再 x86 系统上加载 GRUB 引导加载程序。此内核将在屏幕上显示一条信息，然后挂起。 x86 机器是如何启动的 在我们考虑编写内核之前，让我们看看机器是如何启动并将控制转移到内核的。 上电后，x86 CPU的大多数寄存器都有明确定义的值。指令指针（EIP）寄存器保存处理器正在执行的指令的存储器地址。EIP硬编码为值0xFFFFFFF0，因此，x86 CPU硬连线开始在物理地址0xFFFFFFF0处执行。实际上，它是32位地址空间的最后16个字节。该存储器地址称为复位向量。 现在，芯片组的内存映射确保0xFFFFFFF0映射到BIOS的某个部分，而不是RAM。同时，BIOS将自身复制到RAM以便更快地访问，我们称之为shadowing。地址0xFFFFFFF0只包含一条跳转指令，指向BIOS复制自身的内存中的地址。 到这里，BIOS代码开始执行。BIOS首先按配置的引导设备顺序搜索可引导设备。它会检查某个幻数以确定设备是否可引导（第一扇区的字节 511 和 512 是否为0xAA55）。 一旦BIOS找到可引导设备，它就会从物理地址0x7c00开始将设备第一个扇区的内容复制到RAM中，然后跳转到地址并执行刚刚加载的代码，此代码称为引导加载程序。 然后，引导加载程序将内核加载到物理地址0x100000。地址0x100000用作x86计算机上所有大内核的起始地址。 所有x86处理器都以简单的16位模式开始，称为实模式。GRUB引导加载程序通过将CR0寄存器的最低位设置为1来切换到32位保护模式，因此，内核以32位保护模式加载。 请注意，在Linux内核的情况下，GRUB会检测Linux启动协议并以实模式加载Linux内核。Linux内核本身可以切换到保护模式。 我们需要什么 一台 x86 电脑 Linux NASM 汇编程序 gcc ld（GNU 链接器） grub 源代码 源代码可以在 Github 存储库中找到mkernel 使用程序集的入口点 我们喜欢用 C 语言编写所有内容，但我们无法避免一些组装。我们将用x86汇编语言编写一个小文件，以此来作为我们内核的起点。我们所有的汇编文件都会调用一个外部函数，我们将用 C 编写，然后暂停程序流程。 我们如何确保此汇编代码将作为内核的起点呢？ 我们将使用链接脚本来链接目标文件以生成最终的内核可执行文件（稍后将详细解释）。在此链接描述文件中，我们将明确指定我们希望将二进制文件加载到地址0x100000。正如我之前所说，这个地址是内核的预期。因此，引导加载程序将负责触发内核的入口点。 这是汇编代码： 12345678910111213141516171819202122232425;;kernel.asmbits 32 ;nasm directive - 32 bitsection .textglobal startextern kmain ;kmain is defined in the c filestart: cli ;block interrupts mov esp, stack_space ;set stack pointer call kmain hlt ;halt the CPUsection .bssresb 8192 ;8KB for stackstack_space: 第一条指令bits 32不是x86汇编指令，它是NASM汇编程序的一个指令，它指定它应该生成代码，以在32位模式下运行的处理器上运行。在我们的例子中，它并不是强制性的，但是这里包含了它，因为它确实是一个良好实践。 第二行开始文本部分（又名代码部分），这是我们放置所有代码的地方。 global是另一个将源代码中的符号设置为全局的NASM指令，通过这样做，链接器知道符号的start位置，这恰好是我们的切入点。 kmain是我们的函数，将在我们的kernel.c文件中定义。extern声明该函数在其他地方声明。 然后，我们有了start函数，它调用kmain函数并使用hlt指令暂停CPU。中断可以从hlt指令中唤醒CPU，所以我们事先使用cli指令禁用中断。cli是明显中断的缩写。 理想情况下，我们应该为堆栈留出一些内存并将堆栈指针（esp）指向它。但是，似乎GRUB这样做就已经设置了堆栈指针。但是，为了以防万一，我们将在BSS部分中分配一些空间，并将堆栈指针指向分配的内存的开头。我们使用resb以字节为单位保留内存的指令，在它之后，留下一个标签，指向保留的内存块的边缘。在kmain调用之前，堆栈指针（esp）使用mov指令使指向该空间。 C 中的内核 在kernel.asm，我们调用了该函数kmain()。所以我们的C代码将开始执行kmain()： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* * kernel.c */void kmain(void) &#123; const char *str = &quot;my first kernel&quot;; char *vidptr = (char*)0xb8000; //video mem begins here. unsigned int i = 0; unsigned int j = 0; /* this loops clears the screen * there are 25 lines each of 80 columns; each element takes 2 bytes */ while(j &lt; 80 * 25 * 2) &#123; /* blank character */ vidptr[j] = &#x27; &#x27;; /* attribute-byte - light grey on black screen */ vidptr[j+1] = 0x07; j = j + 2; &#125; j = 0; /* this loop writes the string to video memory */ while(str[j] != &#x27;\\0&#x27;) &#123; /* the character&#x27;s ascii */ vidptr[i] = str[j]; /* attribute-byte: give character black bg and light grey fg */ vidptr[i+1] = 0x07; ++j; i = i + 2; &#125; return;&#125; 我们所有的内核都会清除屏幕并写入字符串“我的第一个内核”。 首先，我们创建一个指向vidptr地址0xb8000的指针，该地址是受保护模式下的视频内存的开始。屏幕的文本内存只是我们地址空间中的一块内存，屏幕的内存映射输入/输出从0xb8000开始，支持25行，每行包含80个ASCII字符。 该文本存储器中的每个字符元素由16位（2字节）表示，而不是我们习惯的8位（1字节）。第一个字节应该具有ASCII中的字符表示，第二个字节是attribute-byte。这描述了其特征属性，比如说颜色。 如果要s在黑色背景上打印绿色字符，我们只需要将字符s存储在视频存储器地址的第一个字节中，将值0x02存储在第二个字节中即可。0代表黑色背景，2代表绿色前景。 请查看下表中的不同颜色： 123456789101112131415160 - Black,1 - Blue,2 - Green,3 - Cyan,4 - Red,5 - Magenta,6 - Brown,7 - Light Grey,8 - Dark Grey,9 - Light Blue,10/a - Light Green,11/b - Light Cyan,12/c - Light Red,13/d - Light Magenta,14/e - Light Brown,15/f – White. 在我们的内核中，我们将在黑色背景上使用浅灰色字符，所以我们的属性字节必须具有值0x07。 在第一个while循环中，程序在 25 行的 80 列中写入具有0x07属性的空白字符，这样就可以清除屏幕。 在第二个while循环中，空终止字符串“my first kernel”的字符被写入视频内存块，每个字符保存一个0x07的属性字节。 这将会在屏幕上显示字符串。 链接部分 我们将kernel.asm与NASM组装成一个目标文件，然后使用GCC，将kernel.c编译成另一个目标文件。现在，我们的工作是将这些对象链接到可执行的可引导内核。 为此，我们使用显式链接脚本，它可以作为参数传递给ld（我们的链接器）。 123456789101112131415161718192021/* * link.ld */OUTPUT_FORMAT(elf32-i386)ENTRY(start)SECTIONS &#123; . = 0x100000; .text : &#123; *(.text) &#125; .data : &#123; *(.data) &#125; .bss : &#123; *(.bss) &#125;&#125; 首先，我们将输出可执行文件的输出格式设置为32位可执行文件和可链接格式（ELF）。ELF 是x86架构上类Unix系统的标准二进制文件格式。 ENTRY有一个论点，它指定应该是我们的可执行文件的入口点的符号名称。 SECTIONS是我们最重要的部分，在这里，我们定义可执行文件的布局。我们可以指定如何合并不同的部分以及每个部分的放置位置。 在SECTIONS语句后面的大括号内，句点字符（.）表示位置计数器。 在SECTIONS块的开头，位置计数器始终初始化为0x0，这可以通过为其分配新值来修改它。 记住前文中说过的，内核的代码应该从地址0x100000开始，所以我们将位置计数器设置为0x100000。 看看下一行.text：&#123;*（.text）&#125; 星号（*）是一个匹配任何文件名的通配符，因此，表达式*(.text)表示.text来自所有输入文件的所有输入节。 因此，链接器将目标文件的所有文本部分，合并到位置计数器中存储地址的可执行文件部分，所以我们的可执行文件的代码部分从0x100000开始。 链接器放置文本输出节之后，位置计数器的值将变为0x1000000 +文本输出节的大小。 类似的，数据和bss部分被合并并放置在location-counter的then值处。 Grub 和 Multiboot 现在，我们准备好构建内核的所有文件。但是，既然我们想用GRUB引导程序引导我们的内核，那么还有一步。 有一个使用引导加载程序加载各种x86内核的标准，称为Multiboot spec（多重引导规范）。 如果GRUB符合Multiboot规范，它将只加载我们的内核。 根据规范，内核必须在其前8个千字节内包含一个头，称为Multiboot header（多引导头）。 此外，此Multiboot标头必须包含3个字节，即 4 字节对齐，即： 一个魔术字段（magic field）：包含幻数0x1BADB002，以识别头部。 一个标志字段（flags field）：我们不关心这个字段，只需将其设置为零。 一个校验字段（checksum field）：添加“magic”和“flags”的校验字段必须为零。 所以我们的kernel.asm就会变成： 12345678910111213141516171819202122232425262728293031323334353637;;kernel.asm;nasm directive - 32 bitbits 32section .text ;multiboot spec align 4 dd 0x1BADB002 ;magic dd 0x00 ;flags dd - (0x1BADB002 + 0x00) ;checksum. m+f+c should be zeroglobal startextern kmain ;kmain is defined in the c filestart: cli ;block interrupts mov esp, stack_space ;set stack pointer call kmain hlt ;halt the CPUsection .bssresb 8192 ;8KB for stackstack_space: DD定义大小为 4 个字节的双字。 构建内核 现在，我们将创建从目标文件kernel.asm和kernel.c，然后使用我们的链接脚本链接。 1nasm -f elf32 kernel.asm -o kasm.o 将运行汇编程序以ELF-32位格式创建目标文件kasm.o。 1gcc -m32 -c kernel.c -o kc.o '-c'选项确保在编译之后，链接不会隐式发生。 1ld -m elf_i386 -T link.ld -o kernel kasm.o kc.o 将使用我们的链接描述文件运行链接器并生成名为kernel的可执行文件。 配置你的 grub 并运行你的内核 GRUB要求您的内核具有名称模式kernel-&lt;version&gt;，所以，我们需要重命名内核。我将内核可执行文件重命名为kernel-701。 现在将它放在/ boot目录中。（需要超级用户权限才能执行此操作。） 在GRUB配置文件中，grub.cfg应该添加一个条目，例如： 1title myKernelroot (hd0,0)kernel /boot/kernel-701 ro 不要忘记删除指令hiddenmenu（如果存在的话）。 重新启动计算机，你将获得列出内核名称的列表选择。 那就是你的内核!! PS 始终建议给自己设置一个虚拟机，用于各种内核黑客攻击。 要在grub2 上运行它，这是新发行版的默认引导加载程序，你的配置应如下所示： 1menuentry &#x27;kernel 701&#x27; &#123;set root=&#x27;hd0,msdos1&#x27;multiboot /boot/kernel-701 ro&#125; 此外，如果您想在 qemu 模拟器上运行内核而不是使用 GRUB 启动内核，你可以通过以下方式执行此操作： 1qemu-system-i386 -kernel kernel 参考和感谢 arjun024 的源码及思路 wiki.osdev.org osdever.net Multiboot spec","categories":[{"name":"notes","slug":"notes","permalink":"http://debug.cool/categories/notes/"}],"tags":[]},{"title":"Mac生产力工具","slug":"tipsMac","date":"2018-03-30T16:00:00.000Z","updated":"2021-05-07T07:30:39.980Z","comments":true,"path":"2018/03/31/tipsMac/","link":"","permalink":"http://debug.cool/2018/03/31/tipsMac/","excerpt":"Mac 机写代码除了逼格高一点，生产力是真的显著提高～ 以下简单介绍一些在 Mac 上提高生产力的小技巧。","text":"Mac 机写代码除了逼格高一点，生产力是真的显著提高～ 以下简单介绍一些在 Mac 上提高生产力的小技巧。 以 PHP 开发环境为例，干净的 Mac 系统（重装系统后未作任何配置） 安装命令行终端 这里我们选择iTerm2，iTerm2功能强大，可以替代系统默认的命令行终端。下载解压后，将iTerm2直接拖入&quot;应用程序&quot;目录。 安装 Xcode Xcode是苹果出品的包含一系列工具及库的开发套件。 通过 App Store 安装最新版本的 Xcode。我们一般不会用 Xcode 来开发 PHP 项目。但这一步也是必需的，因为 Xcode 会帮你附带安装一些如 Git 等必要的软件。当然你也可以通过源码包安装 Git。 安装 Xcode Command Line Tools 这一步会帮你安装许多常见的基于 Unix 的工具。Xcode 命令行工具作为 Xcode 的一部分，包含了 GCC 编译器。在命令行中执行以下命令即可安装： 1xcode-select --install 安装包管理器 Homebrew 作为 macOS 不可或缺的套件管理器，用来安装、升级以及卸载常用的软件。在命令行中执行以下命令即可安装： 1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装后可以修改 Homebrew 源，国外源一直不是很给力，这里我们将 Homebrew 的 git 远程仓库改为中国科学技术大学开源软件镜像： 12cd &quot;$(brew --repo)&quot;git remote set-url origin git://mirrors.ustc.edu.cn/brew.git 安装 HTTP 服务器 这里我们选择 nginx 代替系统自带的 Apache，作为我们的 HTTP 服务器： 1brew install nginx 安装完成后，nginx 的一些常用命令： 123sudo nginx # 启动 nginx 服务nginx -h # nginx 帮助信息sudo nginx -s stop|quit|reopen|reload # 停止|退出|重启|重载 nginx 服务 安装数据库 这里我们选择 MySQL 作为我们的数据库服务器： 1brew install mysql 当然，你也可以选择安装 PostgreSQL 或者 MariaDB。 安装完成后，启动 MySQL： 1mysqld 如果不执行上述操作，直接通过命令行进入 MySQL，一般会报一个这样的错误。 ERROR 2002 (HY000): Can’t connect to local MySQL server through socket ‘/tmp/mysql.sock’ 进入 MySQL 服务器 1mysql -u root -p 开启 PHP-FPM nginx 本身不能处理 PHP，它只是个 HTTP 服务器，当接收一个 PHP 请求后，nginx 会将其交由 PHP 解释器处理，并把结果返回给客户端。nginx 一般是把请求发 FastCGI 管理进程处理，FastCGI 管理进程选择 CGI 子进程处理结果并返回被 nginx。 PHP-FPM是一个 PHP FastCGI 管理器，一开始只是 PHP 源代码的一个补丁，旨在将 FastCGI 进程管理整合进 PHP包中。必须将它 patch 到 PHP 源代码中，在编译安装 PHP后才可以使用。PHP 从版本 5.3 开始官方集成PHP-FPM。 添加 PHP-FPM 的配置文件 12cp /private/etc/php-fpm.conf.default /private/etc/php-fpm.confphp-fpm --fpm-config /private/etc/php-fpm.conf 修改 PHP-FPM 的 error_log 路径 12vi /var/log/php-fpm.log # 新建文件vi /private/etc/php-fpm.conf # 将 error_log=log/php-fpm.log 修改为：error_log = /var/log/php-fpm.log，保存 启动 PHP-FPM 1sudo php-fpm 关闭 PHP-FPM 12ps aux|grep php-fpmsudo kill php-fpm min pid # 杀死 php-fpm 最小的进程id 配置 nginx.conf 文件 通过以下命令可以查看nginx.conf文件的位置： 1nginx -h 输出： 1234567891011121314nginx version: nginx/1.10.1Usage: nginx [-?hvVtTq] [-s signal] [-c filename] [-p prefix] [-g directives]Options: -?,-h : this help -v : show version and exit -V : show version and configure options then exit -t : test configuration and exit -T : test configuration, dump it and exit -q : suppress non-error messages during configuration testing -s signal : send signal to a master process: stop, quit, reopen, reload -p prefix : set prefix path (default: /usr/local/Cellar/nginx/1.10.1/) -c filename : set configuration file (default: /usr/local/etc/nginx/nginx.conf) -g directives : set global directives out of configuration file 打开配置文件： 1vi /usr/local/etc/nginx/nginx.conf 在文件末尾可以看到： 1include servers/*; 它将同目录下的servers目录里的文件都包含了进来，由此，我们可以在servers文件里创建开发项目的配置信息： 12cd servers/vi test.conf 将以下配置信息，写入 test.conf文件中： 1234567891011121314151617server &#123; listen 8099; server_name localhost; root /home/www/php_project; rewrite . /index.php; location / &#123; index index.php index.html index.htm; autoindex on; &#125; #proxy the php scripts to php-fpm location ~ \\.php$ &#123; include /usr/local/etc/nginx/fastcgi.conf; fastcgi_intercept_errors on; fastcgi_pass 127.0.0.1:9000; &#125;&#125; 在上述的/home/www/php_project的目录下，我们创建一个 index.php文件： 12cd /home/www/php_projectvi test.php 写入内容： 12&lt;? phpphpinfo(); 重启 nginx 12sudo nginx -s stopsudo nginx 打开浏览器，访问localhost:8099。可以看到关于 PHP 配置的信息。 至此，MNMP(MacOS-nginx-MySQL-PHP)环境已经搭建完成。 安装 PHP 扩展 环境搭建完成后，你可能还需要安装一些 PHP 扩展，如 MemCache、Redis、Mongo、Solr等。 在安装PHP扩展之前，你需要完成一些必要的操作。 关闭 SIP 这是安装 PHP 扩展前的必要操作。如果跳过这一操作，即使你用 sudo 命令安装扩展，依旧会报 Operation not permitted 的错误。这是因为 OSX 10.11 El Capitan（或更高）新添加了一个新的安全机制叫系统完整性保护 System Integrity Protection (SIP)，所以对于以下目录： 123/System/sbin/usr 不包含(/usr/local/) 仅仅供系统使用，其它用户或者程序无法直接使用，而我们的 /usr/lib/php/extensions/ 则刚好在受保护范围内（误伤世界上最好的语言）。 所以解决方法就是禁掉 SIP 保护机制，步骤是： 重启系统 按住 Command + R（重新亮屏之后就开始按，象征地按几秒再松开，直到出现苹果标志性的 Logo） 菜单“实用工具” ==&gt;&gt; “终端” ==&gt;&gt; 输入：csrutil disable。执行后会输出： 1Successfully disabled System Integrity Protection. Please restart the machine for the changes to take effect 重启系统 当然，PHP 扩展安装完成后，就可以重新打开 SIP，方法同上，命令改为：csrutil enable。 安装一些必要的依赖包 安装 autoconf，PHP动态编译 phpize 时需要： 1brew install autoconf 安装 openssl，安装某些 php 扩展如 mongo 时需要。 1brew install openssl mongo 扩展安装是可能会报 openssl 错误，解决方法如下： 1ln -s /usr/local/Cellar/openssl/1.0.2j/include/openssl /usr/include/openssl 正式安装扩展 这里有两种方法安装 php 扩展： 通过 pecl 管理工具安装 通过源码包安装 通过 pecl 管理工具安装 首先安装 pecl 12cd /usr/lib/phpsudo php install-pear-nozlib.phar pecl 一般就会安装成功，如果失败，换另一种方式安装 pecl： 12345curl -O http://pear.php.net/go-pear.pharsudo php -d detect_unicode=0 go-pear.phar输入 1，回车，输入/usr/local/pear输入 4，回车，输入/usr/local/bin回车 安装好pecl 之后，我们就可以愉快地安装 PHP 扩展了： 123sudo pecl install solrsudo pecl install memcachesudo pecl install mongodb 通过源码包安装 除了通过 pecl 安装，我们还可以通过下载源码包来进行安装扩展： 1234567wget http://pecl.php.net/get/redis-2.2.8.tgztar -zxvf redis-2.2.8.tgzcd redis-2.2.8phpize./configuremakesudo make install 扩展安装完成后，我们还需最后一步，修改php.ini文件，并重启 PHP-FPM： 123cd /private/etc/cp php.ini.default php.inivi php.ini 追加扩展信息： 1234extension=memcache.soextension=mongo.soextension=redis.soextension=solr.so 重启 PHP-FPM: 123ps aux|grep php-fpmsudo kill php-fpm min pid # 杀死 php-fpm 最小的进程idsudo php-fpm 打开浏览器，访问localhost:8099。查看扩展是否安装成功。","categories":[{"name":"tips","slug":"tips","permalink":"http://debug.cool/categories/tips/"}],"tags":[]},{"title":"Linux主机安全策略部署","slug":"opsLinuxSec","date":"2017-02-16T10:44:00.000Z","updated":"2021-05-07T07:30:39.985Z","comments":true,"path":"2017/02/16/opsLinuxSec/","link":"","permalink":"http://debug.cool/2017/02/16/opsLinuxSec/","excerpt":"","text":"搭了测试机记得初始化配置策略。 启用 authpriv 和 cron 系统日志审计 123456789危险等级:中级类型：安全基线描述：启用authpriv和cron系统日志审计。 authpriv －包括特权信息如用户名在内的认证活动 cron －与 cron 和 at 有关的计划任务信息。参考链接：无操作步骤： 1. 修改/etc/rsyslog.conf，添加或取消注释如下配置（中间的分隔符是tab）： authpriv.* /var/log/secure cron.* /var/log/cron 2. 重启rsyslog服务 Linux 帐户口令生存期策略 12345危险等级:中级类型：安全基线描述：口令老化（Password aging）是一种增强的系统口令生命期认证机制，能够确保用户的口令定期更换，提高系统安全性。参考链接：http://man7.org/linux/man-pages/man5/login.defs.5.html操作步骤：修改文件/etc/login.defs，配置PASS_MAX_DAYS 90 限制 root 权限用户远程登录 12345678危险等级:中级类型：安全基线描述：限制root权限远程登录。先以普通权限用户远程登录后，再切换到超级管理员权限账号后执行相应操作，可以提升系统安全性。参考链接：无操作步骤： 1. 修改文件/etc/ssh/sshd_config配置 PermitRootLogin no 2. 重启sshd服务 Linux 帐户超时自动登出配置 1234567危险等级:中级类型：安全基线描述：配置帐户超时自动登出，在用户输入空闲一段时间后自动断开。参考链接：无操作步骤： 修改/etc/profile文件，设置定时账户自动登出时间 export TMOUT=180 Linux 未配置账户登录失败锁定策略 123456789101112131415161718危险等级:中级类型：安全基线描述：设置账户登录失败锁定策略，加大用户口令被暴力破解的难度。参考链接：http://man7.org/linux/man-pages/man8/pam_tally2.8.html操作步骤： 设置连续输错5次口令，帐号锁定5分钟。 在进行此项安全加固工作前，请先检查PAM模块版本，搜索pam_tally2是否存在，如果pam_tally2存在，修改配置文件。【注意： 各系统配置不一，请根据当前系统进行适当配置，并仔细评估对系统的影响】 修复方案（仅供参考，请勿直接配置）： centos 修改配置/etc/pam.d/password-auth（将配置添加到合适的位置）: auth required pam_tally2.so deny=5 unlock_time=300 even_deny_root root_unlock_time=300 account required pam_tally2.so ubuntu,debian： 修改配置/etc/pam.d/common-auth（将配置添加到合适的位置）: auth required pam_tally2.so deny=5 unlock_time=300 even_deny_root root_unlock_time=300 修改配置/etc/pam.d/common-account参数（将配置添加到合适的位置）: account required pam_tally2.so 删除系统特殊的的用户帐号 123456789101112危险等级:中级类型：安全基线描述：禁止所有默认的被操作系统本身启动的且不需要的帐号，当你第一次装上系统时就应该做此检查，Linux提供了各种帐号，你可能不需要，如果你不需要这个帐号，就移走它，你有的帐号越多，就越容易受到攻击。参考链接：无操作步骤： #为删除你系统上的用户，用下面的命令： [root@c1gstudio]# userdel username #批量删除方式 #这里删除&quot;adm lp sync shutdown halt mail news uucp operator games gopher ftp &quot;账号 #如果你开着ftp等服务可以把ftp账号保留下来。 for i in adm lp sync shutdown halt mail news uucp ope rator games gopher ftp ;do userdel $i ;done 删除系统特殊的组帐号 123456789危险等级:中级类型：安全基线描述：参考链接：无操作步骤： [root@c1gstudio]# groupdel groupname #批量删除方式 for i in adm lp mail news uucp games dip pppusers pop users slipusers ;do groupdel $i ;done 用户密码设置 1234567891011121314危险等级:中级类型：安全基线描述：安装linux时默认的密码最小长度是5个字节，但这并不够，要把它设为8个字节。修改最短密码长度需要编辑login.defs文件#vi /etc/login.defs参考链接：无操作步骤： PASS_MAX_DAYS 99999 ##密码设置最长有效期（默认值） PASS_MIN_DAYS 0 ##密码设置最短有效期 PASS_MIN_LEN 5 ##设置密码最小长度，将5改为8 PASS_WARN_AGE 7 ##提前多少天警告用户密码即将过期。 然后修改Root密码 #passwd root New UNIX password: Retype new UNIX password: passwd: all authentication tokens updated successfully. 修改自动注销帐号时间 12345678危险等级:中级类型：安全基线描述：自动注销帐号的登录，在Linux系统中root账户是具有最高特权的。如果系统管理员在离开系统之前忘记注销root账户，那将会带来很大的安全隐患，应该让系统会自动注销。通过修改账户中“TMOUT”参数，可以实现此功能。TMOUT按秒计算。参考链接：无操作步骤： 编辑你的profile文件（vi /etc/profile）,在&quot;HISTSIZE=&quot;后面加入下面这行： TMOUT=300 # 300，表示300秒，也就是表示5分钟。这样，如果系统中登陆的用户在5分钟内都没有动作，那么系统会自动注销这个账户。 限制 Shell 命令记录大小 12345678910危险等级:中级类型：安全基线描述：默认情况下，bash shell会在文件$HOME/.bash_history中存放多达500条命令记录(根据具体的系统不同，默认记录条数不同)。系统中每个用户的主目录下都有一个这样的文件。在此笔者强烈建议限制该文件的大小。参考链接：无操作步骤： 您可以编辑/etc/profile文件，修改其中的选项如下: HISTFILESIZE=30或HISTSIZE=30 #vi /etc/profile HISTSIZE=30 注销时删除命令记录 12345678910危险等级:中级类型：安全基线描述：参考链接：无操作步骤： 编辑/etc/skel/.bash_logout文件，增加如下行: rm -f $HOME/.bash_history 这样，系统中的所有用户在注销时都会删除其命令记录。 如果只需要针对某个特定用户，如root用户进行设置，则可只在该用户的主目录下修改/$HOME/.bash_history文件，增加相同的一行即可。 用下面的命令加需要的用户组和用户帐号 12345678910111213危险等级:中级类型：安全基线描述：参考链接：无操作步骤： [root@c1gstudio]# groupadd 例如：增加website 用户组，groupadd website 然后调用vigr命令查看已添加的用户组 用下面的命令加需要的用户帐号 [root@c1gstudio]# useradd username –g website //添加用户到website组（作为webserver的普通管理员，而非root管理员） 然后调用vipw命令查看已添加的用户 用下面的命令改变用户口令（至少输入8位字母和数字组合的密码，并将密码记录于本地机的专门文档中，以防遗忘） [root@c1gstudio]# passwd username 阻止任何人 su 作为 root 1234567891011危险等级:中级类型：安全基线描述：参考链接：无操作步骤： 如果你不想任何人能够su作为root,你能编辑/etc/pam.d/su加下面的行： #vi /etc/pam.d/su auth sufficient /lib/security/$ISA/pam_rootok.so debug auth required /lib/security/$ISA/pam_wheel.so group=website 意味着仅仅website组的用户可以su作为root. 修改 ssh 服务的 root 登录权限 123456789101112危险等级:中级类型：安全基线描述：参考链接：无操作步骤： 修改ssh服务配置文件，使的ssh服务不允许直接使用root用户来登录，这样减少系统被恶意登录攻击的机会。 #vi /etc/ssh/sshd_config PermitRootLogin yes 将这行前的＃去掉后，修改为： PermitRootLogin no 修改 ssh 服务的 sshd 端口 12345678910111213141516171819202122232425危险等级:中级类型：安全基线描述：ssh默认会监听在22端口，你可以修改至6022端口以避过常规的扫描。注意：修改端口错误可能会导致你下次连不到服务器，可以先同时开着22和6022两个端口，然后再关掉22端口；重启sshd不会弹掉你当前的连接，可以另外开一个客户端来测试服务;参考链接：无操作步骤： #vi /etc/ssh/sshd_config #增加修改 #Port 22 #关闭22端口 Port 6022 #增加6022端口 #重启sshd服务 service sshd restart 检查一下sshd的监听端口对不对 netstat -lnp|grep ssh #iptables开放sshd的6022端口 vi /etc/sysconfig/iptables #如果使用redhat默认规则则增加 -A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 6022 -j ACCEPT #或 iptables -A INPUT -p tcp --dport 6022 -j ACCEPT iptables -A OUTPUT -p udp --sport 6022 -j ACCEPT 重启iptables 服务 service iptables restart #测试两个端口是否都能连上，连上后再将22端口删除 关闭系统不使用的服务： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697危险等级:中级类型：安全基线描述：参考链接：无操作步骤： cd /etc/init.d # 进入到系统init进程启动目录 在这里有两个方法，可以关闭init目录下的服务。 一个是将init目录下的文件名mv成*.old类的文件名，即修改文件名，作用就是在系统启动的时候找不到这个服务的启动文件。 另一个是使用chkconfig系统命令来关闭系统启动等级的服务。 注：在使用以下任何一种方法时，请先检查需要关闭的服务是否是本服务器特别需要启动支持的服务，以防关闭正常使用的服务。 使用chkcofig命令来关闭不使用的系统服务 (level前面为2个减号)要想在修改启动脚本前了解有多少服务正在运行，输入： ps aux | wc -l 然后修改启动脚本后，重启系统，再次输入上面的命令，就可计算出减少了多少项服务。越少服务在运行，安全性就越好。另外运行以下命令可以了解还有多少服务在运行： netstat -na --ip 批量方式先停止服务 for i in acpid anacron apmd atd auditd autofs avahi-daemon avahi-dnsconfd bluetooth cpuspeed cups dhcpd firstboot gpm haldaemon hidd ip6tables ipsec isdn kudzu lpd mcstrans messagebus microcode_ctl netfs nfs nfslock nscd pcscd portmap readahead_early restorecond rpcgssd rpcidmapd rstatd sendmai l setroubleshoot snmpd sysstat xfs xinetd yppasswdd ypserv yum-updatesd ;do service $i stop;done 关闭启动服务 for i in acpid anacron apmd atd auditd autofs avahi-daemon avahi-dnsconfd bluetooth cpuspeed cups dhcpd firstboot gpm haldaemon hidd ip6tables ipsec isdn kudzu lpd mcstrans messagebus microcode_ctl netfs nfs nfslock nscd pcscd portmap readahead_early restorecond rpcgssd rpcidmapd rstatd sendmai l setroubleshoot snmpd sysstat xfs xinetd yppasswdd ypserv yum-updatesd ;do chkconfig $i off;done 以下为手动方式及解释,执行批量方式后不需再执行了 chkconfig --level 345 apmd off ##笔记本需要 chkconfig --level 345 netfs off ## nfs客户端 chkconfig --level 345 yppasswdd off ## NIS服务器，此服务漏洞很多 chkconfig --level 345 ypserv off ## NIS服务器，此服务漏洞很多 chkconfig --level 345 dhcpd off ## dhcp服务 chkconfig --level 345 portmap off ##运行rpc(111端口)服务必需 chkconfig --level 345 lpd off ##打印服务 chkconfig --level 345 nfs off ## NFS服务器，漏洞极多 chkconfig --level 345 sendmail off ##邮件服务, 漏洞极多 chkconfig --level 345 snmpd off ## SNMP，远程用户能从中获得许多系统信息 chkconfig --level 345 rstatd off ##避免运行r服务，远程用户可以从中获取很多信息 chkconfig --level 345 atd off ##和cron很相似的定时运行程序的服务 注：以上chkcofig 命令中的3和5是系统启动的类型，以下为数字代表意思 0:开机(请不要切换到此等级) 1:单人使用者模式的文字界面 2:多人使用者模式的文字界面,不具有网络档案系统(NFS)功能 3:多人使用者模式的文字界面,具有网络档案系统(NFS)功能 4:某些发行版的linux使用此等级进入x windows system 5:某些发行版的linux使用此等级进入x windows system 6:重新启动 如果不指定--level 单用on和off开关，系统默认只对运行级3，4，5有效 chkconfig cups off #打印机 chkconfig bluetooth off # 蓝牙 chkconfig hidd off # 蓝牙 chkconfig ip6tables off # ipv6 chkconfig ipsec off # vpn chkconfig auditd off #用户空间监控程序 chkconfig autofs off #光盘软盘硬盘等自动加载服务 chkconfig avahi-daemon off #主要用于Zero Configuration Networking ，一般没什么用建议关闭 chkconfig avahi-dnsconfd off #主要用于Zero Configuration Networking ,同上,建议关闭 chkconfig cpuspeed off #动态调整CPU频率的进程，在服务器系统中这个进程建议关闭 chkconfig isdn off #isdn chkconfig kudzu off #硬件自动监测服务 chkconfig nfslock off #NFS文档锁定功能。文档共享支持，无需的能够关了 chkconfig nscd off #负责密码和组的查询，在有NIS服务时需要 chkconfig pcscd off #智能卡支持，,如果没有可以关了 chkconfig yum-updatesd off #yum更新 chkconfig acpid off chkconfig autofs off chkconfig firstboot off chkconfig mcstrans off #selinux chkconfig microcode_ctl off chkconfig rpcgssd off chkconfig rpcidmapd off chkconfig setroubleshoot off chkconfig xfs off chkconfig xinetd off chkconfig messagebus off chkconfig gpm off #鼠标 chkconfig restorecond off #selinux chkconfig haldaemon off chkconfig sysstat off chkconfig readahead_early off chkconfig anacron off 需要保留的服务 crond , irqbalance , microcode_ctl ,network , sshd ,syslog 因为有些服务已运行，所以设置完后需重启 chkconfig /* 语法：chkconfig [--add][--del][--list][系统服务] 或 chkconfig [--level &lt;等级代号&gt;][系统服务][on/off/reset] 补充说明：这是Red Hat公司遵循GPL规则所开发的程序，它可查询操作系统在每一个执行等级中会执行哪些系统服务，其中包括各类常驻服务。 参数： --add 增加所指定的系统服务，让chkconfig指令得以管理它，并同时在系统启动的叙述文件内增加相关数据。 --del 删除所指定的系统服务，不再由chkconfig指令管理，并同时在系统启动的叙述文件内删除相关数据。 --level&lt;等级代号&gt; 指定读系统服务要在哪一个执行等级中开启或关毕 */ 阻止系统响应任何从外部/内部来的 ping 请求 1234567危险等级:中级类型：安全基线描述：既然没有人能ping通你的机器并收到响应，你可以大大增强你的站点的安全性。你可以加下面的一行命令到/etc/rc.d/rc.local，以使每次启动后自动运行。参考链接：无操作步骤： echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all #这个可以不做哈 修改&quot;/etc/host.conf&quot;文件 123456789101112131415危险等级:中级类型：安全基线描述：参考链接：无操作步骤： &quot;/etc/host.conf&quot;说明了如何解析地址。编辑&quot;/etc/host.conf&quot;文件（vi /etc/host.conf），加入下面这行： # Lookup names via DNS first then fall back to /etc/hosts. order hosts,bind # We have machines with multiple IP addresses. multi on # Check for IP address spoofing. nospoof on 第一项设置首先通过DNS解析IP地址，然后通过hosts文件解析。 第二项设置检测是否“/etc/hosts”文件中的主机是否拥有多个IP地址（比如有多个以太口网卡）。 第三项设置说明要注意对本机未经许可的电子欺骗。 不允许从不同的控制台进行 root 登陆 1234567891011121314151617危险等级:中级类型：安全基线描述：参考链接：无操作步骤： &quot;/etc/securetty&quot;文件允许你定义root用户可以从那个TTY设备登陆。你可以编辑&quot;/etc/securetty&quot;文件，再不需要登陆的TTY设备前添加“#”标志，来禁止从该TTY设备进行root登陆。 在/etc/inittab文件中有如下一段话： # Run gettys in standard runlevels 1:2345:respawn:/sbin/mingetty tty1 2:2345:respawn:/sbin/mingetty tty2 # 3:2345:respawn:/sbin/mingetty tty3 # 4:2345:respawn:/sbin/mingetty tty4 # 5:2345:respawn:/sbin/mingetty tty5 # 6:2345:respawn:/sbin/mingetty tty6 系统默认的可以使用6个控制台，即Alt+F1,Alt+F2...，这里在3，4，5，6前面加上“#”，注释该句话，这样现在只有两个控制台可供使用，最好保留两个。然后重新启动init进程，改动即可生效！ 禁止 Control-Alt-Delete 键盘关闭命令 1234567891011危险等级:中级类型：安全基线描述：参考链接：无操作步骤： 在&quot;/etc/inittab&quot; 文件中注释掉下面这行（使用#）： ca::ctrlaltdel:/sbin/shutdown -t3 -r now 改为： # ca::ctrlaltdel:/sbin/shutdown -t3 -r now 为了使这项改动起作用，输入下面这个命令： # /sbin/init q 用 chattr 命令给下面的文件加上不可更改属性。 1234567891011121314151617181920212223242526272829危险等级:中级类型：安全基线描述：参考链接：无操作步骤： [root@c1gstudio]# chattr +i /etc/passwd [root@c1gstudio]# chattr +i /etc/shadow [root@c1gstudio]# chattr +i /etc/group [root@c1gstudio]# chattr +i /etc/gshadow 【注：chattr是改变文件属性的命令，参数i代表不得任意更动文件或目录,此处的i为不可修改位(immutable)。查看方法：lsattr /etc/passwd，撤销为chattr –i /etc/group】 补充说明：这项指令可改变存放在ext2文件系统上的文件或目录属性，这些属性共有以下8种模式： a：让文件或目录仅供附加用途。 b：不更新文件或目录的最后存取时间。 c：将文件或目录压缩后存放。 d：将文件或目录排除在倾倒操作之外。 i：不得任意更动文件或目录。 s：保密性删除文件或目录。 S：即时更新文件或目录。 u：预防以外删除。 参数： -R 递归处理，将指定目录下的所有文件及子目录一并处理。 -v&lt;版本编号&gt; 设置文件或目录版本。 -V 显示指令执行过程。 +&lt;属性&gt; 开启文件或目录的该项属性。 -&lt;属性&gt; 关闭文件或目录的该项属性。 =&lt;属性&gt; 指定文件或目录的该项属性。 给系统服务端口列表文件加锁 1234567危险等级:中级类型：安全基线描述：主要作用是防止未经许可的删除或添加服务参考链接：无操作步骤： chattr +i /etc/services 【查看方法：lsattr /etc/ services，撤销为chattr –i /etc/ services】 系统文件权限修改 1234567891011121314151617181920212223242526危险等级:中级类型：安全基线描述：Linux文件系统的安全主要是通过设置文件的权限来实现的。每一个Linux的文件或目录，都有3组属性，分别定义文件或目录的所有者，用户组和其他人的使用权限（只读、可写、可执行、允许SUID、允许SGID等）。特别注意，权限为SUID和SGID的可执行文件，在程序运行过程中，会给进程赋予所有者的权限，如果被黑客发现并利用就会给系统造成危害。参考链接：无操作步骤： (1)修改init目录文件执行权限： chmod -R 700 /etc/init.d/* （递归处理，owner具有rwx，group无，others无） (2)修改部分系统文件的SUID和SGID的权限： chmod a-s /usr/bin/chage chmod a-s /usr/bin/gpasswd chmod a-s /usr/bin/wall chmod a-s /usr/bin/chfn chmod a-s /usr/bin/chsh chmod a-s /usr/bin/newgrp chmod a-s /usr/bin/write chmod a-s /usr/sbin/usernetctl chmod a-s /usr/sbin/traceroute chmod a-s /bin/mount chmod a-s /bin/umount chmod a-s /sbin/netreport (3)修改系统引导文件 chmod 600 /etc/grub.conf chattr +i /etc/grub.conf 【查看方法：lsattr /etc/grub.conf，撤销为chattr –i /etc/grub.conf】 增加 dns 12345678危险等级:中级类型：安全基线描述：参考链接：无操作步骤： # vi /etc/resolv.conf nameserver 8.8.8.8 #google dns nameserver 8.8.4.4 hostname 修改 12345678910危险等级:低级类型：安全基线描述：参考链接：无操作步骤： # 注意需先把mysql、postfix等服务停了 1.hostname servername 2.vi /etc/sysconfig/network service network restart 3.vi /etc/hosts selinux 修改 12345678910危险等级:中级类型：安全基线描述：参考链接：无操作步骤： 开启selinux可以增加安全性，但装软件时可能会遇到一些奇怪问题 以下是关闭方法 # vi /etc/selinux/config 改成disabled 关闭 ipv6 12345678910111213141516危险等级:中级类型：安全基线描述：参考链接：无操作步骤： echo &quot;alias net-pf-10 off&quot; &gt;&gt; /etc/modprobe.conf echo &quot;alias ipv6 off&quot; &gt;&gt; /etc/modprobe.conf # vi /etc/sysconfig/network NETWORKING_IPV6=no 重启服务 Service ip6tables stop Service network restart 关闭自动启动 chkconfig --level 235 ip6tables off 设置 iptables 123456789101112危险等级:中级类型：安全基线描述：参考链接：无操作步骤： iptables 默认安全规则脚本 重启系统 以上大部分设置可以运行脚本来完成。linux安全设置快捷脚本 设置完成后重启系统 其它设置项 linux 调整系统时区/时间的方法 1234567891011121314151617181920212223242526272829303132333435363738危险等级:低级类型：安全基线描述：参考链接：无操作步骤： 把/usr/share/zoneinfo里相应的时区与/etc/localtime做个软link.比如使用上海时区的时间:ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 如果要使用UTC计时方式，则应在/etc/sysconfig/clock文件里改UTC=TRUE 时间的设置: 使用date 命令加s参数修改，注意linux的时间格式为&quot;月日时分年&quot;,也可以只修改时间date -s 22:30:20,如果修改的是年月日和时间，格式为&quot;月日时分年.秒&quot;,2007-03-18 11:01:56则应写为&quot;date -s 031811012007.56 硬件时间与当前时间更新: hwclock --systohc 如果硬件记时用UTC,则为 hwclock --systohc --utc linux调整系统时区/时间的方法 1) 找到相应的时区文件 /usr/share/zoneinfo/Asia/Shanghai 用这个文件替换当前的/etc/localtime文件。 步骤：cp –i /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 选择覆盖 2) 修改/etc/sysconfig/clock文件，修改为： ZONE=&quot;Asia/Shanghai&quot; UTC=false ARC=false 3) 时间设定成2005年8月30日的命令如下： # date -s 08/30/2005 将系统时间设定成下午6点40分0秒的命令如下： # date -s 18:40:00 4)同步BIOS时钟，强制把系统时间写入CMOS，命令如下： # clock -w 安装ntpd # yum install ntp # chkconfig --levels 235 ntpd on # ntpdate ntp.api.bz #先手动校准下 # service ntpd start 设置语言 1234567891011121314151617181920危险等级:低级类型：安全基线描述：英文语言，中文支持参考链接：无操作步骤： # vi /etc/sysconfig/i18n LANG=&quot;en_US.UTF-8&quot; SUPPORTED=&quot;zh_CN.UTF-8:zh_CN:zh&quot; SYSFONT=&quot;latarcyrheb-sun16&quot; tmpwatch 定时清除 假设服务器自定义了php的session和upload目录 # vi /etc/cron.daily/tmpwatch 在240 /tmp 前增加 -x /tmp/session -x /tmp/upload # mkdir /tmp/session # mkdir /tmp/upload # chown nobody:nobody /tmp/upload # chmod 0770 /tmp/upload","categories":[{"name":"ops","slug":"ops","permalink":"http://debug.cool/categories/ops/"}],"tags":[]},{"title":"Ubuntu搭建渗透测试环境","slug":"tipsLinuxBaseConfig","date":"2017-02-16T10:44:00.000Z","updated":"2021-05-07T07:30:39.985Z","comments":true,"path":"2017/02/16/tipsLinuxBaseConfig/","link":"","permalink":"http://debug.cool/2017/02/16/tipsLinuxBaseConfig/","excerpt":"","text":"常用工具 1sudo apt-get install vim git gedit wget curl vlc whois meld deepin-screenshot qbittorrent transmission fonts-wqy-microhei mtr unrar unrar-free ascii unicode filezilla unrar unace rar unrar p7zip zip unzip p7zip-full p7zip-rar file-roller -y 编辑器 vim gedit vscode 下载工具 wget curl uget 截图工具 deepin-screenshot flameshot 中文字体 fonts-wqy-microhei 压缩工具 unrar unrar-free p7zip zip unzip p7zip-full p7zip-rar ASCII 编码和 UNICODE 编码 ascii unicode whois 查询工具 whois 文件比较工具 meld BT 下载工具 qbittorrent transmission mtr Office 软件 wps for linux / only office 系统清理工具（Stacer） 1sudo apt install stacer 思维导图 mindmaster 即时通讯软件 telegram 123sudo add-apt-repository ppa:atareao/telegramsudo apt-get updatesudo apt-get install telegram 邮件工具：thunderbird 1sudo apt install thunderbird JAVA：Oracle-Java-11（下载后解压） 1234567891011121314151617181920212223# 创建文件夹并拷贝sudo mkdir -p /usr/local/javasudo cp -r jdk-11.0.7/ /usr/local/java/# 接下来配置JDK的环境变量sudo gedit /etc/profile# 复制以下内容追加到文件末尾JAVA_HOME=/usr/local/java/jdk-11.0.7PATH=$PATH:$HOME/bin:$JAVA_HOME/binexport JAVA_HOMEexport PATH# 告诉系统JDK的位置，最后2行代码不是重复，是要执行2次sudo update-alternatives --install &quot;/usr/bin/java&quot; &quot;java&quot; &quot;/usr/local/java/jdk-11.0.7/bin/java&quot; 1sudo update-alternatives --install &quot;/usr/bin/javac&quot; &quot;javac&quot; &quot;/usr/local/java/jdk-11.0.7/bin/javac&quot; 1sudo update-alternatives --install &quot;/usr/bin/javaws&quot; &quot;javaws&quot; &quot;/usr/local/java/jdk-11.0.7/bin/javaws&quot; 1sudo update-alternatives --install &quot;/usr/bin/javaws&quot; &quot;javaws&quot; &quot;/usr/local/java/jdk-11.0.7/bin/javaws&quot; 1# 设置新的JDK为默认,代码也是执行2次sudo update-alternatives --set java /usr/local/java/jdk-11.0.7/bin/javasudo update-alternatives --set javac /usr/local/java/jdk-11.0.7/bin/javac# 重载Profile文件source /etc/profile# 输入命令查看Java版本号java -version# 至此就应该安装成功了 中文输入法：ibus 12345sudo apt install ibus ibus-pinyin ibus-sunpinyin ibus-rimeim-configreboot添加智能拼音输入法ibus-setup #取消embed勾选项 编辑器 sublime text3（用来写 python 还不错） 1234wget -qO - https://download.sublimetext.com/sublimehq-pub.gpg | sudo apt-key add -echo &quot;deb https://download.sublimetext.com/ apt/stable/&quot; | sudo tee /etc/apt/sources.list.d/sublime-text.listsudo apt update &amp;&amp; sudo apt install sublime-text要删除编辑器，请运行命令：sudo apt remove --autoremove sublime-text 虚拟机 1VMware Workstation / VirtualBox 安装 docker 12345678910111213141516171819202122232425262728293031sudo apt-get updatesudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg-agent \\ software-properties-commoncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -sudo apt-key fingerprint 0EBFCD88sudo add-apt-repository \\ &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) \\ stable&quot;sudo apt-get updatesudo apt-get install docker-ce docker-ce-cli containerd.io docker-composesudo docker run hello-world #veriydocker -v #查看docker-ce版本sudo usermod -aG docker $&#123;USER&#125; #将user加入docker组su - $&#123;USER&#125; #应用新的组成员身份，系统将提示您输入用户密码以继续sudo systemctl enable docker #设置docker开机自启动docker镜像加速（我用的阿里云的镜像加速）sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123; &quot;registry-mirrors&quot;: [&quot;https://hecn3mxv.mirror.aliyuncs.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart dockersudo systemctl enable docker Gnome 扩展 1sudo apt install gnome-tweaks chrome-gnome-shell CPU 微码 12sudo apt install intel-microcode #适用于Intel的CPUsudo apt install amd64-microcode #适用于AMD的CPU 优化笔记本电池寿命（使用 tlp 自动优化） 1sudo apt install tlp tlp-rdw Firejail 沙箱 1sudo apt install firejail Chrome 浏览器 渗透测试工具 添加 kali 源和数字签名 12345678#添加kali源，将下面两行写入该文件sudo vim /etc/apt/sources.listdeb http://mirrors.cloud.tencent.com/kali/ kali-rolling main contrib non-freedeb-src http://mirrors.cloud.tencent.com/kali/ kali-rolling main contrib non-free#添加数字签名wget -q -O - https://archive.kali.org/archive-key.asc | apt-key add 安装 metasploit-framework 12345# 直接安装msf就可以了sudo apt update &amp;&amp; sudo apt install metaspliot-framework# 更新msfsudo apt update; sudo apt install metasploit-framework searchsploit 这是一个 Exploit-DB 的命令行搜索工具，它还允许您随身携带漏洞利用数据库的副本。 12345# 安装漏洞利用数据库sudo apt update &amp;&amp; sudo apt -y install exploitdb# 更新数据库searchsploit -u nmap、sqlmap 1sudo apt install nmap sqlmap 安装 wireshark 123456789sudo apt install wireshark# 安装时，系统将询问你是否允许非超级用户捕获数据包。选择“Yes”允许，选择“No”限制非超级用户捕获数据包，最后完成安装# 如果在上一次安装中选择了“No”，则以 root 用户身份运行以下命令：sudo dpkg-reconfigure wireshark-commonsudo usermod -aG wireshark $(whoami) # 使用 usermod 命令将自己添加到 wireshark 组sudo groupadd wireshark # 添加wireshark用户组sudo chgrp wireshark /usr/bin/dumpcap # 将dumpcap更改为wireshark用户组sudo chmod 4755 /usr/bin/dumpcap # 让wireshark用户组有root权限使用dumpcapsudo gpasswd -a simple wireshark # 将所使用的用户名加入wireshark用户组，例如simple 安装 openvas OpenVAS 是一个可用于漏洞扫描和漏洞管理的开源套件 123456789sudo apt-get install openvassudo apt-get install sqlite3sudo openvas-nvt-syncsudo openvas-scapdata-syncsudo openvas-certdata-syncsudo service openvas-scanner restartsudo service openvas-manager restartsudo openvasmd --rebuild --progress hash 破解工具 1sudo apt install hashid hachcat johnny 截断工具：burpsuite msf 图形化界面：kage 这个工具虽然还不是很完善，但是做一些概念验证还是可以的！ 主机发现工具 1sudo apt install arping netdiscover fping hping3 端口扫描工具 1sudo apt install nmap masscan nast koncker 目录扫描工具 1234567891011# dirbsudo apt install dirb# Dirmap：一款高级Web目录文件扫描工具git clone https://github.com/H4ckForJob/dirmap.git &amp;&amp; cd dirmap &amp;&amp; python3 -m pip install -r requirement.txt# dirsearchgit clone https://github.com/maurosoria/dirsearch# Webdirscan：webdirscan是一个很简单的多线程Web目录扫描工具，它是使用Python语言编写的，主要调用了requests第三方库实现git clone https://github.com/TuuuNya/webdirscan/ 网站指纹识别 1sudo apt install whatweb web 扫描器 12341、sudo apt install nikto shipfish zaproxy2、AWVS13 （用docker安装吧，方便一点）3、nessus4、nexpose 密码破解 1sudo apt install hydra john","categories":[{"name":"tips","slug":"tips","permalink":"http://debug.cool/categories/tips/"}],"tags":[]},{"title":"碎碎念","slug":"lifeMind","date":"2016-08-01T10:44:00.000Z","updated":"2021-05-07T14:44:35.175Z","comments":true,"path":"2016/08/01/lifeMind/","link":"","permalink":"http://debug.cool/2016/08/01/lifeMind/","excerpt":"不要放弃对生命的思索，对自己的真实。","text":"不要放弃对生命的思索，对自己的真实。 2020.08 将每次谈判、每次沟通当作最后一次机会。就会谨慎地思考，严密地部署，全力一搏地行动，拥有置死地而后生的勇气。 2020.06 我不喜欢过于情绪化和过于戾气的人，甚至于会下意识远离，因为自知本身也不是耐心太好脾气太好的人。 我不觉得自己有改变他人的能力，只求好不容易培养起的耐性不会随意被耗尽。 2020.02 这个世界没有那么完美，也没有那么丑恶。我们从事网络安全的，本来就是与魔共舞。对世界的热爱，是在知道它的不完美后，依然能矢志不渝，去尽自己的绵薄之力。 2019.10 凡事有交代，件件有着落，事事有回音。 2019.06 每个人都有自己的选择。 — QS.Wang 2019.05 “增删改查”业务系统的技术含量不在于如何实现，而在于如何对现实世界的抽象，如何应对复杂的需求及变更，如何把控项目的质量和进度。 能否实现功能，会不会一门新技术只是程序员的基本要求，而且在信息如此发达的当下，这些已经没有任何难度，也不会成为程序员的核心竞争力，而深入理解计算机系统，设计能力，高质量代码能力，项目的把控能力才是要坚持苦练的内功也是架构师和码农的本质区别。 — J.Xu 2016.08 所思所想，所感所做，感极而悲。 “大难临头，何以为之。” “世受国恩，死生系之。” 往事不回头，未来不将就。","categories":[{"name":"life","slug":"life","permalink":"http://debug.cool/categories/life/"}],"tags":[]},{"title":"利用多核CPU加速Linux命令","slug":"tipsLinuxCommand","date":"2015-08-13T23:22:03.000Z","updated":"2021-05-07T07:30:39.982Z","comments":true,"path":"2015/08/14/tipsLinuxCommand/","link":"","permalink":"http://debug.cool/2015/08/14/tipsLinuxCommand/","excerpt":"要想让Linux命令使用所有的CPU内核，我们需要用到GNU Parallel命令，它让我们所有的CPU内核在单机内做神奇的map-reduce操作，当然，这还要借助很少用到的–pipes 参数(也叫做–spreadstdin)。这样，你的负载就会平均分配到各CPU上。","text":"要想让Linux命令使用所有的CPU内核，我们需要用到GNU Parallel命令，它让我们所有的CPU内核在单机内做神奇的map-reduce操作，当然，这还要借助很少用到的–pipes 参数(也叫做–spreadstdin)。这样，你的负载就会平均分配到各CPU上。 你是否曾经有过要计算一个非常大的数据(几百 GB)的需求？或在里面搜索，或其它操作——一些无法并行的操作。数据专家们，我是在对你们说。你可能有一个 4 核或更多核的 CPU，但我们合适的工具，例如 grep, bzip2, wc, awk, sed等等，都是单线程的，只能使用一个 CPU 内核。 借用卡通人物 Cartman 的话，“如何我能使用这些内核”? 要想让 Linux 命令使用所有的 CPU 内核，我们需要用到GNU Parallel命令，它让我们所有的 CPU 内核在单机内做神奇的 map-reduce 操作，当然，这还要借助很少用到的–pipes 参数(也叫做–spreadstdin)。这样，你的负载就会平均分配到各 CPU 上，真的。 BZIP2 bzip2 是比 gzip 更好的压缩工具，但它很慢！别折腾了，我们有办法解决这问题。 以前的做法： 1cat bigfile.bin | bzip2 –best &gt; compressedfile.bz2 现在这样： 1cat bigfile.bin | parallel –pipe –recend ” -k bzip2 –best &gt; compressedfile.bz2 尤其是针对 bzip2，GNU parallel 在多核 CPU 上是超级的快。你一不留神，它就执行完成了。 GREP 如果你有一个非常大的文本文件，以前你可能会这样： 1grep pattern bigfile.txt 现在你可以这样： 1cat bigfile.txt | parallel –pipe grep ‘pattern’ 或者这样： 1cat bigfile.txt | parallel –block 10M –pipe grep ‘pattern’ 这第二种用法使用了 –block 10M 参数，这是说每个内核处理 1 千万行——你可以用这个参数来调整每个 CUP 内核处理多少行数据。 AWK 下面是一个用 awk 命令计算一个非常大的数据文件的例子。 常规用法： 1cat rands20M.txt | awk ‘&#123;s+=$1&#125; END &#123;print s&#125;’ 现在这样： 1cat rands20M.txt | parallel –pipe awk \\&#x27;&#123;s+=\\$1&#125; END &#123;print s&#125;\\’ | awk ‘&#123;s+=$1&#125; END &#123;print s&#125;’ 这个有点复杂：parallel命令中的–pipe参数将cat输出分成多个块分派给awk调用，形成了很多子计算操作。这些子计算经过第二个管道进入了同一个awk命令，从而输出最终结果。第一个awk有三个反斜杠，这是GNU parallel调用awk的需要。 WC 想要最快的速度计算一个文件的行数吗？ 传统做法： 1wc -l bigfile.txt 现在你应该这样： 1cat bigfile.txt | parallel –pipe wc -l | awk ‘&#123;s+=$1&#125; END &#123;print s&#125;’ 非常的巧妙，先使用parallel命令mapping出大量的wc -l调用，形成子计算，最后通过管道发送给awk进行汇总。 SED 想在一个巨大的文件里使用 sed 命令做大量的替换操作吗？ 常规做法： 1sed s^old^new^g bigfile.txt 现在你可以： 1cat bigfile.txt | parallel –pipe sed s^old^new^g 然后你可以使用管道把输出存储到指定的文件里。","categories":[{"name":"tips","slug":"tips","permalink":"http://debug.cool/categories/tips/"}],"tags":[]},{"title":"Plan Do Review","slug":"lifePersonPlan","date":"2015-03-20T10:44:00.000Z","updated":"2021-05-07T07:30:39.981Z","comments":true,"path":"2015/03/20/lifePersonPlan/","link":"","permalink":"http://debug.cool/2015/03/20/lifePersonPlan/","excerpt":"凡事豫则立，不豫则废。言前定则不跲，事前定则不困，行前定则不疚，道前定则不穷。","text":"凡事豫则立，不豫则废。言前定则不跲，事前定则不困，行前定则不疚，道前定则不穷。 个人成长 确立个人方向，结合工作内容，找出对应短板 该领域主要专家们的工作是否了解？ 相关网络协议，文件格式是否熟悉？ 相关的技术和主要工具是否都看过？用过？ 阅读只是学习过程的起点，不能止于阅读 工具的每个参数每个菜单都要看、要试； 学习网络协议要实际抓包分析，学习文件格式要读代码实现； 学习老漏洞一定要调试，搞懂别人代码每一个字节的意义，之后要完全自己重写一个Exploit； 细节、细节、细节，刨根问底； 建立学习参考目标 短期参考什么？比自己优秀的同龄人 阅读他们的文章和其他工作成果，从细节中观察他们的学习方式和工作方式。 中期参考什么？你的方向上的业内专家 了解他们的成长轨迹，跟踪他们关注的内容。 长期参考什么？业内老牌企业和先锋企业 把握行业发展、技术趋势，为未来做积累。 推荐的学习方式 以工具为线索 一个比较省事的学习目录：Kali Linux 学习思路，以Metasploit为例： 遍历每个子目录，除了 Exploit 里面还有什么？ 每个工具分别有什么功能？原理是什么？涉及哪些知识？ 能否改进优化？能否发展、组合出新的功能？ 以专家为线索 你的技术方向里有哪些专家？ 他们的邮箱、主页、社交网络账号是什么？ 他们在该方向上有哪些作品？发表过哪些演讲？ 跟踪关注，一个一个学。 处理好学习、工作和生活 学习、工作和生活是矛盾统一的 三者都需要时间，你一天只有 24 小时 调和矛盾的关键：提高效率。 如何提高效率 做好预研，收集相关前人成果，避免无谓的重复劳动 在可行性判断阶段，能找到工具就不写代码，能用脚本语言写就不要用编译语言，能把完美主义放在最终实现阶段 做好笔记并定期整理，遗忘会让所有的投入都白费 多和同事交流，别人说的一个工具的名字可能让你节约数小时 咖啡可以提高思维效率，而且合法 无论怎么提高效率，要成为专家，都需要大量的时间投入","categories":[{"name":"life","slug":"life","permalink":"http://debug.cool/categories/life/"}],"tags":[]}],"categories":[{"name":"dev","slug":"dev","permalink":"http://debug.cool/categories/dev/"},{"name":"sec","slug":"sec","permalink":"http://debug.cool/categories/sec/"},{"name":"tips","slug":"tips","permalink":"http://debug.cool/categories/tips/"},{"name":"notes","slug":"notes","permalink":"http://debug.cool/categories/notes/"},{"name":"ops","slug":"ops","permalink":"http://debug.cool/categories/ops/"},{"name":"life","slug":"life","permalink":"http://debug.cool/categories/life/"}],"tags":[{"name":"Kafka","slug":"Kafka","permalink":"http://debug.cool/tags/Kafka/"},{"name":"Matplotlib","slug":"Matplotlib","permalink":"http://debug.cool/tags/Matplotlib/"}]}